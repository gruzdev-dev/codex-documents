// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package fhir

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type Account struct {
	// Extensions for calculatedAt
	CalculatedAt *Element `json:"_calculatedAt,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The calculated account balances - these are calculated and processed by the
	// finance system.The balances with a `term` that is not current are usually
	// generated/updated by an invoicing or similar process.
	Balance []AccountBalance `json:"balance,omitempty"`

	// The BillingStatus tracks the lifecycle of the account through the billing
	// process. It indicates how transactions are treated when they are allocated to
	// the account.
	BillingStatus *CodeableConcept `json:"billingStatus,omitempty"`

	// Time the balance amount was calculated.
	CalculatedAt_2 *Instant `json:"calculatedAt,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AccountContainedElem `json:"contained,omitempty"`

	// The party(s) that are responsible for covering the payment of this account, and
	// what order should they be applied to the account.
	Coverage []AccountCoverage `json:"coverage,omitempty"`

	// An account that collects the charges for a specific set of services offered
	// over a limited time period.  For example, a hospital account might contain all
	// charges related to a given admission, including any inpatient appointments, and
	// possibly re-admissions, of the billing for those re-admissions should be
	// grouped with the initial admission for the purpose of claim submission.
	Covers []Reference `json:"covers,omitempty"`

	// The default currency for the account.
	Currency *CodeableConcept `json:"currency,omitempty"`

	// Provides additional information about what the account tracks and how it is
	// used.
	Description_2 *Markdown `json:"description,omitempty"`

	// When using an account for billing a specific Encounter the set of diagnoses
	// that are relevant for billing are stored here on the account where they are
	// able to be sequenced appropriately prior to processing to produce claim(s).
	Diagnosis []AccountDiagnosis `json:"diagnosis,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The parties responsible for balancing the account if other payment options fall
	// short.
	Guarantor []AccountGuarantor `json:"guarantor,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique identifier used to reference the account.  Might or might not be
	// intended for human use (e.g. credit card number).
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name used for the account when displaying it to humans in reports, etc.
	Name_2 *String `json:"name,omitempty"`

	// Indicates the service area, hospital, department, etc. with responsibility for
	// managing the Account.
	Owner *Reference `json:"owner,omitempty"`

	// Reference to an associated parent Account which has this account as a
	// sub-account.
	Parent *Reference `json:"parent,omitempty"`

	// When using an account for billing a specific Encounter the set of procedures
	// that are relevant for billing are stored here on the account where they are
	// able to be sequenced appropriately prior to processing to produce claim(s).
	Procedure []AccountProcedure `json:"procedure,omitempty"`

	// This is a Account resource
	ResourceType interface{} `json:"resourceType"`

	// The date range of services associated with this account.
	ServicePeriod *Period `json:"servicePeriod,omitempty"`

	// Indicates whether the account is presently used/usable or not.
	Status_2 *Code `json:"status,omitempty"`

	// Identifies the entity which incurs the expenses. While the immediate recipients
	// of services or goods might be entities related to the subject, the expenses
	// were ultimately incurred by the subject of the Account.
	Subject []Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Categorizes the account for reporting and searching purposes.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type AccountBalance struct {
	// Extensions for estimate
	Estimate *Element `json:"_estimate,omitempty"`

	// Who is expected to pay this part of the balance.
	Aggregate *CodeableConcept `json:"aggregate,omitempty"`

	// The actual balance value calculated for the age defined in the term property.
	Amount Money `json:"amount"`

	// The amount is only an estimated value - this is likely common for `current`
	// term balances, but not with known terms (that were generated by a backend
	// process).
	Estimate_2 *Boolean `json:"estimate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The term of the account balances - The balance value is the amount that was
	// outstanding for this age.
	Term *CodeableConcept `json:"term,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountBalance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in AccountBalance: required")
	}
	type Plain AccountBalance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AccountBalance(plain)
	return nil
}

type AccountContainedElem interface{}

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type AccountCoverage struct {
	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// The party(s) that contribute to payment (or part of) of the charges applied to
	// this account (including self-pay).
	//
	// A coverage may only be responsible for specific types of charges, and the
	// sequence of the coverages in the account could be important when processing
	// billing.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The priority of the coverage in the context of this account.
	Priority_2 *PositiveInt `json:"priority,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountCoverage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in AccountCoverage: required")
	}
	type Plain AccountCoverage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AccountCoverage(plain)
	return nil
}

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type AccountDiagnosis struct {
	// Extensions for dateOfDiagnosis
	DateOfDiagnosis *Element `json:"_dateOfDiagnosis,omitempty"`

	// Extensions for onAdmission
	OnAdmission *Element `json:"_onAdmission,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The diagnosis relevant to the account.
	Condition CodeableReference `json:"condition"`

	// Ranking of the diagnosis (for each type).
	DateOfDiagnosis_2 *DateTime `json:"dateOfDiagnosis,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Was the Diagnosis present on Admission in the related Encounter.
	OnAdmission_2 *Boolean `json:"onAdmission,omitempty"`

	// The package code can be used to group diagnoses that may be priced or delivered
	// as a single product. Such as DRGs.
	PackageCode []CodeableConcept `json:"packageCode,omitempty"`

	// Ranking of the diagnosis (for each type).
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// Type that this diagnosis has relevant to the account (e.g. admission, billing,
	// discharge â€¦).
	Type []CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountDiagnosis) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["condition"]; raw != nil && !ok {
		return fmt.Errorf("field condition in AccountDiagnosis: required")
	}
	type Plain AccountDiagnosis
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AccountDiagnosis(plain)
	return nil
}

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type AccountGuarantor struct {
	// Extensions for onHold
	OnHold *Element `json:"_onHold,omitempty"`

	// Extensions for rank
	Rank *Element `json:"_rank,omitempty"`

	// Reference to a specific Account belonging to the guarantor to use.
	Account *Reference `json:"account,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The maximum amount the guarantee will pay.
	Limit *Money `json:"limit,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A guarantor may be placed on credit hold or otherwise have their role
	// temporarily suspended.
	OnHold_2 *Boolean `json:"onHold,omitempty"`

	// The entity who is responsible.
	Party *Reference `json:"party,omitempty"`

	// The timeframe during which the guarantor accepts responsibility for the
	// account.
	Period *Period `json:"period,omitempty"`

	// The order in which guarantors will be held responsible.
	Rank_2 *PositiveInt `json:"rank,omitempty"`

	// The amount (as a percentage) of the charges the guarantor is responsible.
	Responsibility *Quantity `json:"responsibility,omitempty"`
}

// A financial tool for tracking value accrued for a particular purpose.  In the
// healthcare field, used to track charges for a patient, cost centers, etc.
type AccountProcedure struct {
	// Extensions for dateOfService
	DateOfService *Element `json:"_dateOfService,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The procedure relevant to the account.
	Code CodeableReference `json:"code"`

	// Date of the procedure when using a coded procedure. If using a reference to a
	// procedure, then the date on the procedure should be used.
	DateOfService_2 *DateTime `json:"dateOfService,omitempty"`

	// Any devices that were associated with the procedure relevant to the account.
	Device []Reference `json:"device,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The package code can be used to group procedures that may be priced or
	// delivered as a single product. Such as DRGs.
	PackageCode []CodeableConcept `json:"packageCode,omitempty"`

	// Ranking of the procedure (for each type).
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// How this procedure value should be used in charging the account.
	Type []CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountProcedure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in AccountProcedure: required")
	}
	type Plain AccountProcedure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AccountProcedure(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Account) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Account: required")
	}
	type Plain Account
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Account(plain)
	return nil
}

// This resource allows for the definition of some activity to be performed,
// independent of a particular patient, practitioner, or other performance context.
type ActivityDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for asNeededBoolean
	AsNeededBoolean *Element `json:"_asNeededBoolean,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subjectCanonical
	SubjectCanonical *Element `json:"_subjectCanonical,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// If a CodeableConcept is present, it indicates the pre-condition for performing
	// the service.  For example "pain", "on flare-up", etc.
	AsNeededBoolean_2 *bool `json:"asNeededBoolean,omitempty"`

	// If a CodeableConcept is present, it indicates the pre-condition for performing
	// the service.  For example "pain", "on flare-up", etc.
	AsNeededCodeableConcept *CodeableConcept `json:"asNeededCodeableConcept,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Indicates the sites on the subject's body where the procedure should be
	// performed (I.e. the target sites).
	BodySite []CodeableConcept `json:"bodySite,omitempty"`

	// Detailed description of the type of activity; e.g. What lab test, what
	// procedure, what kind of encounter.
	Code *CodeableConcept `json:"code,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ActivityDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the activity definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the activity definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the activity definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the activity definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the activity definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// Set this to true if the definition is to indicate that a particular activity
	// should NOT be performed. If true, this element should be interpreted to
	// reinforce a negative coding. For example NPO as a code with a doNotPerform of
	// true would still indicate to NOT perform the action.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// Provides detailed dosage instructions in the same way that they are described
	// for MedicationRequest resources.
	Dosage []Dosage `json:"dosage,omitempty"`

	// Dynamic values that will be evaluated to produce values for elements of the
	// resulting resource. For example, if the dosage of a medication must be computed
	// based on the patient's weight, a dynamic value would be used to specify an
	// expression that calculated the weight, and the path on the request resource
	// that would contain the result.
	DynamicValue []ActivityDefinitionDynamicValue `json:"dynamicValue,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the activity definition content was or is planned to be
	// in active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this activity definition is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this activity definition when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Indicates the level of authority/intentionality associated with the activity
	// and where the request should fit into the workflow chain.
	Intent_2 *Code `json:"intent,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// A description of the kind of resource the activity definition is representing.
	// For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest.
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// A reference to a Library resource containing any formal logic used by the
	// activity definition.
	Library []Canonical `json:"library,omitempty"`

	// Identifies the facility where the activity will occur; e.g. home, hospital,
	// specific clinic, etc.
	Location *CodeableReference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the activity definition. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Defines observation requirements for the action to be performed, such as body
	// weight or surface area.
	ObservationRequirement []Canonical `json:"observationRequirement,omitempty"`

	// Defines the observations that are expected to be produced by the action.
	ObservationResultRequirement []Canonical `json:"observationResultRequirement,omitempty"`

	// Indicates who should participate in performing the action described.
	Participant []ActivityDefinitionParticipant `json:"participant,omitempty"`

	// Indicates how quickly the activity  should be addressed with respect to other
	// requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// Identifies the food, drug or other product being consumed or supplied in the
	// activity.
	ProductCodeableConcept *CodeableConcept `json:"productCodeableConcept,omitempty"`

	// Identifies the food, drug or other product being consumed or supplied in the
	// activity.
	ProductReference *Reference `json:"productReference,omitempty"`

	// A profile to which the target of the activity definition is expected to
	// conform.
	Profile *Canonical `json:"profile,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the activity definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this activity definition is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Identifies the quantity expected to be consumed at once (per dose, per meal,
	// etc.).
	Quantity *Quantity `json:"quantity,omitempty"`

	// Related artifacts such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a ActivityDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// Defines specimen requirements for the action to be performed, such as required
	// specimens for a lab test.
	SpecimenRequirement []Canonical `json:"specimenRequirement,omitempty"`

	// The status of this activity definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the activity being defined.  Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCanonical_2 *string `json:"subjectCanonical,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the activity being defined.  Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the activity being defined.  Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// An explanatory or alternate title for the activity definition giving additional
	// information about its content.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The timing or frequency upon which the described activity is to occur.
	TimingAge *Age `json:"timingAge,omitempty"`

	// The timing or frequency upon which the described activity is to occur.
	TimingDuration *Duration `json:"timingDuration,omitempty"`

	// The timing or frequency upon which the described activity is to occur.
	TimingRange *Range `json:"timingRange,omitempty"`

	// The timing or frequency upon which the described activity is to occur.
	TimingRelativeTime *RelativeTime `json:"timingRelativeTime,omitempty"`

	// The timing or frequency upon which the described activity is to occur.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// A short, descriptive, user-friendly title for the activity definition.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the activity. Topics provide a
	// high-level categorization of the activity that can be useful for filtering and
	// searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// A reference to a StructureMap resource that defines a transform that can be
	// executed to produce the intent resource using the ActivityDefinition instance
	// as the input.
	Transform *Canonical `json:"transform,omitempty"`

	// An absolute URI that is used to identify this activity definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this activity definition is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the activity definition is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the activity definition is used from a clinical
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate activity
	// definition instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the activity definition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the activity definition author and is not expected
	// to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
	// a managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence. To provide a version consistent
	// with the Decision Support Service specification, use the format
	// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge
	// assets, refer to the Decision Support Service specification. Note that a
	// version is required for non-experimental active assets.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type ActivityDefinitionContainedElem interface{}

// This resource allows for the definition of some activity to be performed,
// independent of a particular patient, practitioner, or other performance context.
type ActivityDefinitionDynamicValue struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// An expression specifying the value of the customized element.
	Expression Expression `json:"expression"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The path to the element to be customized. This is the path on the resource that
	// will hold the result of the calculation defined by the expression. The
	// specified path SHALL be a FHIRPath resolvable on the specified target type of
	// the ActivityDefinition, and SHALL consist only of identifiers, constant
	// indexers, and a restricted subset of functions. The path is allowed to contain
	// qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	Path_2 *String `json:"path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActivityDefinitionDynamicValue) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in ActivityDefinitionDynamicValue: required")
	}
	type Plain ActivityDefinitionDynamicValue
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ActivityDefinitionDynamicValue(plain)
	return nil
}

// This resource allows for the definition of some activity to be performed,
// independent of a particular patient, practitioner, or other performance context.
type ActivityDefinitionParticipant struct {
	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates how the actor will be involved in the action - author, reviewer,
	// witness, etc.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The role the participant should play in performing the described action.
	Role *CodeableConcept `json:"role,omitempty"`

	// The type of participant in the action.
	Type_2 *Code `json:"type,omitempty"`

	// The type of participant in the action.
	TypeCanonical *Canonical `json:"typeCanonical,omitempty"`

	// The type of participant in the action.
	TypeReference *Reference `json:"typeReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActivityDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ActivityDefinition: required")
	}
	type Plain ActivityDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SubjectCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SubjectCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SubjectCanonical_2", `^\S*$`)
		}
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ActivityDefinition(plain)
	return nil
}

// Provides a definition of an actor - a system, individual, non-system device, or
// collective - that plays a role in a process, such as data exchange, along with
// associated obligations.
type ActorDefinition struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for reference
	Reference []Element `json:"_reference,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// An ActorDefinition that is a super-type of this actor.  This actor inherits all
	// of the obligations that apply to the referenced actor definition and can be
	// used wherever the referenced ActorDefinition can.
	BaseDefinition []Canonical `json:"baseDefinition,omitempty"`

	// Further details about the type of actor.
	Category []CodeableConcept `json:"category,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ActorDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the actor definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the actor definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the actor definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the actor definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the actor.
	Description_2 *Markdown `json:"description,omitempty"`

	// Details describing the nature of the actor as well as boundaries that
	// distinguish this type of actor from other actors.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// A Boolean value to indicate that this actor definition is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this actor definition when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the actor definition. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the actor definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this actor definition is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// A reference to additional documentation about the actor, but description and
	// documentation.
	Reference_2 []Url `json:"reference,omitempty"`

	// This is a ActorDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this actor definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the actor definition.
	Title_2 *String `json:"title,omitempty"`

	// What type of actor this is.
	Type_2 *Code `json:"type,omitempty"`

	// An absolute URI that is used to identify this actor definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this actor definition is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the actor definition is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate actor definition
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the actor definition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the actor definition author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type ActorDefinitionContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActorDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ActorDefinition: required")
	}
	type Plain ActorDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ActorDefinition(plain)
	return nil
}

// An address expressed using postal conventions (as opposed to GPS or other
// location definition formats).  This data type may be used to convey addresses
// for use in delivering mail as well as for visiting locations which might not be
// valid for mail delivery.  There are a variety of postal address formats defined
// around the world.
// The ISO21090-codedString may be used to provide a coded representation of the
// contents of strings in an Address.
type Address struct {
	// Extensions for city
	City *Element `json:"_city,omitempty"`

	// Extensions for country
	Country *Element `json:"_country,omitempty"`

	// Extensions for district
	District *Element `json:"_district,omitempty"`

	// Extensions for line
	Line []Element `json:"_line,omitempty"`

	// Extensions for postalCode
	PostalCode *Element `json:"_postalCode,omitempty"`

	// Extensions for state
	State *Element `json:"_state,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// The name of the city, town, suburb, village or other community or delivery
	// center.
	City_2 *String `json:"city,omitempty"`

	// Country - a nation as commonly understood or generally accepted.
	Country_2 *String `json:"country,omitempty"`

	// The name of the administrative area (county).
	District_2 *String `json:"district,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// This component contains the house number, apartment number, street name, street
	// direction,  P.O. Box number, delivery hints, and similar address information.
	Line_2 []String `json:"line,omitempty"`

	// Time period when address was/is in use.
	Period *Period `json:"period,omitempty"`

	// A postal code designating a region defined by the postal service.
	PostalCode_2 *String `json:"postalCode,omitempty"`

	// Sub-unit of a country with limited sovereignty in a federally organized
	// country. A code may be used if codes are in common use (e.g. US 2 letter state
	// codes).
	State_2 *String `json:"state,omitempty"`

	// Specifies the entire address as it should be displayed e.g. on a postal label,
	// using a newline delimiter for each line (e.g., \n). This may be provided
	// instead of or as well as the specific parts.
	Text_2 *String `json:"text,omitempty"`

	// Distinguishes between physical addresses (those you can visit) and mailing
	// addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
	Type_2 *AddressType_2 `json:"type,omitempty"`

	// The purpose of this address.
	Use_2 *AddressUse_2 `json:"use,omitempty"`
}

type AddressType_2 string

const AddressType_2_Both AddressType_2 = "both"
const AddressType_2_Physical AddressType_2 = "physical"
const AddressType_2_Postal AddressType_2 = "postal"

var enumValues_AddressType_2 = []interface{}{
	"postal",
	"physical",
	"both",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddressType_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AddressType_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AddressType_2, v)
	}
	*j = AddressType_2(v)
	return nil
}

type AddressUse_2 string

const AddressUse_2_Billing AddressUse_2 = "billing"
const AddressUse_2_Home AddressUse_2 = "home"
const AddressUse_2_Old AddressUse_2 = "old"
const AddressUse_2_Temp AddressUse_2 = "temp"
const AddressUse_2_Work AddressUse_2 = "work"

var enumValues_AddressUse_2 = []interface{}{
	"home",
	"work",
	"temp",
	"old",
	"billing",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddressUse_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AddressUse_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AddressUse_2, v)
	}
	*j = AddressUse_2(v)
	return nil
}

// A medicinal product in the final form which is suitable for administering to a
// patient (after any mixing of multiple components, dissolution etc. has been
// performed).
type AdministrableProductDefinition struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The dose form of the final product after necessary reconstitution or
	// processing. Contrasts to the manufactured dose form (see
	// ManufacturedItemDefinition). If the manufactured form was 'powder for solution
	// for injection', the administrable dose form could be 'solution for injection'
	// (once mixed with another item having manufactured form 'solvent for solution
	// for injection').
	AdministrableDoseForm *CodeableConcept `json:"administrableDoseForm,omitempty"`

	// A code that this product is known by, within some formal terminology. May be a
	// PhPID. PhPID is really a code or a label, and not an identifier, because it
	// applies to multiple products.
	Code []Coding `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AdministrableProductDefinitionContainedElem `json:"contained,omitempty"`

	// A general description of the product, when in its final form, suitable for
	// administration e.g. effervescent blue liquid, to be swallowed. Intended to be
	// used when the other structured properties of this resource are insufficient or
	// cannot be supported. It is not intended to duplicate information already
	// carried elsewhere.
	Description_2 *Markdown `json:"description,omitempty"`

	// A device that is integral to the medicinal product, in effect being considered
	// as an "ingredient" of the medicinal product. This is not intended for devices
	// that are just co-packaged.
	Device *Reference `json:"device,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// References a product from which one or more of the constituent parts of that
	// product can be prepared and used as described by this administrable product.
	// If this administrable product describes the administration of a crushed tablet,
	// the 'formOf' would be the product representing a distribution containing
	// tablets and possibly also a cream.  This is distinct from the 'producedFrom'
	// which refers to the specific components of the product that are used in this
	// preparation, rather than the product as a whole.
	FormOf []Reference `json:"formOf,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// An identifier for the administrable product instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The ingredients of this administrable medicinal product. This is only needed if
	// the ingredients are not specified either using ManufacturedItemDefinition (via
	// AdministrableProductDefinition.producedFrom) to state which component items are
	// used to make this, or using by incoming references from the Ingredient
	// resource, to state in detail which substances exist within this. This element
	// allows a basic coded ingredient to be used.
	Ingredient []CodeableConcept `json:"ingredient,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the specific manufactured items that are part of the 'formOf' product
	// that are used in the preparation of this specific administrable form.  In some
	// cases, an administrable form might use all of the items from the overall
	// product (or there might only be one item), while in other cases, an
	// administrable form might use only a subset of the items available in the
	// overall product.  For example, an administrable form might involve combining a
	// liquid and a powder available as part of an overall product, but not involve
	// applying the also supplied cream. For consistency, it is acceptable to refer to
	// the manufactured item in all cases - from complex many-to-many to simple
	// one-to-one cases - even when there is no transformation or combining involved
	// between the manufactured form and the administrable form. For example an oral
	// solid tablet is usually administered without any transformation or combination,
	// but the administrable form can still be represented as 'producedFrom' the
	// single manufactured tablet.
	ProducedFrom []Reference `json:"producedFrom,omitempty"`

	// Characteristics e.g. a product's onset of action.
	Property []AdministrableProductDefinitionProperty `json:"property,omitempty"`

	// This is a AdministrableProductDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The path by which the product is taken into or makes contact with the body. In
	// some regions this is referred to as the licensed or approved route.
	// RouteOfAdministration cannot be used when the 'formOf' product already uses
	// MedicinalProductDefinition.route (and vice versa).
	RouteOfAdministration []AdministrableProductDefinitionRouteOfAdministration `json:"routeOfAdministration"`

	// The status of this administrable product. Enables tracking the life-cycle of
	// the content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The presentation type in which this item is given to a patient. e.g. for a
	// spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial'
	// (as in 'contains 5 ml per vial').
	UnitOfPresentation *CodeableConcept `json:"unitOfPresentation,omitempty"`
}

type AdministrableProductDefinitionContainedElem interface{}

// A medicinal product in the final form which is suitable for administering to a
// patient (after any mixing of multiple components, dissolution etc. has been
// performed).
type AdministrableProductDefinitionProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The status of characteristic e.g. assigned or pending.
	Status *CodeableConcept `json:"status,omitempty"`

	// A code expressing the type of characteristic.
	Type CodeableConcept `json:"type"`

	// A value for the characteristic.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// A value for the characteristic.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// A value for the characteristic.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value for the characteristic.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A value for the characteristic.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// A value for the characteristic.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A value for the characteristic.
	ValueRange *Range `json:"valueRange,omitempty"`

	// A value for the characteristic.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdministrableProductDefinitionProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AdministrableProductDefinitionProperty: required")
	}
	type Plain AdministrableProductDefinitionProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	*j = AdministrableProductDefinitionProperty(plain)
	return nil
}

// A medicinal product in the final form which is suitable for administering to a
// patient (after any mixing of multiple components, dissolution etc. has been
// performed).
type AdministrableProductDefinitionRouteOfAdministration struct {
	// Coded expression for the route.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The first dose (dose quantity) administered can be specified for the product,
	// using a numerical value and its unit of measurement.
	FirstDose *Quantity `json:"firstDose,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The maximum dose per day (maximum dose quantity to be administered in any one
	// 24-h period) that can be administered.
	MaxDosePerDay *Quantity `json:"maxDosePerDay,omitempty"`

	// The maximum dose per treatment period that can be administered.
	MaxDosePerTreatmentPeriod *Ratio `json:"maxDosePerTreatmentPeriod,omitempty"`

	// The maximum single dose that can be administered, specified using a numerical
	// value and its unit of measurement.
	MaxSingleDose *Quantity `json:"maxSingleDose,omitempty"`

	// The maximum treatment period during which the product can be administered.
	MaxTreatmentPeriod *Duration `json:"maxTreatmentPeriod,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A species for which this route applies.
	TargetSpecies []AdministrableProductDefinitionTargetSpecies `json:"targetSpecies,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdministrableProductDefinitionRouteOfAdministration) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in AdministrableProductDefinitionRouteOfAdministration: required")
	}
	type Plain AdministrableProductDefinitionRouteOfAdministration
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AdministrableProductDefinitionRouteOfAdministration(plain)
	return nil
}

// A medicinal product in the final form which is suitable for administering to a
// patient (after any mixing of multiple components, dissolution etc. has been
// performed).
type AdministrableProductDefinitionTargetSpecies struct {
	// Coded expression for the species.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A species specific time during which consumption of animal product is not
	// appropriate.
	WithdrawalPeriod []AdministrableProductDefinitionWithdrawalPeriod `json:"withdrawalPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdministrableProductDefinitionTargetSpecies) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in AdministrableProductDefinitionTargetSpecies: required")
	}
	type Plain AdministrableProductDefinitionTargetSpecies
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AdministrableProductDefinitionTargetSpecies(plain)
	return nil
}

// A medicinal product in the final form which is suitable for administering to a
// patient (after any mixing of multiple components, dissolution etc. has been
// performed).
type AdministrableProductDefinitionWithdrawalPeriod struct {
	// Extensions for supportingInformation
	SupportingInformation *Element `json:"_supportingInformation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Extra information about the withdrawal period.
	SupportingInformation_2 *String `json:"supportingInformation,omitempty"`

	// Coded expression for the type of tissue for which the withdrawal period
	// applies, e.g. meat, milk.
	Tissue CodeableConcept `json:"tissue"`

	// A value for the time.
	Value Quantity `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdministrableProductDefinitionWithdrawalPeriod) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tissue"]; raw != nil && !ok {
		return fmt.Errorf("field tissue in AdministrableProductDefinitionWithdrawalPeriod: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in AdministrableProductDefinitionWithdrawalPeriod: required")
	}
	type Plain AdministrableProductDefinitionWithdrawalPeriod
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AdministrableProductDefinitionWithdrawalPeriod(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdministrableProductDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in AdministrableProductDefinition: required")
	}
	if _, ok := raw["routeOfAdministration"]; raw != nil && !ok {
		return fmt.Errorf("field routeOfAdministration in AdministrableProductDefinition: required")
	}
	type Plain AdministrableProductDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AdministrableProductDefinition(plain)
	return nil
}

// An event (i.e. any change to current patient status) that may be related to
// unintended effects on a patient or research participant. The unintended effects
// may require additional monitoring, treatment, hospitalization, or may result in
// death. The AdverseEvent resource also extends to potential or avoided events
// that could have had such effects. There are two major domains where the
// AdverseEvent resource is expected to be used. One is in clinical care reported
// adverse events and the other is in reporting adverse events in clinical
// research trial management. Adverse events can be reported by healthcare
// providers, patients, caregivers or by medical products manufacturers. Given the
// differences between these two concepts, we recommend consulting the domain
// specific implementation guides when implementing the AdverseEvent Resource. The
// implementation guides include specific extensions, value sets and constraints.
type AdverseEvent struct {
	// Extensions for actuality
	Actuality *Element `json:"_actuality,omitempty"`

	// Extensions for detected
	Detected *Element `json:"_detected,omitempty"`

	// Extensions for effectDateTime
	EffectDateTime *Element `json:"_effectDateTime,omitempty"`

	// Extensions for expectedInResearchStudy
	ExpectedInResearchStudy *Element `json:"_expectedInResearchStudy,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for recordedDate
	RecordedDate *Element `json:"_recordedDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Whether the event actually happened or was a near miss. Note that this is
	// independent of whether anyone was affected or harmed or how severely.
	Actuality_2 *Code `json:"actuality,omitempty"`

	// The overall type of event, intended for search and filtering purposes.
	Category []CodeableConcept `json:"category,omitempty"`

	// Specific event that occurred or that was averted, such as patient fall, wrong
	// organ removed, or wrong blood transfused.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AdverseEventContainedElem `json:"contained,omitempty"`

	// The contributing factors suspected to have increased the probability or
	// severity of the adverse event.
	ContributingFactor []CodeableReference `json:"contributingFactor,omitempty"`

	// Estimated or actual date the AdverseEvent began, in the opinion of the
	// reporter.
	Detected_2 *DateTime `json:"detected,omitempty"`

	// The date (and perhaps time) when the effect of the AdverseEvent occurred.
	EffectDateTime_2 *string `json:"effectDateTime,omitempty"`

	// The date (and perhaps time) when the effect of the AdverseEvent occurred.
	EffectPeriod *Period `json:"effectPeriod,omitempty"`

	// The Encounter associated with the start of the AdverseEvent.
	Encounter *Reference `json:"encounter,omitempty"`

	// Considered likely or probable or anticipated in the research study.  Whether
	// the reported event matches any of the outcomes for the patient that are
	// considered by the study as known or likely.
	ExpectedInResearchStudy_2 *Boolean `json:"expectedInResearchStudy,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this adverse event by the performer or other
	// systems which remain constant as the resource is updated and propagates from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The information about where the adverse event occurred.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The ameliorating action taken after the adverse event occurred in order to
	// reduce the extent of harm.
	MitigatingAction []CodeableReference `json:"mitigatingAction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the adverse event by the performer, subject or other
	// participants.
	Note []Annotation `json:"note,omitempty"`

	// Describes the type of outcome from the adverse event, such as resolved,
	// recovering, ongoing, resolved-with-sequelae, or fatal.
	Outcome []CodeableConcept `json:"outcome,omitempty"`

	// Indicates who or what participated in the adverse event and how they were
	// involved.
	Participant []AdverseEventParticipant `json:"participant,omitempty"`

	// Preventive actions that contributed to avoiding the adverse event.
	PreventiveAction []CodeableReference `json:"preventiveAction,omitempty"`

	// The date on which the existence of the AdverseEvent was first recorded.
	RecordedDate_2 *DateTime `json:"recordedDate,omitempty"`

	// Information on who recorded the adverse event.  May be the patient or a
	// practitioner.
	Recorder *Reference `json:"recorder,omitempty"`

	// This is a AdverseEvent resource
	ResourceType interface{} `json:"resourceType"`

	// Information about the condition that occurred as a result of the adverse event,
	// such as hives due to the exposure to a substance (for example, a drug or a
	// chemical) or a broken leg as a result of the fall.
	ResultingEffect []CodeableReference `json:"resultingEffect,omitempty"`

	// Assessment whether this event, or averted event, was of clinical importance.
	Seriousness *CodeableConcept `json:"seriousness,omitempty"`

	// The current state of the adverse event or potential adverse event.
	Status_2 *Code `json:"status,omitempty"`

	// The research study that the subject is enrolled in.
	Study []Reference `json:"study,omitempty"`

	// This subject or group impacted by the event.
	Subject Reference `json:"subject"`

	// Relevant past history for the subject. In a clinical care context, an example
	// being a patient had an adverse event following a penicillin administration and
	// the patient had a previously documented penicillin allergy. In a clinical
	// trials context, an example is a bunion or rash that was present prior to the
	// study. Additionally, the supporting item can be a document that is relevant to
	// this instance of the adverse event that is not part of the subject's medical
	// history. For example, a clinical note, staff list, or material safety data
	// sheet (MSDS).  Supporting information is not a contributing factor, preventive
	// action, or mitigating action.
	SupportingInfo []CodeableReference `json:"supportingInfo,omitempty"`

	// Describes the entity that is suspected to have caused the adverse event.
	SuspectEntity []AdverseEventSuspectEntity `json:"suspectEntity,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// An event (i.e. any change to current patient status) that may be related to
// unintended effects on a patient or research participant. The unintended effects
// may require additional monitoring, treatment, hospitalization, or may result in
// death. The AdverseEvent resource also extends to potential or avoided events
// that could have had such effects. There are two major domains where the
// AdverseEvent resource is expected to be used. One is in clinical care reported
// adverse events and the other is in reporting adverse events in clinical
// research trial management. Adverse events can be reported by healthcare
// providers, patients, caregivers or by medical products manufacturers. Given the
// differences between these two concepts, we recommend consulting the domain
// specific implementation guides when implementing the AdverseEvent Resource. The
// implementation guides include specific extensions, value sets and constraints.
type AdverseEventCausality struct {
	// The method of evaluating the relatedness of the suspected entity to the event.
	AssessmentMethod *CodeableConcept `json:"assessmentMethod,omitempty"`

	// The author of the information on the possible cause of the event.
	Author *Reference `json:"author,omitempty"`

	// The result of the assessment regarding the relatedness of the suspected entity
	// to the event.
	EntityRelatedness *CodeableConcept `json:"entityRelatedness,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type AdverseEventContainedElem interface{}

// An event (i.e. any change to current patient status) that may be related to
// unintended effects on a patient or research participant. The unintended effects
// may require additional monitoring, treatment, hospitalization, or may result in
// death. The AdverseEvent resource also extends to potential or avoided events
// that could have had such effects. There are two major domains where the
// AdverseEvent resource is expected to be used. One is in clinical care reported
// adverse events and the other is in reporting adverse events in clinical
// research trial management. Adverse events can be reported by healthcare
// providers, patients, caregivers or by medical products manufacturers. Given the
// differences between these two concepts, we recommend consulting the domain
// specific implementation guides when implementing the AdverseEvent Resource. The
// implementation guides include specific extensions, value sets and constraints.
type AdverseEventParticipant struct {
	// Indicates who or what participated in the event.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of involvement of the actor in the adverse event, such
	// as contributor or informant.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdverseEventParticipant) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in AdverseEventParticipant: required")
	}
	type Plain AdverseEventParticipant
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AdverseEventParticipant(plain)
	return nil
}

// An event (i.e. any change to current patient status) that may be related to
// unintended effects on a patient or research participant. The unintended effects
// may require additional monitoring, treatment, hospitalization, or may result in
// death. The AdverseEvent resource also extends to potential or avoided events
// that could have had such effects. There are two major domains where the
// AdverseEvent resource is expected to be used. One is in clinical care reported
// adverse events and the other is in reporting adverse events in clinical
// research trial management. Adverse events can be reported by healthcare
// providers, patients, caregivers or by medical products manufacturers. Given the
// differences between these two concepts, we recommend consulting the domain
// specific implementation guides when implementing the AdverseEvent Resource. The
// implementation guides include specific extensions, value sets and constraints.
type AdverseEventSuspectEntity struct {
	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Information on the possible cause of the event.
	Causality *AdverseEventCausality `json:"causality,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifies the actual instance of what caused the adverse event.  May be a
	// substance, medication, medication administration, medication statement or a
	// device.
	Instance CodeableReference `json:"instance"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The date (and perhaps time) when the suspect entity occurred.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The date (and perhaps time) when the suspect entity occurred.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdverseEventSuspectEntity) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["instance"]; raw != nil && !ok {
		return fmt.Errorf("field instance in AdverseEventSuspectEntity: required")
	}
	type Plain AdverseEventSuspectEntity
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = AdverseEventSuspectEntity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdverseEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in AdverseEvent: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in AdverseEvent: required")
	}
	type Plain AdverseEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EffectDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.EffectDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = AdverseEvent(plain)
	return nil
}

// A duration of time during which an organism (or a process) has existed.
type Age struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A computer processable form of the unit in some unit representation system.
	Code_2 *Code `json:"code,omitempty"`

	// How the value should be understood and represented - whether the actual value
	// is greater or less than the stated value due to measurement issues; e.g. if the
	// comparator is "<" , then the real value is < stated value.
	Comparator_2 *AgeComparator_2 `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the system that provides the coded form of the unit.
	System_2 *Uri `json:"system,omitempty"`

	// A human-readable form of the unit.
	Unit_2 *String `json:"unit,omitempty"`

	// The value of the measured amount. The value includes an implicit precision in
	// the presentation of the value.
	Value_2 *Decimal `json:"value,omitempty"`
}

type AgeComparator_2 string

const AgeComparator_2_Ad AgeComparator_2 = "ad"
const AgeComparator_2_GE AgeComparator_2 = ">="
const AgeComparator_2_GT AgeComparator_2 = ">"
const AgeComparator_2_LE AgeComparator_2 = "<="
const AgeComparator_2_LT AgeComparator_2 = "<"

var enumValues_AgeComparator_2 = []interface{}{
	"<",
	"<=",
	">=",
	">",
	"ad",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgeComparator_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AgeComparator_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AgeComparator_2, v)
	}
	*j = AgeComparator_2(v)
	return nil
}

// Risk of harmful or undesirable physiological response which is specific to an
// individual and associated with exposure to a substance.
type AllergyIntolerance struct {
	// Extensions for category
	Category []Element `json:"_category,omitempty"`

	// Extensions for criticality
	Criticality *Element `json:"_criticality,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReactionOccurrence
	LastReactionOccurrence *Element `json:"_lastReactionOccurrence,omitempty"`

	// Extensions for onsetDateTime
	OnsetDateTime *Element `json:"_onsetDateTime,omitempty"`

	// Extensions for onsetString
	OnsetString *Element `json:"_onsetString,omitempty"`

	// Extensions for recordedDate
	RecordedDate *Element `json:"_recordedDate,omitempty"`

	// The source of the information about the allergy that is recorded.
	Asserter *Reference `json:"asserter,omitempty"`

	// Category of the identified substance.
	Category_2 []Code `json:"category,omitempty"`

	// The clinical status of the allergy or intolerance.
	ClinicalStatus *CodeableConcept `json:"clinicalStatus,omitempty"`

	// Code for an allergy or intolerance statement (either a positive or a
	// negated/excluded statement).  This may be a code for a substance or
	// pharmaceutical product that is considered to be responsible for the adverse
	// reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g.,
	// "Latex allergy"), or a negated/excluded code for a specific substance or class
	// (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,
	// "No known allergy", "No known drug allergies").  Note: the substance for a
	// specific reaction may be different from the substance identified as the cause
	// of the risk, but it must be consistent with it. For instance, it may be a more
	// specific substance (e.g. a brand medication) or a composite product that
	// includes the identified substance. It must be clinically safe to only process
	// the 'code' and ignore the 'reaction.substance'.  If a receiving system is
	// unable to confirm that AllergyIntolerance.reaction.substance falls within the
	// semantic scope of AllergyIntolerance.code, then the receiving system should
	// ignore AllergyIntolerance.reaction.substance.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AllergyIntoleranceContainedElem `json:"contained,omitempty"`

	// Estimate of the potential clinical harm, or seriousness, of the reaction to the
	// identified substance.
	Criticality_2 *Code `json:"criticality,omitempty"`

	// The encounter when the allergy or intolerance was asserted.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this AllergyIntolerance by the performer or
	// other systems which remain constant as the resource is updated and propagates
	// from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Represents the date and/or time of the last known occurrence of a reaction
	// event.
	LastReactionOccurrence_2 *DateTime `json:"lastReactionOccurrence,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional narrative about the propensity for the Adverse Reaction, not
	// captured in other fields.
	Note []Annotation `json:"note,omitempty"`

	// Estimated or actual date,  date-time, or age when allergy or intolerance was
	// identified.
	OnsetAge *Age `json:"onsetAge,omitempty"`

	// Estimated or actual date,  date-time, or age when allergy or intolerance was
	// identified.
	OnsetDateTime_2 *string `json:"onsetDateTime,omitempty"`

	// Estimated or actual date,  date-time, or age when allergy or intolerance was
	// identified.
	OnsetPeriod *Period `json:"onsetPeriod,omitempty"`

	// Estimated or actual date,  date-time, or age when allergy or intolerance was
	// identified.
	OnsetRange *Range `json:"onsetRange,omitempty"`

	// Estimated or actual date,  date-time, or age when allergy or intolerance was
	// identified.
	OnsetString_2 *string `json:"onsetString,omitempty"`

	// The patient who has the allergy or intolerance.
	Patient Reference `json:"patient"`

	// Details about each adverse reaction event linked to exposure to the identified
	// substance.
	Reaction []AllergyIntoleranceReaction `json:"reaction,omitempty"`

	// The recordedDate represents when this particular AllergyIntolerance record was
	// created in the system, which is often a system-generated date.
	RecordedDate_2 *DateTime `json:"recordedDate,omitempty"`

	// Individual who recorded the record and takes responsibility for accurately
	// recording its content.
	Recorder *Reference `json:"recorder,omitempty"`

	// This is a AllergyIntolerance resource
	ResourceType interface{} `json:"resourceType"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Identification of the underlying physiological mechanism for the reaction risk.
	Type *CodeableConcept `json:"type,omitempty"`

	// Assertion about certainty associated with the propensity, or potential risk, of
	// a reaction to the identified substance (including pharmaceutical product).  The
	// verification status pertains to the allergy or intolerance, itself, not to any
	// specific AllergyIntolerance attribute.
	VerificationStatus *CodeableConcept `json:"verificationStatus,omitempty"`
}

type AllergyIntoleranceContainedElem interface{}

// Risk of harmful or undesirable physiological response which is specific to an
// individual and associated with exposure to a substance.
type AllergyIntoleranceReaction struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for onset
	Onset *Element `json:"_onset,omitempty"`

	// Extensions for severity
	Severity *Element `json:"_severity,omitempty"`

	// Text description about the reaction as a whole, including details of the
	// manifestation if required.
	Description_2 *String `json:"description,omitempty"`

	// Identification of the route by which the subject was exposed to the substance.
	ExposureRoute *CodeableConcept `json:"exposureRoute,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Clinical symptoms and/or signs that are observed or associated with the adverse
	// reaction event.
	Manifestation []CodeableReference `json:"manifestation"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional text about the adverse reaction event not captured in other fields.
	Note []Annotation `json:"note,omitempty"`

	// Record of the date and/or time of the onset of the Reaction.
	Onset_2 *DateTime `json:"onset,omitempty"`

	// Clinical assessment of the severity of the reaction event as a whole,
	// potentially considering multiple different manifestations.
	Severity_2 *Code `json:"severity,omitempty"`

	// Identification of the specific substance (or pharmaceutical product) considered
	// to be responsible for the Adverse Reaction event. Note: the substance for a
	// specific reaction may be different from the substance identified as the cause
	// of the risk, but it must be consistent with it. For instance, it may be a more
	// specific substance (e.g. a brand medication) or a composite product that
	// includes the identified substance. It must be clinically safe to only process
	// the 'code' and ignore the 'reaction.substance'.  If a receiving system is
	// unable to confirm that AllergyIntolerance.reaction.substance falls within the
	// semantic scope of AllergyIntolerance.code, then the receiving system should
	// ignore AllergyIntolerance.reaction.substance.
	Substance *CodeableConcept `json:"substance,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AllergyIntoleranceReaction) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["manifestation"]; raw != nil && !ok {
		return fmt.Errorf("field manifestation in AllergyIntoleranceReaction: required")
	}
	type Plain AllergyIntoleranceReaction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AllergyIntoleranceReaction(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AllergyIntolerance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in AllergyIntolerance: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in AllergyIntolerance: required")
	}
	type Plain AllergyIntolerance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OnsetDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OnsetDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OnsetDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.OnsetString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.OnsetString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OnsetString_2", `^^[\s\S]+$$`)
		}
	}
	*j = AllergyIntolerance(plain)
	return nil
}

// A  text note which also  contains information about who made the statement and
// when.
type Annotation struct {
	// Extensions for authorString
	AuthorString *Element `json:"_authorString,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for time
	Time *Element `json:"_time,omitempty"`

	// The individual responsible for making the annotation.
	AuthorReference *Reference `json:"authorReference,omitempty"`

	// The individual responsible for making the annotation.
	AuthorString_2 *string `json:"authorString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The text of the annotation in markdown format.
	Text_2 *Markdown `json:"text,omitempty"`

	// Indicates when this particular annotation was made.
	Time_2 *DateTime `json:"time,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Annotation) UnmarshalJSON(value []byte) error {
	type Plain Annotation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AuthorString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AuthorString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AuthorString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Annotation(plain)
	return nil
}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type Appointment struct {
	// Extensions for cancellationDate
	CancellationDate *Element `json:"_cancellationDate,omitempty"`

	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for end
	End *Element `json:"_end,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for minutesDuration
	MinutesDuration *Element `json:"_minutesDuration,omitempty"`

	// Extensions for occurrenceChanged
	OccurrenceChanged *Element `json:"_occurrenceChanged,omitempty"`

	// Extensions for recurrenceId
	RecurrenceID *Element `json:"_recurrenceId,omitempty"`

	// Extensions for start
	Start *Element `json:"_start,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The set of accounts that is expected to be used for billing the activities that
	// result from this Appointment.
	Account []Reference `json:"account,omitempty"`

	// The style of appointment or patient that has been booked in the slot (not
	// service type).
	AppointmentType *CodeableConcept `json:"appointmentType,omitempty"`

	// The request this appointment is allocated to assess (e.g. incoming referral or
	// procedure request).
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The date/time describing when the appointment was cancelled.
	CancellationDate_2 *DateTime `json:"cancellationDate,omitempty"`

	// The coded reason for the appointment being cancelled. This is often used in
	// reporting/billing/further processing to determine if further actions are
	// required, or specific fees apply.
	CancellationReason *CodeableConcept `json:"cancellationReason,omitempty"`

	// Concepts representing classification of patient encounter such as ambulatory
	// (outpatient), inpatient, emergency, home health or others due to local
	// variations.
	Class []CodeableConcept `json:"class,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AppointmentContainedElem `json:"contained,omitempty"`

	// The date that this appointment was initially created. This could be different
	// to the meta.lastModified value on the initial entry, as this could have been
	// before the resource was created on the FHIR server, and should remain unchanged
	// over the lifespan of the appointment.
	Created_2 *DateTime `json:"created,omitempty"`

	// The brief description of the appointment as would be shown on a subject line in
	// a meeting request, or appointment list. Detailed or expanded information should
	// be put in the note field.
	Description_2 *String `json:"description,omitempty"`

	// Date/Time that the appointment is to conclude.
	End_2 *Instant `json:"end,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// This records identifiers associated with this appointment concern that are
	// defined by business processes and/or used to refer to it when a direct URL
	// reference to the resource itself is not appropriate (e.g. in CDA documents, or
	// in written / printed documentation).
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// Number of minutes that the appointment is to take. This can be less than the
	// duration between the start and end times.  For example, where the actual time
	// of appointment is only an estimate or if a 30 minute appointment is being
	// requested, but any time would work.  Also, if there is, for example, a planned
	// 15 minute break in the middle of a long appointment, the duration may be 15
	// minutes less than the difference between the start and end.
	MinutesDuration_2 *PositiveInt `json:"minutesDuration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional notes/comments about the appointment.
	Note []Annotation `json:"note,omitempty"`

	// This appointment varies from the recurring pattern.
	OccurrenceChanged_2 *Boolean `json:"occurrenceChanged,omitempty"`

	// The originating appointment in a recurring set of related appointments.
	OriginatingAppointment *Reference `json:"originatingAppointment,omitempty"`

	// List of participants involved in the appointment.
	Participant []AppointmentParticipant `json:"participant"`

	// While Appointment.note contains information for internal use,
	// Appointment.patientInstructions is used to capture patient facing information
	// about the Appointment (e.g. please bring your referral or fast from 8pm night
	// before).
	PatientInstruction []CodeableReference `json:"patientInstruction,omitempty"`

	// The previous appointment in a series of related appointments.
	PreviousAppointment *Reference `json:"previousAppointment,omitempty"`

	// The priority of the appointment. Can be used to make informed decisions if
	// needing to re-prioritize appointments. (The iCal Standard specifies 0 as
	// undefined, 1 as highest, 9 as lowest priority).
	Priority *CodeableConcept `json:"priority,omitempty"`

	// The reason that this appointment is being scheduled. This is more clinical than
	// administrative. This can be coded, or as specified using information from
	// another resource. When the patient arrives and the encounter begins it may be
	// used as the admission diagnosis. The indication will typically be a Condition
	// (with other resources referenced in the evidence.detail), or a Procedure.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The sequence number that identifies a specific appointment in a recurring
	// pattern.
	RecurrenceID_2 *PositiveInt `json:"recurrenceId,omitempty"`

	// The details of the recurrence pattern or template that is used to generate
	// recurring appointments.
	RecurrenceTemplate []AppointmentRecurrenceTemplate `json:"recurrenceTemplate,omitempty"`

	// Appointment replaced by this Appointment in cases where there is a
	// cancellation, the details of the cancellation can be found in the
	// cancellationReason property (on the referenced resource).
	Replaces []Reference `json:"replaces,omitempty"`

	// A set of date ranges (potentially including times) that the appointment is
	// preferred to be scheduled within.
	//
	// The duration (usually in minutes) could also be provided to indicate the length
	// of the appointment to fill and populate the start/end times for the actual
	// allocated time. However, in other situations the duration may be calculated by
	// the scheduling system.
	RequestedPeriod []Period `json:"requestedPeriod,omitempty"`

	// This is a Appointment resource
	ResourceType interface{} `json:"resourceType"`

	// A broad categorization of the service that is to be performed during this
	// appointment.
	ServiceCategory []CodeableConcept `json:"serviceCategory,omitempty"`

	// The specific service that is to be performed during this appointment.
	ServiceType []CodeableReference `json:"serviceType,omitempty"`

	// The slots from the participants' schedules that will be filled by the
	// appointment.
	Slot []Reference `json:"slot,omitempty"`

	// The specialty of a practitioner that would be required to perform the service
	// requested in this appointment.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// Date/Time that the appointment is to take place.
	Start_2 *Instant `json:"start,omitempty"`

	// The overall status of the Appointment. Each of the participants has their own
	// participation status which indicates their involvement in the process, however
	// this status indicates the shared status.
	Status_2 *Code `json:"status,omitempty"`

	// The patient or group associated with the appointment, if they are to be present
	// (usually) then they should also be included in the participant backbone
	// element.
	Subject *Reference `json:"subject,omitempty"`

	// Additional information to support the appointment provided when making the
	// appointment.
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Connection details of a virtual service (e.g. conference call).
	VirtualService []VirtualServiceDetail `json:"virtualService,omitempty"`
}

type AppointmentContainedElem interface{}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type AppointmentMonthlyTemplate struct {
	// Extensions for dayOfMonth
	DayOfMonth *Element `json:"_dayOfMonth,omitempty"`

	// Extensions for monthInterval
	MonthInterval *Element `json:"_monthInterval,omitempty"`

	// Indicates that appointments in the series of recurring appointments should
	// occur on a specific day of the month.
	DayOfMonth_2 *PositiveInt `json:"dayOfMonth,omitempty"`

	// Indicates which day of the week the recurring appointments should occur each
	// nth week.
	DayOfWeek *Coding `json:"dayOfWeek,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates that recurring appointments should occur every nth month.
	MonthInterval_2 *PositiveInt `json:"monthInterval,omitempty"`

	// Indicates which week within a month the appointments in the series of recurring
	// appointments should occur on.
	NthWeekOfMonth *Coding `json:"nthWeekOfMonth,omitempty"`
}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type AppointmentParticipant struct {
	// Extensions for required
	Required *Element `json:"_required,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The individual, device, location, or service participating in the appointment.
	Actor *Reference `json:"actor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Participation period of the actor.
	Period *Period `json:"period,omitempty"`

	// Whether this participant is required to be present at the meeting. If false,
	// the participant is optional.
	Required_2 *Boolean `json:"required,omitempty"`

	// Participation status of the actor.
	Status_2 *Code `json:"status,omitempty"`

	// Role of participant in the appointment.
	Type []CodeableConcept `json:"type,omitempty"`
}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type AppointmentRecurrenceTemplate struct {
	// Extensions for excludingDate
	ExcludingDate []Element `json:"_excludingDate,omitempty"`

	// Extensions for excludingRecurrenceId
	ExcludingRecurrenceID []Element `json:"_excludingRecurrenceId,omitempty"`

	// Extensions for lastOccurrenceDate
	LastOccurrenceDate *Element `json:"_lastOccurrenceDate,omitempty"`

	// Extensions for occurrenceCount
	OccurrenceCount *Element `json:"_occurrenceCount,omitempty"`

	// Extensions for occurrenceDate
	OccurrenceDate []Element `json:"_occurrenceDate,omitempty"`

	// Any dates, such as holidays, that should be excluded from the recurrence.
	ExcludingDate_2 []Date `json:"excludingDate,omitempty"`

	// Any dates, such as holidays, that should be excluded from the recurrence.
	ExcludingRecurrenceID_2 []PositiveInt `json:"excludingRecurrenceId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Recurring appointments will not occur after this date.
	LastOccurrenceDate_2 *Date `json:"lastOccurrenceDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Information about monthly recurring appointments.
	MonthlyTemplate *AppointmentMonthlyTemplate `json:"monthlyTemplate,omitempty"`

	// How many appointments are planned in the recurrence.
	OccurrenceCount_2 *PositiveInt `json:"occurrenceCount,omitempty"`

	// The list of specific dates that will have appointments generated.
	OccurrenceDate_2 []Date `json:"occurrenceDate,omitempty"`

	// How often the appointment series should recur.
	RecurrenceType CodeableConcept `json:"recurrenceType"`

	// The timezone of the recurring appointment occurrences.
	Timezone *CodeableConcept `json:"timezone,omitempty"`

	// Information about weekly recurring appointments.
	WeeklyTemplate *AppointmentWeeklyTemplate `json:"weeklyTemplate,omitempty"`

	// Information about yearly recurring appointments.
	YearlyTemplate *AppointmentYearlyTemplate `json:"yearlyTemplate,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppointmentRecurrenceTemplate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["recurrenceType"]; raw != nil && !ok {
		return fmt.Errorf("field recurrenceType in AppointmentRecurrenceTemplate: required")
	}
	type Plain AppointmentRecurrenceTemplate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AppointmentRecurrenceTemplate(plain)
	return nil
}

// A reply to an appointment request for a patient and/or practitioner(s), such as
// a confirmation or rejection.
type AppointmentResponse struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for end
	End *Element `json:"_end,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDate
	OccurrenceDate *Element `json:"_occurrenceDate,omitempty"`

	// Extensions for participantStatus
	ParticipantStatus *Element `json:"_participantStatus,omitempty"`

	// Extensions for proposedNewTime
	ProposedNewTime *Element `json:"_proposedNewTime,omitempty"`

	// Extensions for recurrenceId
	RecurrenceID *Element `json:"_recurrenceId,omitempty"`

	// Extensions for recurring
	Recurring *Element `json:"_recurring,omitempty"`

	// Extensions for start
	Start *Element `json:"_start,omitempty"`

	// A Person, Location, HealthcareService, or Device that is participating in the
	// appointment.
	Actor *Reference `json:"actor,omitempty"`

	// Appointment that this response is replying to.
	Appointment Reference `json:"appointment"`

	// Additional comments about the appointment.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AppointmentResponseContainedElem `json:"contained,omitempty"`

	// This may be either the same as the appointment request to confirm the details
	// of the appointment, or alternately a new time to request a re-negotiation of
	// the end time.
	End_2 *Instant `json:"end,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// This records identifiers associated with this appointment response concern that
	// are defined by business processes and/ or used to refer to it when a direct URL
	// reference to the resource itself is not appropriate.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The original date within a recurring request. This could be used in place of
	// the recurrenceId to be more direct (or where the template is provided through
	// the simple list of dates in `Appointment.occurrenceDate`).
	OccurrenceDate_2 *Date `json:"occurrenceDate,omitempty"`

	// Participation status of the participant. When the status is declined or
	// tentative if the start/end times are different to the appointment, then these
	// times should be interpreted as a requested time change. When the status is
	// accepted, the times can either be the time of the appointment (as a
	// confirmation of the time) or can be empty.
	ParticipantStatus_2 *Code `json:"participantStatus,omitempty"`

	// Role of participant in the appointment.
	ParticipantType []CodeableConcept `json:"participantType,omitempty"`

	// Indicates that the response is proposing a different time that was initially
	// requested.  The new proposed time will be indicated in the start and end
	// properties.
	ProposedNewTime_2 *Boolean `json:"proposedNewTime,omitempty"`

	// The recurrence ID (sequence number) of the specific appointment when responding
	// to a recurring request.
	RecurrenceID_2 *PositiveInt `json:"recurrenceId,omitempty"`

	// Indicates that this AppointmentResponse applies to all occurrences in a
	// recurring request.
	Recurring_2 *Boolean `json:"recurring,omitempty"`

	// This is a AppointmentResponse resource
	ResourceType interface{} `json:"resourceType"`

	// Date/Time that the appointment is to take place, or requested new start time.
	Start_2 *Instant `json:"start,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type AppointmentResponseContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppointmentResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["appointment"]; raw != nil && !ok {
		return fmt.Errorf("field appointment in AppointmentResponse: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in AppointmentResponse: required")
	}
	type Plain AppointmentResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AppointmentResponse(plain)
	return nil
}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type AppointmentWeeklyTemplate struct {
	// Extensions for friday
	Friday *Element `json:"_friday,omitempty"`

	// Extensions for monday
	Monday *Element `json:"_monday,omitempty"`

	// Extensions for saturday
	Saturday *Element `json:"_saturday,omitempty"`

	// Extensions for sunday
	Sunday *Element `json:"_sunday,omitempty"`

	// Extensions for thursday
	Thursday *Element `json:"_thursday,omitempty"`

	// Extensions for tuesday
	Tuesday *Element `json:"_tuesday,omitempty"`

	// Extensions for wednesday
	Wednesday *Element `json:"_wednesday,omitempty"`

	// Extensions for weekInterval
	WeekInterval *Element `json:"_weekInterval,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates that recurring appointments should occur on Fridays.
	Friday_2 *Boolean `json:"friday,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates that recurring appointments should occur on Mondays.
	Monday_2 *Boolean `json:"monday,omitempty"`

	// Indicates that recurring appointments should occur on Saturdays.
	Saturday_2 *Boolean `json:"saturday,omitempty"`

	// Indicates that recurring appointments should occur on Sundays.
	Sunday_2 *Boolean `json:"sunday,omitempty"`

	// Indicates that recurring appointments should occur on Thursdays.
	Thursday_2 *Boolean `json:"thursday,omitempty"`

	// Indicates that recurring appointments should occur on Tuesdays.
	Tuesday_2 *Boolean `json:"tuesday,omitempty"`

	// Indicates that recurring appointments should occur on Wednesdays.
	Wednesday_2 *Boolean `json:"wednesday,omitempty"`

	// The interval defines if the recurrence is every nth week. The default is every
	// week, so it is expected that this value will be 2 or more.e.g. For recurring
	// every second week this interval would be 2, or every third week the interval
	// would be 3.
	WeekInterval_2 *PositiveInt `json:"weekInterval,omitempty"`
}

// A booking of a healthcare event among patient(s), practitioner(s), related
// person(s) and/or device(s) for a specific date/time. This may result in one or
// more Encounter(s).
type AppointmentYearlyTemplate struct {
	// Extensions for yearInterval
	YearInterval *Element `json:"_yearInterval,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Appointment recurs every nth year.
	YearInterval_2 *PositiveInt `json:"yearInterval,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Appointment) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["participant"]; raw != nil && !ok {
		return fmt.Errorf("field participant in Appointment: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Appointment: required")
	}
	type Plain Appointment
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Appointment(plain)
	return nil
}

// This Resource provides one or more comments, classifiers or ratings about a
// Resource and supports attribution and rights management metadata for the added
// content.
type ArtifactAssessment struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for artifactCanonical
	ArtifactCanonical *Element `json:"_artifactCanonical,omitempty"`

	// Extensions for artifactUri
	ArtifactUri *Element `json:"_artifactUri,omitempty"`

	// Extensions for citeAs
	CiteAs *Element `json:"_citeAs,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for workflowStatus
	WorkflowStatus *Element `json:"_workflowStatus,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// A reference to a resource, canonical resource, or non-FHIR resource which the
	// comment or assessment is about.
	ArtifactCanonical_2 *string `json:"artifactCanonical,omitempty"`

	// A reference to a resource, canonical resource, or non-FHIR resource which the
	// comment or assessment is about.
	ArtifactReference *Reference `json:"artifactReference,omitempty"`

	// A reference to a resource, canonical resource, or non-FHIR resource which the
	// comment or assessment is about.
	ArtifactUri_2 *string `json:"artifactUri,omitempty"`

	// Display of the bibliographic citation of the comment, classifier, or rating.
	CiteAs_2 *Markdown `json:"citeAs,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ArtifactAssessmentContainedElem `json:"contained,omitempty"`

	// A component comment, classifier, or rating of the artifact.
	Content []ArtifactAssessmentContent `json:"content,omitempty"`

	// A copyright statement relating to the artifact assessment and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the artifact assessment.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// The date  (and optionally time) when the artifact assessment was published. The
	// date must change when the disposition changes and it must change if the
	// workflow status code changes. In addition, it should change when the
	// substantive content of the artifact assessment changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// Indicates the disposition of the responsible party to the comment or change
	// request.
	Disposition_2 *Code `json:"disposition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this artifact assessment when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Relationship that this ArtifactAssessment has with other FHIR or non-FHIR
	// resources that already exist.
	RelatesTo []ArtifactAssessmentRelatesTo `json:"relatesTo,omitempty"`

	// This is a ArtifactAssessment resource
	ResourceType interface{} `json:"resourceType"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A label for use in displaying and selecting the artifact assessment.
	Title_2 *String `json:"title,omitempty"`

	// Indicates the workflow status of the comment or change request.
	WorkflowStatus_2 *Code `json:"workflowStatus,omitempty"`
}

type ArtifactAssessmentContainedElem interface{}

// This Resource provides one or more comments, classifiers or ratings about a
// Resource and supports attribution and rights management metadata for the added
// content.
type ArtifactAssessmentContent struct {
	// Extensions for freeToShare
	FreeToShare *Element `json:"_freeToShare,omitempty"`

	// Extensions for path
	Path []Element `json:"_path,omitempty"`

	// Extensions for summary
	Summary *Element `json:"_summary,omitempty"`

	// Indicates who or what authored the content.
	Author []Reference `json:"author,omitempty"`

	// Represents a rating, classifier, or assessment of the artifact.
	Classifier []CodeableConcept `json:"classifier,omitempty"`

	// A component comment, classifier, or rating of the artifact.
	Component []ArtifactAssessmentContent `json:"component,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Acceptable to publicly share the comment, classifier or rating.
	FreeToShare_2 *Boolean `json:"freeToShare,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A URI that points to what the comment is about, such as a line of text in the
	// CQL, or a specific element in a resource.
	Path_2 []Uri `json:"path,omitempty"`

	// A quantitative rating of the artifact.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Relationship that this content component has with other FHIR or non-FHIR
	// resources that already exist.
	RelatesTo []ArtifactAssessmentRelatesTo `json:"relatesTo,omitempty"`

	// A brief summary of the content of this component.
	Summary_2 *Markdown `json:"summary,omitempty"`

	// Indicates what type of content this component represents.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This Resource provides one or more comments, classifiers or ratings about a
// Resource and supports attribution and rights management metadata for the added
// content.
type ArtifactAssessmentRelatesTo struct {
	// Extensions for targetCanonical
	TargetCanonical *Element `json:"_targetCanonical,omitempty"`

	// Extensions for targetMarkdown
	TargetMarkdown *Element `json:"_targetMarkdown,omitempty"`

	// Extensions for targetUri
	TargetUri *Element `json:"_targetUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The artifact that is related to this ArtifactAssessment Resource.
	TargetAttachment *Attachment `json:"targetAttachment,omitempty"`

	// The artifact that is related to this ArtifactAssessment Resource.
	TargetCanonical_2 *string `json:"targetCanonical,omitempty"`

	// The artifact that is related to this ArtifactAssessment Resource.
	TargetMarkdown_2 *string `json:"targetMarkdown,omitempty"`

	// The artifact that is related to this ArtifactAssessment Resource.
	TargetReference *Reference `json:"targetReference,omitempty"`

	// The artifact that is related to this ArtifactAssessment Resource.
	TargetUri_2 *string `json:"targetUri,omitempty"`

	// The type of relationship to the related artifact.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArtifactAssessmentRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ArtifactAssessmentRelatesTo: required")
	}
	type Plain ArtifactAssessmentRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.TargetUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetUri_2", `^\S*$`)
		}
	}
	*j = ArtifactAssessmentRelatesTo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArtifactAssessment) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ArtifactAssessment: required")
	}
	type Plain ArtifactAssessment
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ArtifactCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ArtifactCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ArtifactCanonical_2", `^\S*$`)
		}
	}
	if plain.ArtifactUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ArtifactUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ArtifactUri_2", `^\S*$`)
		}
	}
	*j = ArtifactAssessment(plain)
	return nil
}

// For referring to data content defined in other formats.
type Attachment struct {
	// Extensions for contentType
	ContentType *Element `json:"_contentType,omitempty"`

	// Extensions for creation
	Creation *Element `json:"_creation,omitempty"`

	// Extensions for data
	Data *Element `json:"_data,omitempty"`

	// Extensions for duration
	Duration *Element `json:"_duration,omitempty"`

	// Extensions for frames
	Frames *Element `json:"_frames,omitempty"`

	// Extensions for hash
	Hash *Element `json:"_hash,omitempty"`

	// Extensions for height
	Height *Element `json:"_height,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for pages
	Pages *Element `json:"_pages,omitempty"`

	// Extensions for size
	Size *Element `json:"_size,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for width
	Width *Element `json:"_width,omitempty"`

	// Identifies the type of the data in the attachment and allows a method to be
	// chosen to interpret or render the data. Includes mime type parameters such as
	// charset where appropriate.
	ContentType_2 *Code `json:"contentType,omitempty"`

	// The date that the attachment was first created.
	Creation_2 *DateTime `json:"creation,omitempty"`

	// The actual data of the attachment - a sequence of bytes, base64 encoded.
	Data_2 *Base64Binary `json:"data,omitempty"`

	// The duration of the recording in seconds - for audio and video.
	Duration_2 *Decimal `json:"duration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The number of frames in a photo. This is used with a multi-page fax, or an
	// imaging acquisition context that takes multiple slices in a single image, or an
	// animated gif. If there is more than one frame, this SHALL have a value in order
	// to alert interface software that a multi-frame capable rendering widget is
	// required.
	Frames_2 *PositiveInt `json:"frames,omitempty"`

	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash_2 *Base64Binary `json:"hash,omitempty"`

	// Height of the image in pixels (photo/video).
	Height_2 *PositiveInt `json:"height,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The human language of the content. The value can be any valid value according
	// to BCP 47.
	Language_2 *Code `json:"language,omitempty"`

	// The number of pages when printed.
	Pages_2 *PositiveInt `json:"pages,omitempty"`

	// The number of bytes of data that make up this attachment (before base64
	// encoding, if that is done).
	Size_2 *Integer64 `json:"size,omitempty"`

	// A label or set of text to display in place of the data.
	Title_2 *String `json:"title,omitempty"`

	// A location where the data can be accessed.
	Url_2 *Url `json:"url,omitempty"`

	// Width of the image in pixels (photo/video).
	Width_2 *PositiveInt `json:"width,omitempty"`
}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEvent struct {
	// Extensions for action
	Action *Element `json:"_action,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurredDateTime
	OccurredDateTime *Element `json:"_occurredDateTime,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for severity
	Severity *Element `json:"_severity,omitempty"`

	// Indicator for type of action performed during the event that generated the
	// audit.
	Action_2 *Code `json:"action,omitempty"`

	// An actor taking an active role in the event or activity that is logged.
	Agent []AuditEventAgent `json:"agent"`

	// The authorization (e.g., PurposeOfUse) that was used during the event being
	// recorded.
	Authorization []CodeableConcept `json:"authorization,omitempty"`

	// Allows tracing of authorization for the events and tracking whether
	// proposals/recommendations were acted upon.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []AuditEventContainedElem `json:"contained,omitempty"`

	// This will typically be the encounter the event occurred, but some events MAY be
	// initiated prior to or after the official completion of an encounter but still
	// be tied to the context of the encounter (e.g. pre-admission lab tests).
	Encounter *Reference `json:"encounter,omitempty"`

	// Specific instances of data or objects that have been accessed.
	Entity []AuditEventEntity `json:"entity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time or period during which the activity occurred.
	OccurredDateTime_2 *string `json:"occurredDateTime,omitempty"`

	// The time or period during which the activity occurred.
	OccurredPeriod *Period `json:"occurredPeriod,omitempty"`

	// Indicates whether the event succeeded or failed. A free text descripiton can be
	// given in outcome.text.
	Outcome *AuditEventOutcome `json:"outcome,omitempty"`

	// The patient element is available to enable deterministic tracking of activities
	// that involve the patient as the subject of the data used in an activity.
	Patient *Reference `json:"patient,omitempty"`

	// The time when the event was recorded.
	Recorded_2 *Instant `json:"recorded,omitempty"`

	// This is a AuditEvent resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates and enables segmentation of various severity including debugging from
	// critical.
	Severity_2 *Code `json:"severity,omitempty"`

	// The actor that is reporting the event.
	Source AuditEventSource `json:"source"`

	// Describes what happened. The most specific codes for the event.
	Subtype []CodeableConcept `json:"subtype,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Partitions the audit event into one or more categories that can be used to
	// filter searching, to govern access control and/or to guide system behavior.
	Type CodeableConcept `json:"type"`
}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEventAgent struct {
	// Extensions for networkString
	NetworkString *Element `json:"_networkString,omitempty"`

	// Extensions for networkUri
	NetworkUri *Element `json:"_networkUri,omitempty"`

	// Extensions for policy
	Policy []Element `json:"_policy,omitempty"`

	// Extensions for requestor
	Requestor *Element `json:"_requestor,omitempty"`

	// The authorization (e.g., PurposeOfUse) that was used during the event being
	// recorded.
	Authorization []CodeableConcept `json:"authorization,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Where the agent location is known, the agent location when the event occurred.
	Location *Reference `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// When the event utilizes a network there SHOULD be an agent describing the local
	// system, and an agent describing remote system, with the network interface
	// details.
	NetworkReference *Reference `json:"networkReference,omitempty"`

	// When the event utilizes a network there SHOULD be an agent describing the local
	// system, and an agent describing remote system, with the network interface
	// details.
	NetworkString_2 *string `json:"networkString,omitempty"`

	// When the event utilizes a network there SHOULD be an agent describing the local
	// system, and an agent describing remote system, with the network interface
	// details.
	NetworkUri_2 *string `json:"networkUri,omitempty"`

	// Where the policy(ies) are known that authorized the agent participation in the
	// event. Typically, a single activity MAY have multiple applicable policies, such
	// as patient consent, guarantor funding, etc. The policy would also indicate the
	// security token used.
	Policy_2 []Uri `json:"policy,omitempty"`

	// Indicator that the user is or is not the requestor, or initiator, for the event
	// being audited.
	Requestor_2 *Boolean `json:"requestor,omitempty"`

	// The structural roles of the agent indicating the agent's competency. The
	// security role enabling the agent with respect to the activity.
	Role []CodeableConcept `json:"role,omitempty"`

	// The Functional Role of the user when performing the event.
	Type *CodeableConcept `json:"type,omitempty"`

	// Reference to who this agent is that was involved in the event.
	Who Reference `json:"who"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuditEventAgent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["who"]; raw != nil && !ok {
		return fmt.Errorf("field who in AuditEventAgent: required")
	}
	type Plain AuditEventAgent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.NetworkString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.NetworkString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "NetworkString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.NetworkUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.NetworkUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "NetworkUri_2", `^\S*$`)
		}
	}
	*j = AuditEventAgent(plain)
	return nil
}

type AuditEventContainedElem interface{}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEventDetail struct {
	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name of extra detail provided in the value. This element is the tag for the
	// value. Where a simple string is used for the tag name, use the
	// CodeableConcept.display element.
	Type CodeableConcept `json:"type"`

	// The  value of the extra detail.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The  value of the extra detail.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The  value of the extra detail.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The  value of the extra detail.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The  value of the extra detail.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The  value of the extra detail.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The  value of the extra detail.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The  value of the extra detail.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The  value of the extra detail.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The  value of the extra detail.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The  value of the extra detail.
	ValueTime_2 *string `json:"valueTime,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuditEventDetail) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AuditEventDetail: required")
	}
	type Plain AuditEventDetail
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	*j = AuditEventDetail(plain)
	return nil
}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEventEntity struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for query
	Query *Element `json:"_query,omitempty"`

	// The entity is attributed to an agent to express the agent's responsibility for
	// that entity in the activity. This is most used to indicate when persistence
	// media (the entity) are used by an agent. For example when importing data from a
	// device, the device would be described in an entity, and the user importing data
	// from that media would be indicated as the entity.agent.
	Agent []AuditEventAgent `json:"agent,omitempty"`

	// Text that describes the entity in more detail.
	Description_2 *String `json:"description,omitempty"`

	// Tagged value pairs for conveying additional information about the entity.
	Detail []AuditEventDetail `json:"detail,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The query parameters for a query-type entities.
	Query_2 *Base64Binary `json:"query,omitempty"`

	// Code representing the role the entity played in the event being audited.
	Role *CodeableConcept `json:"role,omitempty"`

	// Security labels for the identified entity.
	SecurityLabel []CodeableConcept `json:"securityLabel,omitempty"`

	// Identifies a specific instance of the entity. The reference SHOULD be version
	// specific. This is allowed to be a Parameters resource.
	What *Reference `json:"what,omitempty"`
}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEventOutcome struct {
	// Indicates whether the event succeeded or failed.
	Code Coding `json:"code"`

	// Additional details about the error. This MAY be a text description of the error
	// or a system code that identifies the error.
	Detail []CodeableConcept `json:"detail,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuditEventOutcome) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in AuditEventOutcome: required")
	}
	type Plain AuditEventOutcome
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AuditEventOutcome(plain)
	return nil
}

// A record of an event relevant for purposes such as operations, privacy,
// security, maintenance, and performance analysis.
type AuditEventSource struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifier of the source where the event was detected.
	Observer Reference `json:"observer"`

	// Logical source location within the healthcare enterprise network.  For example,
	// a hospital or other provider location within a multi-entity provider group.
	Site *Reference `json:"site,omitempty"`

	// Code specifying the type of source where event originated.
	Type []CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuditEventSource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["observer"]; raw != nil && !ok {
		return fmt.Errorf("field observer in AuditEventSource: required")
	}
	type Plain AuditEventSource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AuditEventSource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuditEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["agent"]; raw != nil && !ok {
		return fmt.Errorf("field agent in AuditEvent: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in AuditEvent: required")
	}
	if _, ok := raw["source"]; raw != nil && !ok {
		return fmt.Errorf("field source in AuditEvent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AuditEvent: required")
	}
	type Plain AuditEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurredDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurredDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurredDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = AuditEvent(plain)
	return nil
}

// Availability data for an {item}, declaring what days/times are available, and
// any exceptions. The exceptions could be textual only, e.g. Public holidays, or
// could be time period specific and indicate a specific years dates.
type Availability struct {
	// A collection of times that the {item} is available.
	AvailableTime []AvailabilityAvailableTime `json:"availableTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The {item} is not available during this period of time due to the provided
	// reason.
	NotAvailableTime []AvailabilityNotAvailableTime `json:"notAvailableTime,omitempty"`

	// The period of time when the availability is applicable.  For example, you might
	// use this property to indicate the period during the holiday season when you
	// close an hour early.
	Period *Period `json:"period,omitempty"`
}

// Availability data for an {item}, declaring what days/times are available, and
// any exceptions. The exceptions could be textual only, e.g. Public holidays, or
// could be time period specific and indicate a specific years dates.
type AvailabilityAvailableTime struct {
	// Extensions for allDay
	AllDay *Element `json:"_allDay,omitempty"`

	// Extensions for availableEndTime
	AvailableEndTime *Element `json:"_availableEndTime,omitempty"`

	// Extensions for availableStartTime
	AvailableStartTime *Element `json:"_availableStartTime,omitempty"`

	// Extensions for daysOfWeek
	DaysOfWeek []Element `json:"_daysOfWeek,omitempty"`

	// Is this always available? (hence times are irrelevant) i.e. 24 hour service.
	AllDay_2 *Boolean `json:"allDay,omitempty"`

	// The closing time of day. Note: If the AllDay flag is set, then this time is
	// ignored.
	AvailableEndTime_2 *Time `json:"availableEndTime,omitempty"`

	// The opening time of day. Note: If the AllDay flag is set, then this time is
	// ignored.
	AvailableStartTime_2 *Time `json:"availableStartTime,omitempty"`

	// Indicates which days of the week are available between the start and end Times.
	DaysOfWeek_2 []Code `json:"daysOfWeek,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Availability data for an {item}, declaring what days/times are available, and
// any exceptions. The exceptions could be textual only, e.g. Public holidays, or
// could be time period specific and indicate a specific years dates.
type AvailabilityNotAvailableTime struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// The reason that can be presented to the user as to why this time is not
	// available.
	Description_2 *String `json:"description,omitempty"`

	// The {item} is not available (seasonally or for a public holiday) during this
	// period.
	During *Period `json:"during,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Base definition for the few data types that are allowed to carry modifier
// extensions.
type BackboneType struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A stream of bytes
type Base64Binary string

// Basic is used for handling concepts not yet defined in FHIR, narrative-only
// resources that don't map to an existing resource, and custom resources not
// appropriate for inclusion in the FHIR specification.
type Basic struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Indicates who was responsible for creating the resource instance.
	Author *Reference `json:"author,omitempty"`

	// Identifies the 'type' of resource - equivalent to the resource name for other
	// resources.
	Code CodeableConcept `json:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []BasicContainedElem `json:"contained,omitempty"`

	// Identifies when the resource was first created.
	Created_2 *DateTime `json:"created,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier assigned to the resource for business purposes, outside the context
	// of FHIR.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This is a Basic resource
	ResourceType interface{} `json:"resourceType"`

	// Identifies the patient, practitioner, device or any other resource that is the
	// "focus" of this resource.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type BasicContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Basic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in Basic: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Basic: required")
	}
	type Plain Basic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Basic(plain)
	return nil
}

// A resource that represents the data of a single raw artifact as digital content
// accessible in its native format.  A Binary resource can contain any content,
// whether text, image, pdf, zip archive, etc.
type Binary struct {
	// Extensions for contentType
	ContentType *Element `json:"_contentType,omitempty"`

	// Extensions for data
	Data *Element `json:"_data,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// MimeType of the binary content represented as a standard MimeType (BCP 13).
	ContentType_2 *Code `json:"contentType,omitempty"`

	// The actual content, base64 encoded.
	Data_2 *Base64Binary `json:"data,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// This is a Binary resource
	ResourceType interface{} `json:"resourceType"`

	// This element identifies another resource that can be used as a proxy of the
	// security sensitivity to use when deciding and enforcing access control rules
	// for the Binary resource. Given that the Binary resource contains very few
	// elements that can be used to determine the sensitivity of the data and
	// relationships to individuals, the referenced resource stands in as a proxy
	// equivalent for this purpose. This referenced resource may be related to the
	// Binary (e.g. DocumentReference), or may be some non-related Resource purely as
	// a security proxy. E.g. to identify that the binary resource relates to a
	// patient, and access should only be granted to applications that have access to
	// the patient.
	SecurityContext *Reference `json:"securityContext,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Binary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Binary: required")
	}
	type Plain Binary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Binary(plain)
	return nil
}

// This resource reflects an instance of a biologically derived product. A material
// substance originating from a biological entity intended to be transplanted or
// infused
// into another (possibly the same) biological entity.
type BiologicallyDerivedProduct struct {
	// Extensions for division
	Division *Element `json:"_division,omitempty"`

	// Extensions for expirationDate
	ExpirationDate *Element `json:"_expirationDate,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// An identifier that supports traceability to the event during which material in
	// this product from one or more biological entities was obtained or pooled.
	BiologicalSourceEvent *Identifier `json:"biologicalSourceEvent,omitempty"`

	// How this product was collected.
	Collection *BiologicallyDerivedProductCollection `json:"collection,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []BiologicallyDerivedProductContainedElem `json:"contained,omitempty"`

	// A unique identifier for an aliquot of a product.  Used to distinguish
	// individual aliquots of a product carrying the same biologicalSource and
	// productCode identifiers.
	Division_2 *String `json:"division,omitempty"`

	// Date, and where relevant time, of expiration.
	ExpirationDate_2 *DateTime `json:"expirationDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique instance identifiers assigned to a biologically derived product. Note:
	// This is a business identifier, not a resource identifier.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Parent product (if any) for this biologically-derived product.
	Parent []Reference `json:"parent,omitempty"`

	// Processing facilities responsible for the labeling and distribution of this
	// biologically derived product.
	ProcessingFacility []Reference `json:"processingFacility,omitempty"`

	// A category or classification of the product.  Products may be assigned multiple
	// categories, for example a human heart valve can be categorized as an 'MPHO' and
	// 'tissue'.
	ProductCategory []CodeableConcept `json:"productCategory,omitempty"`

	// A codified value that systematically supports characterization and
	// classification of medical products of human origin inclusive of processing
	// conditions such as additives, volumes and handling conditions.
	ProductCode *CodeableConcept `json:"productCode,omitempty"`

	// The current status of the product.
	ProductStatus *Coding `json:"productStatus,omitempty"`

	// A property that is specific to this BiologicallyDerviedProduct instance.
	Property []BiologicallyDerivedProductProperty `json:"property,omitempty"`

	// Request to obtain and/or infuse this biologically derived product.
	Request []Reference `json:"request,omitempty"`

	// This is a BiologicallyDerivedProduct resource
	ResourceType interface{} `json:"resourceType"`

	// The temperature requirements for storage of the biologically-derived product.
	StorageTempRequirements *Range `json:"storageTempRequirements,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// This resource reflects an instance of a biologically derived product. A material
// substance originating from a biological entity intended to be transplanted or
// infused
// into another (possibly the same) biological entity.
type BiologicallyDerivedProductCollection struct {
	// Extensions for collectedDateTime
	CollectedDateTime *Element `json:"_collectedDateTime,omitempty"`

	// Time of product collection.
	CollectedDateTime_2 *string `json:"collectedDateTime,omitempty"`

	// Time of product collection.
	CollectedPeriod *Period `json:"collectedPeriod,omitempty"`

	// Healthcare professional who is performing the collection.
	Collector *Reference `json:"collector,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The procedure performed to collect the biologically derived product.
	Procedure *Reference `json:"procedure,omitempty"`

	// The entity, such as a hospital or vendor in the case of a
	// processed/manipulated/manufactured product, providing the product.
	SourceOrganization *Reference `json:"sourceOrganization,omitempty"`

	// The patient providing the product.
	SourcePatient *Reference `json:"sourcePatient,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BiologicallyDerivedProductCollection) UnmarshalJSON(value []byte) error {
	type Plain BiologicallyDerivedProductCollection
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CollectedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.CollectedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CollectedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = BiologicallyDerivedProductCollection(plain)
	return nil
}

type BiologicallyDerivedProductContainedElem interface{}

// This resource reflects an instance of a biologically derived product. A material
// substance originating from a biological entity intended to be transplanted or
// infused
// into another (possibly the same) biological entity.
type BiologicallyDerivedProductProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Code that specifies the property. It should reference an established coding
	// system.
	Type CodeableConcept `json:"type"`

	// Property values.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Property values.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Property values.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Property values.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Property values.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Property values.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Property values.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Property values.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Property values.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BiologicallyDerivedProductProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BiologicallyDerivedProductProperty: required")
	}
	type Plain BiologicallyDerivedProductProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = BiologicallyDerivedProductProperty(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BiologicallyDerivedProduct) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in BiologicallyDerivedProduct: required")
	}
	type Plain BiologicallyDerivedProduct
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BiologicallyDerivedProduct(plain)
	return nil
}

// Record details about an anatomical structure.  This resource may be used when a
// coded concept does not provide the necessary detail needed for the use case.
type BodyStructure struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Whether this body site is in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []BodyStructureContainedElem `json:"contained,omitempty"`

	// A summary, characterization or explanation of the body structure.
	Description_2 *Markdown `json:"description,omitempty"`

	// The anatomical location(s) or region(s) not occupied or represented by the
	// specimen, lesion, or body structure.
	ExcludedStructure []BodyStructureIncludedStructure `json:"excludedStructure,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for this instance of the anatomical structure.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Image(s) used to identify aspects of the overall structure.
	Image []Attachment `json:"image,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The anatomical location(s) or region(s) of the specimen, lesion, or body
	// structure.
	IncludedStructure []BodyStructureIncludedStructure `json:"includedStructure"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The person to which the body site belongs.
	Patient Reference `json:"patient"`

	// This is a BodyStructure resource
	ResourceType interface{} `json:"resourceType"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Record details about an anatomical structure.  This resource may be used when a
// coded concept does not provide the necessary detail needed for the use case.
type BodyStructureBodyLandmarkOrientation struct {
	// An description of the direction away from a landmark something is located based
	// on a radial clock dial.
	ClockFacePosition []CodeableConcept `json:"clockFacePosition,omitempty"`

	// The distance in centimeters a certain observation is made from a body landmark.
	DistanceFromLandmark []BodyStructureDistanceFromLandmark `json:"distanceFromLandmark,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Body landmark description used as a reference to locate something else.
	LandmarkDescription []CodeableConcept `json:"landmarkDescription,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The surface area a body location is in relation to a landmark.
	SurfaceOrientation []CodeableConcept `json:"surfaceOrientation,omitempty"`
}

type BodyStructureContainedElem interface{}

// Record details about an anatomical structure.  This resource may be used when a
// coded concept does not provide the necessary detail needed for the use case.
type BodyStructureDistanceFromLandmark struct {
	// An instrument, tool, analyzer, etc. used in the measurement.
	Device []CodeableReference `json:"device,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The measured distance (e.g., in cm) from a body landmark.
	Value []Quantity `json:"value,omitempty"`
}

// Record details about an anatomical structure.  This resource may be used when a
// coded concept does not provide the necessary detail needed for the use case.
type BodyStructureIncludedStructure struct {
	// Body location in relation to a specific body landmark (e.g., a body structure
	// such a navel, scar, or implanted device).
	BodyLandmarkOrientation []BodyStructureBodyLandmarkOrientation `json:"bodyLandmarkOrientation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Image(s) used to identify aspects of an included or excluded structure.
	Image []Attachment `json:"image,omitempty"`

	// Code that represents the included structure laterality.
	Laterality *CodeableConcept `json:"laterality,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The kind of structure being represented by the body structure at
	// `BodyStructure.location`.  This can define both normal and abnormal
	// morphologies.
	Morphology *CodeableConcept `json:"morphology,omitempty"`

	// Code that represents the included structure qualifier.
	Qualifier []CodeableConcept `json:"qualifier,omitempty"`

	// XY or XYZ-coordinate orientation for structure.
	SpatialReference []Reference `json:"spatialReference,omitempty"`

	// Code that represents the included structure.
	Structure CodeableConcept `json:"structure"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodyStructureIncludedStructure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["structure"]; raw != nil && !ok {
		return fmt.Errorf("field structure in BodyStructureIncludedStructure: required")
	}
	type Plain BodyStructureIncludedStructure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BodyStructureIncludedStructure(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodyStructure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["includedStructure"]; raw != nil && !ok {
		return fmt.Errorf("field includedStructure in BodyStructure: required")
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in BodyStructure: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in BodyStructure: required")
	}
	type Plain BodyStructure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BodyStructure(plain)
	return nil
}

// Value of "true" or "false"
type Boolean bool

// A container for a collection of resources.
type Bundle struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for timestamp
	Timestamp *Element `json:"_timestamp,omitempty"`

	// Extensions for total
	Total *Element `json:"_total,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// An entry in a bundle resource - will either contain a resource or information
	// about a resource (transactions and history only).
	Entry []BundleEntry `json:"entry,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A persistent identifier for the bundle that won't change as a bundle is copied
	// from server to server.
	Identifier *Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// An OperationOutcome that captures issues and warnings that relate to the
	// construction of the Bundle and the content within it.
	Issues BundleIssues `json:"issues,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A series of links that provide context to this bundle.
	Link []BundleLink `json:"link,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// This is a Bundle resource
	ResourceType interface{} `json:"resourceType"`

	// Digital Signature: XML-DSig or JWS. This element is deprecated, and [Provenance
	// based Signatures](signatures.html#Bundle) should be used instead.
	Signature *Signature `json:"signature,omitempty"`

	// The date/time that the bundle was assembled - i.e. when the resources were
	// placed in the bundle.
	Timestamp_2 *Instant `json:"timestamp,omitempty"`

	// If a set of search matches or a history, this is the (potentially estimated)
	// total number of entries of type 'match' across all pages in the search.  It
	// does not include search.mode = 'include' or 'outcome' entries and it does not
	// provide a count of the number of entries in the Bundle.
	Total_2 *UnsignedInt `json:"total,omitempty"`

	// Indicates the purpose of this bundle - how it is intended to be used.
	Type_2 *Code `json:"type,omitempty"`
}

// A container for a collection of resources.
type BundleEntry struct {
	// Extensions for fullUrl
	FullUrl *Element `json:"_fullUrl,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The Absolute URL for the resource. Except for transactions and batches, each
	// entry in a Bundle must have a fullUrl. The fullUrl SHALL NOT disagree with the
	// id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be
	// version-independent URL consistent with the Resource.id. The fullUrl is a
	// version independent reference to the resource. Even when not required, fullUrl
	// MAY be set to a urn:uuid to allow referencing entries in a transaction. The
	// fullUrl can be an arbitrary URI and is not limited to urn:uuid, urn:oid, http,
	// and https. The fullUrl element SHALL have a value unless:
	// * the Bundle is a batch or transaction request or response AND
	// * the entry is
	//     * invoking a create
	//   * invoking or responding to an operation where the body is not a single
	// identified resource
	//   * invoking or returning the results of a search or history operation.
	FullUrl_2 *Uri `json:"fullUrl,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A series of links that provide context to this entry.
	Link []BundleLink `json:"link,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional information about how this entry should be processed as part of a
	// transaction or batch.  For history, it shows how the entry was processed to
	// create the version contained in the entry.
	Request *BundleRequest `json:"request,omitempty"`

	// The Resource for the entry. The purpose/meaning of the resource is determined
	// by the Bundle.type. This is allowed to be a Parameters resource if and only if
	// it is referenced by something else within the Bundle that provides
	// context/meaning.
	Resource BundleEntryResource `json:"resource,omitempty"`

	// Indicates the results of processing the corresponding 'request' entry in the
	// batch or transaction being responded to or what the results of an operation
	// where when returning history.
	Response *BundleResponse `json:"response,omitempty"`

	// Information about the search process that lead to the creation of this entry.
	Search *BundleSearch `json:"search,omitempty"`
}

// The Resource for the entry. The purpose/meaning of the resource is determined by
// the Bundle.type. This is allowed to be a Parameters resource if and only if it
// is referenced by something else within the Bundle that provides context/meaning.
type BundleEntryResource interface{}

// An OperationOutcome that captures issues and warnings that relate to the
// construction of the Bundle and the content within it.
type BundleIssues interface{}

// A container for a collection of resources.
type BundleLink struct {
	// Extensions for relation
	Relation *Element `json:"_relation,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name which details the functional use for this link - see
	// [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
	Relation_2 *Code `json:"relation,omitempty"`

	// The reference details for the link.
	Url_2 *Uri `json:"url,omitempty"`
}

// A container for a collection of resources.
type BundleRequest struct {
	// Extensions for ifMatch
	IfMatch *Element `json:"_ifMatch,omitempty"`

	// Extensions for ifModifiedSince
	IfModifiedSince *Element `json:"_ifModifiedSince,omitempty"`

	// Extensions for ifNoneExist
	IfNoneExist *Element `json:"_ifNoneExist,omitempty"`

	// Extensions for ifNoneMatch
	IfNoneMatch *Element `json:"_ifNoneMatch,omitempty"`

	// Extensions for method
	Method *Element `json:"_method,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Only perform the operation if the Etag value matches. For more information, see
	// the API section ["Managing Resource Contention"](http.html#concurrency).
	IfMatch_2 *String `json:"ifMatch,omitempty"`

	// Only perform the operation if the last updated date matches. See the API
	// documentation for ["Conditional Read"](http.html#cread).
	IfModifiedSince_2 *Instant `json:"ifModifiedSince,omitempty"`

	// Instruct the server not to perform the create if a specified resource already
	// exists. For further information, see the API documentation for ["Conditional
	// Create"](http.html#ccreate). This is just the query portion of the URL - what
	// follows the "?" (not including the "?").
	IfNoneExist_2 *String `json:"ifNoneExist,omitempty"`

	// If the ETag values match, return a 304 Not Modified status. See the API
	// documentation for ["Conditional Read"](http.html#cread).
	IfNoneMatch_2 *String `json:"ifNoneMatch,omitempty"`

	// In a transaction or batch, this is the HTTP action to be executed for this
	// entry. In a history bundle, this indicates the HTTP action that occurred.
	Method_2 *Code `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The URL for this entry, relative to the root (the address to which the request
	// is posted).
	Url_2 *Uri `json:"url,omitempty"`
}

// A container for a collection of resources.
type BundleResponse struct {
	// Extensions for etag
	Etag *Element `json:"_etag,omitempty"`

	// Extensions for lastModified
	LastModified *Element `json:"_lastModified,omitempty"`

	// Extensions for location
	Location *Element `json:"_location,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The Etag for the resource, if the operation for the entry produced a versioned
	// resource (see [Resource Metadata and Versioning](http.html#versioning) and
	// [Managing Resource Contention](http.html#concurrency)).
	Etag_2 *String `json:"etag,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The date/time that the resource was modified on the server.
	LastModified_2 *Instant `json:"lastModified,omitempty"`

	// The location header created by processing this operation, populated if the
	// operation returns a location.
	Location_2 *Uri `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An OperationOutcome containing hints and warnings produced as part of
	// processing this entry in a batch or transaction.
	Outcome BundleResponseOutcome `json:"outcome,omitempty"`

	// The status code returned by processing this entry. The status SHALL start with
	// a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description
	// associated with the status code.
	Status_2 *String `json:"status,omitempty"`
}

// An OperationOutcome containing hints and warnings produced as part of processing
// this entry in a batch or transaction.
type BundleResponseOutcome interface{}

// A container for a collection of resources.
type BundleSearch struct {
	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Extensions for score
	Score *Element `json:"_score,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Why this entry is in the result set - whether it's included as a match or
	// because of an _include requirement, or to convey information or warning
	// information about the search process.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// When searching, the server's search ranking score for the entry.
	Score_2 *Decimal `json:"score,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Bundle) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Bundle: required")
	}
	type Plain Bundle
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Bundle(plain)
	return nil
}

// A URI that is a reference to a canonical URL on a FHIR resource
type Canonical string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Canonical) UnmarshalJSON(value []byte) error {
	type Plain Canonical
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^\S*$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^\S*$`)
	}
	*j = Canonical(plain)
	return nil
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatement struct {
	// Extensions for acceptLanguage
	AcceptLanguage []Element `json:"_acceptLanguage,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for fhirVersion
	FhirVersion *Element `json:"_fhirVersion,omitempty"`

	// Extensions for format
	Format []Element `json:"_format,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for patchFormat
	PatchFormat []Element `json:"_patchFormat,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// A list of the languages supported by this implementation that are usefully
	// supported in the ```Accept-Language``` header.
	AcceptLanguage_2 []Code `json:"acceptLanguage,omitempty"`

	// ActorDefinitions to describe the specific sets of functionality supported by
	// (or that should be supported by) systems (via obligations).
	ActorDefinition []Canonical `json:"actorDefinition,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CapabilityStatementContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the capability statement and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the capability statement.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the capability statement was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the capability statement changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the capability statement from a
	// consumer's perspective. Typically, this is used when the capability statement
	// describes a desired rather than an actual solution, for example as a formal
	// expression of requirements as part of an RFP.
	Description_2 *Markdown `json:"description,omitempty"`

	// A document definition.
	Document []CapabilityStatementDocument `json:"document,omitempty"`

	// A Boolean value to indicate that this capability statement is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The version of the FHIR specification that this CapabilityStatement describes
	// (which SHALL be the same as the FHIR version of the CapabilityStatement
	// itself). There is no default value.
	FhirVersion_2 *Code `json:"fhirVersion,omitempty"`

	// A list of the formats supported by this implementation using their content
	// types.
	Format_2 []Code `json:"format,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this CapabilityStatement when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Identifies a specific implementation instance that is described by the
	// capability statement - i.e. a particular installation, rather than the
	// capabilities of a software program.
	Implementation *CapabilityStatementImplementation `json:"implementation,omitempty"`

	// A list of implementation guides that the server does (or should) support in
	// their entirety.
	ImplementationGuide []Canonical `json:"implementationGuide,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Reference to a canonical URL of another CapabilityStatement that this software
	// adds to. The capability statement automatically includes everything in the
	// other statement, and it is not duplicated, though the server may repeat the
	// same resources, interactions and operations to add additional details to them.
	Imports []Canonical `json:"imports,omitempty"`

	// Reference to a canonical URL of another CapabilityStatement that this software
	// implements. This capability statement is a published API description that
	// corresponds to a business service. The server may actually implement a subset
	// of the capability statement it claims to implement, so the capability statement
	// must specify the full capability details.
	Instantiates []Canonical `json:"instantiates,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The way that this statement is intended to be used, to describe an actual
	// running instance of software, a particular product (kind, not instance of
	// software) or a class of implementation (e.g. a desired purchase).
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A description of the messaging capabilities of the solution.
	Messaging []CapabilityStatementMessaging `json:"messaging,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the capability statement. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// A list of the patch formats supported by this implementation using their
	// content types.
	PatchFormat_2 []Code `json:"patchFormat,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the capability statement.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this capability statement is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a CapabilityStatement resource
	ResourceType interface{} `json:"resourceType"`

	// A definition of the restful capabilities of the solution, if any.
	Rest []CapabilityStatementRest `json:"rest,omitempty"`

	// Software that is covered by this capability statement.  It is used when the
	// capability statement describes the capabilities of a particular software
	// version, independent of an installation.
	Software *CapabilityStatementSoftware `json:"software,omitempty"`

	// The status of this capability statement. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the capability statement.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this capability statement when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this capability statement is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the capability statement is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate capability
	// statement instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the capability
	// statement when it is referenced in a specification, model, design or instance.
	// This is an arbitrary value managed by the capability statement author and is
	// not expected to be globally unique. For example, it might be a timestamp (e.g.
	// yyyymmdd) if a managed version is not available. There is also no expectation
	// that versions can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type CapabilityStatementContainedElem interface{}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementDocument struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// A description of how the application supports or uses the specified document
	// profile.  For example, when documents are created, what action is taken with
	// consumed documents, etc.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Mode of this document declaration - whether an application is a producer or
	// consumer.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A profile on the document Bundle that constrains which resources are present,
	// and their contents.
	Profile Canonical `json:"profile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilityStatementDocument) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["profile"]; raw != nil && !ok {
		return fmt.Errorf("field profile in CapabilityStatementDocument: required")
	}
	type Plain CapabilityStatementDocument
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CapabilityStatementDocument(plain)
	return nil
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementEndpoint struct {
	// Extensions for address
	Address *Element `json:"_address,omitempty"`

	// The network address of the endpoint. For solutions that do not use network
	// addresses for routing, it can be just an identifier.
	Address_2 *Url `json:"address,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A list of the messaging transport protocol(s) identifiers, supported by this
	// endpoint.
	Protocol Coding `json:"protocol"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilityStatementEndpoint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["protocol"]; raw != nil && !ok {
		return fmt.Errorf("field protocol in CapabilityStatementEndpoint: required")
	}
	type Plain CapabilityStatementEndpoint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CapabilityStatementEndpoint(plain)
	return nil
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementImplementation struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// The organization responsible for the management of the instance and oversight
	// of the data on the server at the specified URL.
	Custodian *Reference `json:"custodian,omitempty"`

	// Information about the specific installation that this capability statement
	// relates to.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An absolute base URL for the implementation.  This forms the base for REST
	// interfaces as well as the mailbox and document interfaces.
	Url_2 *Url `json:"url,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementInteraction struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Coded identifier of the interaction, supported by the system resource.
	Code_2 *Code `json:"code,omitempty"`

	// Guidance specific to the implementation of this interaction, such as 'delete is
	// a logical delete' or 'updates are only allowed with version id' or 'creates
	// permitted from pre-authorized certificates only'.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementInteraction1 struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// A coded identifier of the interaction, supported by the system.
	Code_2 *Code `json:"code,omitempty"`

	// Guidance specific to the implementation of this interaction, such as
	// limitations on the kind of transactions allowed, or information about system
	// wide search is implemented.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementMessaging struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for reliableCache
	ReliableCache *Element `json:"_reliableCache,omitempty"`

	// Documentation about the system's messaging capabilities for this endpoint not
	// otherwise documented by the capability statement.  For example, the process for
	// becoming an authorized messaging exchange partner.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// An endpoint (network accessible address) to which messages and/or replies are
	// to be sent.
	Endpoint []CapabilityStatementEndpoint `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Length if the receiver's reliable messaging cache in minutes (if a receiver) or
	// how long the cache length on the receiver should be (if a sender).
	ReliableCache_2 *UnsignedInt `json:"reliableCache,omitempty"`

	// References to message definitions for messages this system can send or receive.
	SupportedMessage []CapabilityStatementSupportedMessage `json:"supportedMessage,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementOperation struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Where the formal definition can be found. If a server references the base
	// definition of an Operation (i.e. from the specification itself such as
	// ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that means it
	// supports the full capabilities of the operation - e.g. both GET and POST
	// invocation.  If it only supports a subset, it must define its own custom
	// [OperationDefinition](operationdefinition.html#) with a 'base' of the original
	// OperationDefinition.  The custom definition would describe the specific subset
	// of functionality supported.
	Definition Canonical `json:"definition"`

	// Documentation that describes anything special about the operation behavior,
	// possibly detailing different behavior for system, type and instance-level
	// invocation of the operation.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name of the operation or query. For an operation, this name is prefixed
	// with $ and used in the URL. For a query, this is the name used in the _query
	// parameter when the query is called. This SHOULD be the same as the
	// OperationDefinition.code of the defining OperationDefinition.  However, it can
	// sometimes differ if necessary to disambiguate when a server supports multiple
	// OperationDefinition that happen to share the same code.
	Name_2 *String `json:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilityStatementOperation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["definition"]; raw != nil && !ok {
		return fmt.Errorf("field definition in CapabilityStatementOperation: required")
	}
	type Plain CapabilityStatementOperation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CapabilityStatementOperation(plain)
	return nil
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementResource struct {
	// Extensions for conditionalCreate
	ConditionalCreate *Element `json:"_conditionalCreate,omitempty"`

	// Extensions for conditionalDelete
	ConditionalDelete *Element `json:"_conditionalDelete,omitempty"`

	// Extensions for conditionalPatch
	ConditionalPatch *Element `json:"_conditionalPatch,omitempty"`

	// Extensions for conditionalRead
	ConditionalRead *Element `json:"_conditionalRead,omitempty"`

	// Extensions for conditionalUpdate
	ConditionalUpdate *Element `json:"_conditionalUpdate,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for readHistory
	ReadHistory *Element `json:"_readHistory,omitempty"`

	// Extensions for referencePolicy
	ReferencePolicy []Element `json:"_referencePolicy,omitempty"`

	// Extensions for searchInclude
	SearchInclude []Element `json:"_searchInclude,omitempty"`

	// Extensions for searchRevInclude
	SearchRevInclude []Element `json:"_searchRevInclude,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for updateCreate
	UpdateCreate *Element `json:"_updateCreate,omitempty"`

	// Extensions for versioning
	Versioning *Element `json:"_versioning,omitempty"`

	// A flag that indicates that the server supports conditional create.
	ConditionalCreate_2 *Boolean `json:"conditionalCreate,omitempty"`

	// A code that indicates how the server supports conditional delete.
	ConditionalDelete_2 *Code `json:"conditionalDelete,omitempty"`

	// A flag that indicates that the server supports conditional patch.
	ConditionalPatch_2 *Boolean `json:"conditionalPatch,omitempty"`

	// A code that indicates how the server supports conditional read.
	ConditionalRead_2 *Code `json:"conditionalRead,omitempty"`

	// A flag that indicates that the server supports conditional update.
	ConditionalUpdate_2 *Boolean `json:"conditionalUpdate,omitempty"`

	// The definition of the resource, if the resource is an additional resource. If
	// it is not an additional resource, then this element must not be present.
	Definition *Canonical `json:"definition,omitempty"`

	// Additional information about the resource type used by the system.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifies a restful interaction supported by the solution.
	Interaction []CapabilityStatementInteraction `json:"interaction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Definition of an operation or a named query together with its parameters and
	// their meaning and type. Consult the definition of the operation for details
	// about how to invoke the operation, and the parameters.
	Operation []CapabilityStatementOperation `json:"operation,omitempty"`

	// A system-wide profile that is applied across *all* instances of the resource
	// supported by the system. For example, if declared on Observation, this profile
	// is the "superset" of capabilities for laboratory *and* vitals *and* other
	// domains. See further discussion in [Using
	// Profiles](profiling.html#profile-uses).
	Profile *Canonical `json:"profile,omitempty"`

	// A flag for whether the server is able to return past versions as part of the
	// vRead interaction.
	ReadHistory_2 *Boolean `json:"readHistory,omitempty"`

	// A set of flags that defines how references are supported.
	ReferencePolicy_2 []Code `json:"referencePolicy,omitempty"`

	// A list of _include values supported by the server.
	SearchInclude_2 []String `json:"searchInclude,omitempty"`

	// Search parameters for implementations to support and/or make use of - either
	// references to ones defined in the specification, or additional ones defined
	// for/by the implementation.
	SearchParam []CapabilityStatementSearchParam `json:"searchParam,omitempty"`

	// A list of _revinclude (reverse include) values supported by the server.
	SearchRevInclude_2 []String `json:"searchRevInclude,omitempty"`

	// A list of profiles representing different use cases the system hosts/produces.
	// A supported profile is a statement about the functionality of the data and
	// services provided by the server (or the client) for supported use cases. For
	// example, a system can define and declare multiple Observation profiles for
	// laboratory observations, vital sign observations, etc. By declaring supported
	// profiles, systems provide a way to determine whether individual resources are
	// conformant. See further discussion in [Using
	// Profiles](profiling.html#profile-uses).
	SupportedProfile []Canonical `json:"supportedProfile,omitempty"`

	// A relative URL, in which case it is a type of resource exposed via the restful
	// interface, either a resource defined in this specification, or an [additional
	// resource](resource.html#additional), or else a full URL referring to some other
	// type that specialises the base resource (e.g. a custom resource).
	Type_2 *Uri `json:"type,omitempty"`

	// A flag to indicate that the server allows or needs to allow the client to
	// create new identities on the server (that is, the client PUTs to a location
	// where there is no existing resource). Allowing this interaction means that the
	// server allows the client to create new identities on the server.
	UpdateCreate_2 *Boolean `json:"updateCreate,omitempty"`

	// This field is set to no-version to specify that the system does not support
	// (server) or use (client) versioning for this resource type. If this has some
	// other value, the server must at least correctly track and populate the
	// versionId meta-property on resources. If the value is 'versioned-update', then
	// the server supports all the versioning features, including using e-tags for
	// version integrity in the API.
	Versioning_2 *Code `json:"versioning,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementRest struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// An absolute URI which is a reference to the definition of a compartment that
	// the system supports. The reference is to a CompartmentDefinition resource by
	// its canonical URL .
	Compartment []Canonical `json:"compartment,omitempty"`

	// Information about the system's restful capabilities that apply across all
	// applications, such as security.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A specification of restful operations supported by the system.
	Interaction []CapabilityStatementInteraction1 `json:"interaction,omitempty"`

	// Identifies whether this portion of the statement is describing the ability to
	// initiate or receive restful interactions.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Definition of an operation or a named query together with its parameters and
	// their meaning and type.
	Operation []CapabilityStatementOperation `json:"operation,omitempty"`

	// A specification of the restful capabilities of the solution for a specific
	// resource type.
	Resource []CapabilityStatementResource `json:"resource,omitempty"`

	// Search parameters that are supported for searching all resources for
	// implementations to support and/or make use of - either references to ones
	// defined in the specification, or additional ones defined for/by the
	// implementation. This is only for searches executed against the system-level
	// endpoint.
	SearchParam []CapabilityStatementSearchParam `json:"searchParam,omitempty"`

	// Information about security implementation from an interface perspective - what
	// a client needs to know.
	Security *CapabilityStatementSecurity `json:"security,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementSearchParam struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// An absolute URI that is a formal reference to where this parameter was first
	// defined, so that a client can be confident of the meaning of the search
	// parameter (a reference to
	// [SearchParameter.url](searchparameter-definitions.html#SearchParameter.url)).
	// This element SHALL be populated if the search parameter refers to a
	// SearchParameter defined by the FHIR core specification or externally defined
	// IGs.
	Definition *Canonical `json:"definition,omitempty"`

	// This allows documentation of any distinct behaviors about how the search
	// parameter is used.  For example, text matching algorithms.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The label used for the search parameter in this particular system's API - i.e.
	// the 'name' portion of the name-value pair that will appear as part of the
	// search URL.  This SHOULD be the same as the SearchParameter.code of the
	// defining SearchParameter.  However, it can sometimes differ if necessary to
	// disambiguate when a server supports multiple SearchParameters that happen to
	// share the same code.
	Name_2 *String `json:"name,omitempty"`

	// The type of value a search parameter refers to, and how the content is
	// interpreted.
	Type_2 *Code `json:"type,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementSecurity struct {
	// Extensions for cors
	Cors *Element `json:"_cors,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Server adds CORS headers when responding to requests - this enables Javascript
	// applications to use the server.
	Cors_2 *Boolean `json:"cors,omitempty"`

	// General description of how security works.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Types of security services that are supported/required by the system.
	Service []CodeableConcept `json:"service,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementSoftware struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for releaseDate
	ReleaseDate *Element `json:"_releaseDate,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name the software is known by.
	Name_2 *String `json:"name,omitempty"`

	// Date this version of the software was released.
	ReleaseDate_2 *DateTime `json:"releaseDate,omitempty"`

	// The version identifier for the software covered by this statement.
	Version_2 *String `json:"version,omitempty"`
}

// A Capability Statement documents a set of capabilities (behaviors) of a FHIR
// Server or Client for a particular version of FHIR that may be used as a
// statement of actual server functionality or a statement of required or desired
// server implementation.
type CapabilityStatementSupportedMessage struct {
	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Points to a message definition that identifies the messaging event, message
	// structure, allowed responses, etc.
	Definition Canonical `json:"definition"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The mode of this event declaration - whether application is sender or receiver.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilityStatementSupportedMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["definition"]; raw != nil && !ok {
		return fmt.Errorf("field definition in CapabilityStatementSupportedMessage: required")
	}
	type Plain CapabilityStatementSupportedMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CapabilityStatementSupportedMessage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilityStatement) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CapabilityStatement: required")
	}
	type Plain CapabilityStatement
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = CapabilityStatement(plain)
	return nil
}

// Describes the intention of how one or more practitioners intend to deliver care
// for a particular patient, group or community for a period of time, possibly
// limited to care for a specific condition or set of conditions.
type CarePlan struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Identifies an action that has occurred or is a planned action to occur as part
	// of the plan. For example, a medication to be used, lab tests to perform,
	// self-monitoring that has occurred, education etc.
	Activity []CarePlanActivity `json:"activity,omitempty"`

	// Identifies the conditions/problems/concerns/diagnoses/etc. whose management
	// and/or mitigation are handled by this plan.
	Addresses []CodeableReference `json:"addresses,omitempty"`

	// A higher-level request resource (i.e. a plan, proposal or order) that is
	// fulfilled in whole or in part by this care plan.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Identifies all people and organizations who are expected to be involved in the
	// care envisioned by this plan.
	CareTeam []Reference `json:"careTeam,omitempty"`

	// Identifies what "kind" of plan this is to support differentiation between
	// multiple co-existing plans; e.g. "Home health", "psychiatric", "asthma",
	// "disease management", "wellness plan", etc.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CarePlanContainedElem `json:"contained,omitempty"`

	// Identifies the individual(s), organization or device who provided the contents
	// of the care plan.
	Contributor []Reference `json:"contributor,omitempty"`

	// Represents when this particular CarePlan record was created in the system,
	// which is often a system-generated date.
	Created_2 *DateTime `json:"created,omitempty"`

	// When populated, the custodian is responsible for the care plan. The care plan
	// is attributed to the custodian.
	Custodian *Reference `json:"custodian,omitempty"`

	// A description of the scope and nature of the plan.
	Description_2 *String `json:"description,omitempty"`

	// The Encounter during which this CarePlan was created or to which the creation
	// of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Describes the intended objective(s) of carrying out the care plan.
	Goal []Reference `json:"goal,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this care plan by the performer or other
	// systems which remain constant as the resource is updated and propagates from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Indicates the level of authority/intentionality associated with the care plan
	// and where the care plan fits into the workflow chain.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// General notes about the care plan not covered elsewhere.
	Note []Annotation `json:"note,omitempty"`

	// A larger care plan of which this particular care plan is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// Indicates when the plan did (or is intended to) come into effect and end.
	Period *Period `json:"period,omitempty"`

	// Completed or terminated care plan whose function is taken by this new care
	// plan.
	Replaces []Reference `json:"replaces,omitempty"`

	// This is a CarePlan resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates whether the plan is currently being acted upon, represents future
	// intentions or is now a historical record.
	Status_2 *Code `json:"status,omitempty"`

	// Identifies the patient or group whose intended care is described by the plan.
	Subject Reference `json:"subject"`

	// Identifies portions of the patient's record that specifically influenced the
	// formation of the plan.  These might include comorbidities, recent procedures,
	// limitations, recent assessments, etc.
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Human-friendly name for the care plan.
	Title_2 *String `json:"title,omitempty"`
}

// Describes the intention of how one or more practitioners intend to deliver care
// for a particular patient, group or community for a period of time, possibly
// limited to care for a specific condition or set of conditions.
type CarePlanActivity struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies the activity that was performed. For example, an activity could be
	// patient education, exercise, or a medication administration. The reference to
	// an "event" resource, such as Procedure or Encounter or Observation, represents
	// the activity that was performed. The requested activity can be conveyed using
	// the CarePlan.activity.plannedActivityReference (a reference to a â€œrequestâ€
	// resource).
	PerformedActivity []CodeableReference `json:"performedActivity,omitempty"`

	// The details of the proposed activity represented in a specific resource.
	PlannedActivityReference *Reference `json:"plannedActivityReference,omitempty"`

	// Notes about the adherence/status/progress of the activity.
	Progress []Annotation `json:"progress,omitempty"`
}

type CarePlanContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CarePlan) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CarePlan: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in CarePlan: required")
	}
	type Plain CarePlan
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CarePlan(plain)
	return nil
}

// The Care Team includes all the people, organizations, and care teams who
// participate or plan to participate in the coordination and delivery of care.
type CareTeam struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Identifies what kind of team.  This is to support differentiation between
	// multiple co-existing teams, such as care plan team, episode of care team,
	// longitudinal care team.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CareTeamContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this care team by the performer or other
	// systems which remain constant as the resource is updated and propagates from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organization responsible for the care team.
	ManagingOrganization []Reference `json:"managingOrganization,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A label for human use intended to distinguish like teams.  E.g. the "red" vs.
	// "green" trauma teams.
	Name_2 *String `json:"name,omitempty"`

	// Comments made about the CareTeam.
	Note []Annotation `json:"note,omitempty"`

	// Identifies all people and organizations who are expected to be involved in the
	// care team.
	Participant []CareTeamParticipant `json:"participant,omitempty"`

	// Indicates when the team did (or is intended to) come into effect and end.
	Period *Period `json:"period,omitempty"`

	// Describes why the care team exists.
	Reason []CodeableReference `json:"reason,omitempty"`

	// This is a CareTeam resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates the current state of the care team.
	Status_2 *Code `json:"status,omitempty"`

	// Identifies the patient or group whose intended care is handled by the team.
	Subject *Reference `json:"subject,omitempty"`

	// A central contact detail for the care team (that applies to all members).
	Telecom []ContactPoint `json:"telecom,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type CareTeamContainedElem interface{}

// The Care Team includes all the people, organizations, and care teams who
// participate or plan to participate in the coordination and delivery of care.
type CareTeamParticipant struct {
	// When the member is generally available within this care team.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// When the member is generally available within this care team.
	EffectiveTiming *Timing `json:"effectiveTiming,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The specific person or organization who is participating/expected to
	// participate in the care team.
	Member *Reference `json:"member,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Entity that the participant is acting as a proxy of, or an agent of, or in the
	// interest of, or as a representative of.
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`

	// Indicates specific responsibility of an individual within the care team, such
	// as "Primary care physician", "Trained social worker counselor", "Caregiver",
	// etc.
	Role *CodeableConcept `json:"role,omitempty"`

	// The basis for the member's role participation in care team.  For example,
	// supporting documentation that establishes legal power of attorney or court
	// ordered guardianship.
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CareTeam) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CareTeam: required")
	}
	type Plain CareTeam
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CareTeam(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type Claim struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// Details of an accident which resulted in injuries which required the products
	// and services listed in the claim.
	Accident *ClaimAccident `json:"accident,omitempty"`

	// The period for which charges are being submitted.
	BillablePeriod *Period `json:"billablePeriod,omitempty"`

	// The members of the team who provided the products and services.
	CareTeam []ClaimCareTeam `json:"careTeam,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ClaimContainedElem `json:"contained,omitempty"`

	// The date this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// Information about diagnoses relevant to the claim items.
	Diagnosis []ClaimDiagnosis `json:"diagnosis,omitempty"`

	// A package billing code or bundle code used to group products and services to a
	// particular health condition (such as heart attack) which is based on a
	// predetermined grouping code system.
	DiagnosisRelatedGroup *CodeableConcept `json:"diagnosisRelatedGroup,omitempty"`

	// Healthcare encounters related to this claim.
	Encounter []Reference `json:"encounter,omitempty"`

	// Individual who created the claim, predetermination or preauthorization.
	Enterer *Reference `json:"enterer,omitempty"`

	// Information code for an event with a corresponding date or period.
	Event []ClaimEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Facility where the services were provided.
	Facility *Reference `json:"facility,omitempty"`

	// A code to indicate whether and for whom funds are to be reserved for future
	// claims.
	FundsReserve *CodeableConcept `json:"fundsReserve,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this claim.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Financial instruments for reimbursement for the health care products and
	// services specified on the claim.
	Insurance []ClaimInsurance `json:"insurance,omitempty"`

	// The Insurer who is target of the request.
	Insurer *Reference `json:"insurer,omitempty"`

	// A claim line. Either a simple  product or service or a 'group' of details which
	// can each be a simple items or groups of sub-details.
	Item []ClaimItem `json:"item,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Original prescription which has been superseded by this prescription to support
	// the dispensing of pharmacy services, medications or products.
	OriginalPrescription *Reference `json:"originalPrescription,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// The party to be reimbursed for cost of the products and services according to
	// the terms of the policy.
	Payee *ClaimPayee `json:"payee,omitempty"`

	// Prescription is the document/authorization given to the claim author for them
	// to provide products and services for which consideration (reimbursement) is
	// sought. Could be a RX for medications, an 'order' for oxygen or wheelchair or
	// physiotherapy treatments.
	Prescription *Reference `json:"prescription,omitempty"`

	// The provider-required urgency of processing the request. Typical values
	// include: stat, normal, deferred.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// Procedures performed on the patient relevant to the billing items with the
	// claim.
	Procedure []ClaimProcedure `json:"procedure,omitempty"`

	// The provider which is responsible for the claim, predetermination or
	// preauthorization.
	Provider *Reference `json:"provider,omitempty"`

	// The referral information received by the claim author, it is not to be used
	// when the author generates a referral for a patient. A copy of that referral may
	// be provided as supporting information. Some insurers require proof of referral
	// to pay for services or to pay specialist rates for services.
	Referral *Reference `json:"referral,omitempty"`

	// Other claims which are related to this claim such as prior submissions or
	// claims for related services or for the same event.
	Related []ClaimRelated `json:"related,omitempty"`

	// This is a Claim resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// A finer grained suite of claim type codes which may convey additional
	// information such as Inpatient vs Outpatient and/or a specialty service.
	SubType *CodeableConcept `json:"subType,omitempty"`

	// The party/group to whom the professional services and/or products have been
	// supplied or are being considered and for whom actual or forecast reimbursement
	// is sought.
	Subject Reference `json:"subject"`

	// Additional information codes regarding exceptions, special considerations, the
	// condition, situation, prior or concurrent issues.
	SupportingInfo []ClaimSupportingInfo `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The total value of the all the items in the claim.
	Total *Money `json:"total,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// The category of claim, e.g. oral, pharmacy, vision, institutional,
	// professional.
	Type CodeableConcept `json:"type"`

	// A code to indicate whether the nature of the request is: Claim - A request to
	// an Insurer to adjudicate the supplied charges for health care goods and
	// services under the identified policy and to pay the determined Benefit amount,
	// if any; Preauthorization - A request to an Insurer to adjudicate the supplied
	// proposed future charges for health care goods and services under the identified
	// policy and to approve the services and provide the expected benefit amounts and
	// potentially to reserve funds to pay the benefits when Claims for the indicated
	// services are later submitted; or, Pre-determination - A request to an Insurer
	// to adjudicate the supplied 'what if' charges for health care goods and services
	// under the identified policy and report back what the Benefit payable would be
	// had the services actually been provided.
	Use_2 *Code `json:"use,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimAccident struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Date of an accident event  related to the products and services contained in
	// the claim.
	Date_2 *Date `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The physical location of the accident event.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// The physical location of the accident event.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type or context of the accident event for the purposes of selection of
	// potential insurance coverages and determination of coordination between
	// insurers.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimBodySite struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Physical service site on the patient (limb, tooth, etc.).
	Site []CodeableReference `json:"site"`

	// A region or surface of the bodySite, e.g. limb region or tooth surface(s).
	SubSite []CodeableConcept `json:"subSite,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimBodySite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["site"]; raw != nil && !ok {
		return fmt.Errorf("field site in ClaimBodySite: required")
	}
	type Plain ClaimBodySite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimBodySite(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimCareTeam struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Member of the team who provided the product or service.
	Provider Reference `json:"provider"`

	// The lead, assisting or supervising practitioner and their discipline if a
	// multidisciplinary team.
	Role *CodeableConcept `json:"role,omitempty"`

	// A number to uniquely identify care team entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The specialization of the practitioner or provider which is applicable for this
	// service.
	Specialty *CodeableConcept `json:"specialty,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimCareTeam) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["provider"]; raw != nil && !ok {
		return fmt.Errorf("field provider in ClaimCareTeam: required")
	}
	type Plain ClaimCareTeam
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimCareTeam(plain)
	return nil
}

type ClaimContainedElem interface{}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimDetail struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the line item.detail.
	// Net = unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// A number to uniquely identify item entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// A claim detail line. Either a simple (a product or service) or a 'group' of
	// sub-details which are simple items.
	SubDetail []ClaimSubDetail `json:"subDetail,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimDiagnosis struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisCodeableConcept *CodeableConcept `json:"diagnosisCodeableConcept,omitempty"`

	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisReference *Reference `json:"diagnosisReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indication of whether the diagnosis was present on admission to a facility.
	OnAdmission *CodeableConcept `json:"onAdmission,omitempty"`

	// A number to uniquely identify diagnosis entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// When the condition was observed or the relative ranking.
	Type []CodeableConcept `json:"type,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimEvent struct {
	// Extensions for whenDateTime
	WhenDateTime *Element `json:"_whenDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A coded event such as when a service is expected or a card printed.
	Type CodeableConcept `json:"type"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenDateTime_2 *string `json:"whenDateTime,omitempty"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClaimEvent: required")
	}
	type Plain ClaimEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.WhenDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.WhenDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WhenDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = ClaimEvent(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimInsurance struct {
	// Extensions for businessArrangement
	BusinessArrangement *Element `json:"_businessArrangement,omitempty"`

	// Extensions for focal
	Focal *Element `json:"_focal,omitempty"`

	// Extensions for preAuthRef
	PreAuthRef []Element `json:"_preAuthRef,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// A business agreement number established between the provider and the insurer
	// for special business processing purposes.
	BusinessArrangement_2 *String `json:"businessArrangement,omitempty"`

	// The result of the adjudication of the line items for the Coverage specified in
	// this insurance.
	ClaimResponse *Reference `json:"claimResponse,omitempty"`

	// Reference to the insurance card level information contained in the Coverage
	// resource. The coverage issuing insurer will use these details to locate the
	// patient's actual coverage within the insurer's information system.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A flag to indicate that this Coverage is to be used for adjudication of this
	// claim when set to true.
	Focal_2 *Boolean `json:"focal,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The business identifier to be used when the claim is sent for adjudication
	// against this insurance policy.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference numbers previously provided by the insurer to the provider to be
	// quoted on subsequent claims containing services or products related to the
	// prior authorization.
	PreAuthRef_2 []String `json:"preAuthRef,omitempty"`

	// A number to uniquely identify insurance entries and provide a sequence of
	// coverages to convey coordination of benefit order.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimInsurance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in ClaimInsurance: required")
	}
	type Plain ClaimInsurance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimInsurance(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimItem struct {
	// Extensions for careTeamSequence
	CareTeamSequence []Element `json:"_careTeamSequence,omitempty"`

	// Extensions for diagnosisSequence
	DiagnosisSequence []Element `json:"_diagnosisSequence,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for informationSequence
	InformationSequence []Element `json:"_informationSequence,omitempty"`

	// Extensions for procedureSequence
	ProcedureSequence []Element `json:"_procedureSequence,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// Physical location where the service is performed or applies.
	BodySite []ClaimBodySite `json:"bodySite,omitempty"`

	// CareTeam members related to this service or product.
	CareTeamSequence_2 []PositiveInt `json:"careTeamSequence,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// A claim detail line. Either a simple (a product or service) or a 'group' of
	// sub-details which are simple items.
	Detail []ClaimDetail `json:"detail,omitempty"`

	// Diagnosis applicable for this service or product.
	DiagnosisSequence_2 []PositiveInt `json:"diagnosisSequence,omitempty"`

	// Healthcare encounters related to this claim.
	Encounter []Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product.
	InformationSequence_2 []PositiveInt `json:"informationSequence,omitempty"`

	// Where the product or service was provided.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// Where the product or service was provided.
	LocationCodeableConcept *CodeableConcept `json:"locationCodeableConcept,omitempty"`

	// Where the product or service was provided.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the line item. Net =
	// unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// Procedures applicable for this service or product.
	ProcedureSequence_2 []PositiveInt `json:"procedureSequence,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Request or Referral for Goods or Service to be rendered.
	Request []Reference `json:"request,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// A number to uniquely identify item entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The party to whom the professional services and/or products have been supplied
	// or are being considered and for whom actual for facast reimbursement is sought.
	Subject *Reference `json:"subject,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimItem) UnmarshalJSON(value []byte) error {
	type Plain ClaimItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = ClaimItem(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimPayee struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the individual or organization to whom any payment will be made.
	Party *Reference `json:"party,omitempty"`

	// Type of Party to be reimbursed: subscriber, provider, other.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimPayee) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClaimPayee: required")
	}
	type Plain ClaimPayee
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimPayee(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimProcedure struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Date and optionally time the procedure was performed.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The code or reference to a Procedure resource which identifies the clinical
	// intervention performed.
	ProcedureCodeableConcept *CodeableConcept `json:"procedureCodeableConcept,omitempty"`

	// The code or reference to a Procedure resource which identifies the clinical
	// intervention performed.
	ProcedureReference *Reference `json:"procedureReference,omitempty"`

	// A number to uniquely identify procedure entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// When the condition was observed or the relative ranking.
	Type []CodeableConcept `json:"type,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimRelated struct {
	// Reference to a related claim.
	Claim *Reference `json:"claim,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An alternate organizational reference to the case or file to which this
	// particular claim pertains.
	Reference *Identifier `json:"reference,omitempty"`

	// A code to convey how the claims are related.
	Relationship *CodeableConcept `json:"relationship,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponse struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outcome
	Outcome *Element `json:"_outcome,omitempty"`

	// Extensions for preAuthRef
	PreAuthRef *Element `json:"_preAuthRef,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// The first-tier service adjudications for payer added product or service lines.
	AddItem []ClaimResponseAddItem `json:"addItem,omitempty"`

	// The adjudication results which are presented at the header level rather than at
	// the line-item or add-item levels.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// Request for additional supporting or authorizing information.
	CommunicationRequest []Reference `json:"communicationRequest,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ClaimResponseContainedElem `json:"contained,omitempty"`

	// The date this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// The result of the claim, predetermination, or preauthorization adjudication.
	Decision *CodeableConcept `json:"decision,omitempty"`

	// A package billing code or bundle code used to group products and services to a
	// particular health condition (such as heart attack) which is based on a
	// predetermined grouping code system.
	DiagnosisRelatedGroup *CodeableConcept `json:"diagnosisRelatedGroup,omitempty"`

	// A human readable description of the status of the adjudication.
	Disposition_2 *String `json:"disposition,omitempty"`

	// Healthcare encounters related to this claim.
	Encounter []Reference `json:"encounter,omitempty"`

	// Errors encountered during the processing of the adjudication.
	Error []ClaimResponseError `json:"error,omitempty"`

	// Information code for an event with a corresponding date or period.
	Event []ClaimResponseEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual form, by reference or inclusion, for printing the content or an EOB.
	Form *Attachment `json:"form,omitempty"`

	// A code for the form to be used for printing the content.
	FormCode *CodeableConcept `json:"formCode,omitempty"`

	// A code, used only on a response to a preauthorization, to indicate whether the
	// benefits payable have been reserved and for whom.
	FundsReserve *CodeableConcept `json:"fundsReserve,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this claim response.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Financial instruments for reimbursement for the health care products and
	// services specified on the claim.
	Insurance []ClaimResponseInsurance `json:"insurance,omitempty"`

	// The party responsible for authorization, adjudication and reimbursement.
	Insurer *Reference `json:"insurer,omitempty"`

	// A claim line. Either a simple (a product or service) or a 'group' of details
	// which can also be a simple items or groups of sub-details.
	Item []ClaimResponseItem `json:"item,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The outcome of the claim, predetermination, or preauthorization processing.
	Outcome_2 *Code `json:"outcome,omitempty"`

	// Type of Party to be reimbursed: subscriber, billing provider, other.
	PayeeType *CodeableConcept `json:"payeeType,omitempty"`

	// Payment details for the adjudication of the claim.
	Payment *ClaimResponsePayment `json:"payment,omitempty"`

	// The time frame during which this authorization is effective.
	PreAuthPeriod *Period `json:"preAuthPeriod,omitempty"`

	// Reference from the Insurer which is used in later communications which refers
	// to this adjudication.
	PreAuthRef_2 *String `json:"preAuthRef,omitempty"`

	// A note that describes or explains adjudication results in a human readable
	// form.
	ProcessNote []ClaimResponseProcessNote `json:"processNote,omitempty"`

	// Original request resource reference.
	Request *Reference `json:"request,omitempty"`

	// The provider which is responsible for the claim, predetermination or
	// preauthorization.
	Requestor *Reference `json:"requestor,omitempty"`

	// This is a ClaimResponse resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// A finer grained suite of claim type codes which may convey additional
	// information such as Inpatient vs Outpatient and/or a specialty service.
	SubType *CodeableConcept `json:"subType,omitempty"`

	// The party/group to whom the professional services and/or products have been
	// supplied or are being considered and for whom actual for facast reimbursement
	// is sought.
	Subject Reference `json:"subject"`

	// Additional information codes regarding exceptions, special considerations, the
	// condition, situation, prior or concurrent issues.
	SupportingInfo []ClaimResponseSupportingInfo `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Categorized monetary totals for the adjudication.
	Total []ClaimResponseTotal `json:"total,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// A finer grained suite of claim type codes which may convey additional
	// information such as Inpatient vs Outpatient and/or a specialty service.
	Type CodeableConcept `json:"type"`

	// A code to indicate whether the nature of the request is: Claim - A request to
	// an Insurer to adjudicate the supplied charges for health care goods and
	// services under the identified policy and to pay the determined Benefit amount,
	// if any; Preauthorization - A request to an Insurer to adjudicate the supplied
	// proposed future charges for health care goods and services under the identified
	// policy and to approve the services and provide the expected benefit amounts and
	// potentially to reserve funds to pay the benefits when Claims for the indicated
	// services are later submitted; or, Pre-determination - A request to an Insurer
	// to adjudicate the supplied 'what if' charges for health care goods and services
	// under the identified policy and report back what the Benefit payable would be
	// had the services actually been provided.
	Use_2 *Code `json:"use,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseAddItem struct {
	// Extensions for detailSequence
	DetailSequence []Element `json:"_detailSequence,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for informationSequence
	InformationSequence []Element `json:"_informationSequence,omitempty"`

	// Extensions for itemSequence
	ItemSequence []Element `json:"_itemSequence,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// Extensions for subdetailSequence
	SubdetailSequence []Element `json:"_subdetailSequence,omitempty"`

	// The adjudication results.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// Physical location where the service is performed or applies.
	BodySite []ClaimResponseBodySite `json:"bodySite,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// The second-tier service adjudications for payer added services.
	Detail []ClaimResponseDetail1 `json:"detail,omitempty"`

	// The sequence number of the details within the claim item which this line is
	// intended to replace.
	DetailSequence_2 []PositiveInt `json:"detailSequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product.
	InformationSequence_2 []PositiveInt `json:"informationSequence,omitempty"`

	// Claim items which this service line is intended to replace.
	ItemSequence_2 []PositiveInt `json:"itemSequence,omitempty"`

	// Where the product or service was provided.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// Where the product or service was provided.
	LocationCodeableConcept *CodeableConcept `json:"locationCodeableConcept,omitempty"`

	// Where the product or service was provided.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the addItem. Net =
	// unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The providers who are authorized for the services rendered to the patient.
	Provider []Reference `json:"provider,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Request or Referral for Goods or Service to be rendered.
	Request []Reference `json:"request,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The sequence number of the sub-details within the details within the claim item
	// which this line is intended to replace.
	SubdetailSequence_2 []PositiveInt `json:"subdetailSequence,omitempty"`

	// The party to whom the professional services and/or products have been supplied
	// or are being considered and for whom actual for facast reimbursement is sought.
	Subject *Reference `json:"subject,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseAddItem) UnmarshalJSON(value []byte) error {
	type Plain ClaimResponseAddItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = ClaimResponseAddItem(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseAdjudication struct {
	// Extensions for decisionDate
	DecisionDate *Element `json:"_decisionDate,omitempty"`

	// Monetary amount associated with the category.
	Amount *Money `json:"amount,omitempty"`

	// A code to indicate the information type of this adjudication record.
	// Information types may include the value submitted, maximum values or
	// percentages allowed or payable under the plan, amounts that: the patient is
	// responsible for in aggregate or pertaining to this item; amounts paid by other
	// coverages; and, the benefit payable for this item.
	Category CodeableConcept `json:"category"`

	// The date and time the adjudication decision occured.
	DecisionDate_2 *DateTime `json:"decisionDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A non-monetary value associated with the category. Mutually exclusive to the
	// amount element above.
	Quantity *Quantity `json:"quantity,omitempty"`

	// A code supporting the understanding of the adjudication result and explaining
	// variance from expected amount.
	Reason *CodeableConcept `json:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseAdjudication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ClaimResponseAdjudication: required")
	}
	type Plain ClaimResponseAdjudication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponseAdjudication(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseBodySite struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Physical service site on the patient (limb, tooth, etc.).
	Site []CodeableReference `json:"site"`

	// A region or surface of the bodySite, e.g. limb region or tooth surface(s).
	SubSite []CodeableConcept `json:"subSite,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseBodySite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["site"]; raw != nil && !ok {
		return fmt.Errorf("field site in ClaimResponseBodySite: required")
	}
	type Plain ClaimResponseBodySite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponseBodySite(plain)
	return nil
}

type ClaimResponseContainedElem interface{}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseDetail struct {
	// Extensions for detailSequence
	DetailSequence *Element `json:"_detailSequence,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// The adjudication results.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// A number to uniquely reference the claim detail entry.
	DetailSequence_2 *PositiveInt `json:"detailSequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// A sub-detail adjudication of a simple product or service.
	SubDetail []ClaimResponseSubDetail `json:"subDetail,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseDetail1 struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// The adjudication results.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the addItem.detail.
	// Net = unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// The third-tier service adjudications for payer added services.
	SubDetail []ClaimResponseSubDetail1 `json:"subDetail,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseError struct {
	// Extensions for detailSequence
	DetailSequence *Element `json:"_detailSequence,omitempty"`

	// Extensions for expression
	Expression []Element `json:"_expression,omitempty"`

	// Extensions for itemSequence
	ItemSequence *Element `json:"_itemSequence,omitempty"`

	// Extensions for subDetailSequence
	SubDetailSequence *Element `json:"_subDetailSequence,omitempty"`

	// An error code, from a specified code system, which details why the claim could
	// not be adjudicated.
	Code CodeableConcept `json:"code"`

	// The sequence number of the detail within the line item submitted which contains
	// the error. This value is omitted when the error occurs outside of the item
	// structure.
	DetailSequence_2 *PositiveInt `json:"detailSequence,omitempty"`

	// A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names,
	// repetition indicators and the default child accessor that identifies one of the
	// elements in the resource that caused this issue to be raised.
	Expression_2 []String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The sequence number of the line item submitted which contains the error. This
	// value is omitted when the error occurs outside of the item structure.
	ItemSequence_2 *PositiveInt `json:"itemSequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The sequence number of the sub-detail within the detail within the line item
	// submitted which contains the error. This value is omitted when the error occurs
	// outside of the item structure.
	SubDetailSequence_2 *PositiveInt `json:"subDetailSequence,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ClaimResponseError: required")
	}
	type Plain ClaimResponseError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponseError(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseEvent struct {
	// Extensions for whenDateTime
	WhenDateTime *Element `json:"_whenDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A coded event such as when a service is expected or a card printed.
	Type CodeableConcept `json:"type"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenDateTime_2 *string `json:"whenDateTime,omitempty"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClaimResponseEvent: required")
	}
	type Plain ClaimResponseEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.WhenDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.WhenDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WhenDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = ClaimResponseEvent(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseInsurance struct {
	// Extensions for businessArrangement
	BusinessArrangement *Element `json:"_businessArrangement,omitempty"`

	// Extensions for focal
	Focal *Element `json:"_focal,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// A business agreement number established between the provider and the insurer
	// for special business processing purposes.
	BusinessArrangement_2 *String `json:"businessArrangement,omitempty"`

	// The result of the adjudication of the line items for the Coverage specified in
	// this insurance.
	ClaimResponse *Reference `json:"claimResponse,omitempty"`

	// Reference to the insurance card level information contained in the Coverage
	// resource. The coverage issuing insurer will use these details to locate the
	// patient's actual coverage within the insurer's information system.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A flag to indicate that this Coverage is to be used for adjudication of this
	// claim when set to true.
	Focal_2 *Boolean `json:"focal,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A number to uniquely identify insurance entries and provide a sequence of
	// coverages to convey coordination of benefit order.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseInsurance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in ClaimResponseInsurance: required")
	}
	type Plain ClaimResponseInsurance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponseInsurance(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseItem struct {
	// Extensions for informationSequence
	InformationSequence []Element `json:"_informationSequence,omitempty"`

	// Extensions for itemSequence
	ItemSequence *Element `json:"_itemSequence,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// If this item is a group then the values here are a summary of the adjudication
	// of the detail items. If this item is a simple product or service then this is
	// the result of the adjudication of this item.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// A claim detail. Either a simple (a product or service) or a 'group' of
	// sub-details which are simple items.
	Detail []ClaimResponseDetail `json:"detail,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product.
	InformationSequence_2 []PositiveInt `json:"informationSequence,omitempty"`

	// A number to uniquely reference the claim item entries.
	ItemSequence_2 *PositiveInt `json:"itemSequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponsePayment struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Total amount of all adjustments to this payment included in this transaction
	// which are not related to this claim's adjudication.
	Adjustment *Money `json:"adjustment,omitempty"`

	// Reason for the payment adjustment.
	AdjustmentReason *CodeableConcept `json:"adjustmentReason,omitempty"`

	// Benefits payable less any payment adjustment.
	Amount Money `json:"amount"`

	// Estimated date the payment will be issued or the actual issue date of payment.
	Date_2 *Date `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Issuer's unique identifier for the payment instrument.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether this represents partial or complete payment of the benefits payable.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponsePayment) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in ClaimResponsePayment: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClaimResponsePayment: required")
	}
	type Plain ClaimResponsePayment
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponsePayment(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseProcessNote struct {
	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// A code to indicate the business purpose of the note.
	Class *CodeableConcept `json:"class,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A code to define the language used in the text of the note.
	Language *CodeableConcept `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A number to uniquely identify a note entry.
	Number_2 *PositiveInt `json:"number,omitempty"`

	// The explanation or description associated with the processing.
	Text_2 *Markdown `json:"text,omitempty"`

	// The business purpose of the note text.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseReviewOutcome struct {
	// Extensions for preAuthRef
	PreAuthRef *Element `json:"_preAuthRef,omitempty"`

	// The result of the claim, predetermination, or preauthorization adjudication.
	Decision *CodeableConcept `json:"decision,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time frame during which this authorization is effective.
	PreAuthPeriod *Period `json:"preAuthPeriod,omitempty"`

	// Reference from the Insurer which is used in later communications which refers
	// to this adjudication.
	PreAuthRef_2 *String `json:"preAuthRef,omitempty"`

	// The reasons for the result of the claim, predetermination, or preauthorization
	// adjudication.
	Reason []CodeableConcept `json:"reason,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseSubDetail struct {
	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for subDetailSequence
	SubDetailSequence *Element `json:"_subDetailSequence,omitempty"`

	// The adjudication results.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// A number to uniquely reference the claim sub-detail entry.
	SubDetailSequence_2 *PositiveInt `json:"subDetailSequence,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseSubDetail1 struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// The adjudication results.
	Adjudication []ClaimResponseAdjudication `json:"adjudication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the addItem.detail.subDetail. Net = unit price *
	// quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ClaimResponseReviewOutcome `json:"reviewOutcome,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseSupportingInfo struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for timingDateTime
	TimingDateTime *Element `json:"_timingDateTime,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// The general class of the information supplied: information; exception;
	// accident, employment; onset, etc.
	Category CodeableConcept `json:"category"`

	// System and code pertaining to the specific information regarding special
	// conditions relating to the setting, treatment or patient  for which care is
	// sought.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides the reason in the situation where a reason code is required in
	// addition to the content.
	Reason *CodeableConcept `json:"reason,omitempty"`

	// A number to uniquely identify supporting information entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The date when or period to which this information refers.
	TimingDateTime_2 *string `json:"timingDateTime,omitempty"`

	// The date when or period to which this information refers.
	TimingPeriod *Period `json:"timingPeriod,omitempty"`

	// The date when or period to which this information refers.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAge *Age `json:"valueAge,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCount *Count `json:"valueCount,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueID_2 *string `json:"valueId,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseSupportingInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ClaimResponseSupportingInfo: required")
	}
	type Plain ClaimResponseSupportingInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TimingDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimingDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ClaimResponseSupportingInfo(plain)
	return nil
}

// This resource provides the adjudication details from the processing of a Claim
// resource.
type ClaimResponseTotal struct {
	// Monetary total amount associated with the category.
	Amount Money `json:"amount"`

	// A code to indicate the information type of this adjudication record.
	// Information types may include: the value submitted, maximum values or
	// percentages allowed or payable under the plan, amounts that the patient is
	// responsible for in aggregate or pertaining to this item, amounts paid by other
	// coverages, and the benefit payable for this item.
	Category CodeableConcept `json:"category"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponseTotal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in ClaimResponseTotal: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ClaimResponseTotal: required")
	}
	type Plain ClaimResponseTotal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponseTotal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ClaimResponse: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ClaimResponse: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ClaimResponse: required")
	}
	type Plain ClaimResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClaimResponse(plain)
	return nil
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimSubDetail struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for line item.detail.subDetail. Net = unit price *
	// quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// A number to uniquely identify item entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// A provider issued list of professional services and products which have been
// provided, or are to be provided, to a patient which is sent to an insurer for
// reimbursement.
type ClaimSupportingInfo struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for timingDateTime
	TimingDateTime *Element `json:"_timingDateTime,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// The general class of the information supplied: information; exception;
	// accident, employment; onset, etc.
	Category CodeableConcept `json:"category"`

	// System and code pertaining to the specific information regarding special
	// conditions relating to the setting, treatment or patient  for which care is
	// sought.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides the reason in the situation where a reason code is required in
	// addition to the content.
	Reason *CodeableConcept `json:"reason,omitempty"`

	// A number to uniquely identify supporting information entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// A finer classification within the more general category.
	SubCategory *CodeableConcept `json:"subCategory,omitempty"`

	// The date when or period to which this information refers.
	TimingDateTime_2 *string `json:"timingDateTime,omitempty"`

	// The date when or period to which this information refers.
	TimingPeriod *Period `json:"timingPeriod,omitempty"`

	// The date when or period to which this information refers.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAge *Age `json:"valueAge,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCount *Count `json:"valueCount,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueID_2 *string `json:"valueId,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimSupportingInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ClaimSupportingInfo: required")
	}
	type Plain ClaimSupportingInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TimingDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimingDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ClaimSupportingInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Claim) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Claim: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in Claim: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Claim: required")
	}
	type Plain Claim
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Claim(plain)
	return nil
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinition struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// A categorisation of the issue, primarily for dividing warnings into subject
	// heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on
	// Ability to Drive and Use Machines".
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ClinicalUseDefinitionContainedElem `json:"contained,omitempty"`

	// Specifics for when this is a contraindication.
	Contraindication *ClinicalUseDefinitionContraindication `json:"contraindication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifier for this issue.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Specifics for when this is an indication.
	Indication *ClinicalUseDefinitionIndication `json:"indication,omitempty"`

	// Specifics for when this is an interaction.
	Interaction *ClinicalUseDefinitionInteraction `json:"interaction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Logic used by the clinical use definition.
	Library []Canonical `json:"library,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The population group to which this applies.
	Population []Reference `json:"population,omitempty"`

	// This is a ClinicalUseDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// Whether this is a current issue or one that has been retired etc.
	Status *CodeableConcept `json:"status,omitempty"`

	// The medication, product, substance, device, procedure etc. for which this is an
	// indication, contraindication, interaction, undesirable effect, or warning.
	Subject []CodeableReference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// indication | contraindication | interaction | undesirable-effect | warning.
	Type_2 *Code `json:"type,omitempty"`

	// Describe the possible undesirable effects (negative outcomes) from the use of
	// the medicinal product as treatment.
	UndesirableEffect *ClinicalUseDefinitionUndesirableEffect `json:"undesirableEffect,omitempty"`

	// A critical piece of information about environmental, health or physical risks
	// or hazards that serve as caution to the user. For example 'Do not operate heavy
	// machinery', 'May cause drowsiness', or 'Get medical advice/attention if you
	// feel unwell'.
	Warning *ClinicalUseDefinitionWarning `json:"warning,omitempty"`
}

type ClinicalUseDefinitionContainedElem interface{}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionContraindication struct {
	// An expression that returns true or false, indicating whether the indication is
	// applicable or not, after having applied its other elements.
	Applicability *Expression `json:"applicability,omitempty"`

	// A comorbidity (concurrent condition) or coinfection. Where this repeats it
	// means that any one of these is relevant, rather than all of them needing to be
	// present.
	Comorbidity []CodeableReference `json:"comorbidity,omitempty"`

	// The status of the disease or symptom for the contraindication, for example
	// "chronic" or "metastatic".
	DiseaseStatus *CodeableReference `json:"diseaseStatus,omitempty"`

	// The situation that is being documented as contraindicating against this item.
	DiseaseSymptomProcedure *CodeableReference `json:"diseaseSymptomProcedure,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The indication which this is a contraindication for.
	Indication []ClinicalUseDefinitionIndication `json:"indication,omitempty"`

	// Actions for managing the contraindication.
	Management []CodeableConcept `json:"management,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Information about the use of the medicinal product in relation to other
	// therapies described as part of the contraindication.
	OtherTherapy []ClinicalUseDefinitionOtherTherapy `json:"otherTherapy,omitempty"`
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionIndication struct {
	// Extensions for durationString
	DurationString *Element `json:"_durationString,omitempty"`

	// An expression that returns true or false, indicating whether the indication is
	// applicable or not, after having applied its other elements.
	Applicability *Expression `json:"applicability,omitempty"`

	// A comorbidity (concurrent condition) or coinfection as part of the indication.
	// Where this repeats it means that any one of these is relevant, rather than all
	// of them needing to be present.
	Comorbidity []CodeableReference `json:"comorbidity,omitempty"`

	// The status of the disease or symptom for the indication, for example "chronic"
	// or "metastatic".
	DiseaseStatus *CodeableReference `json:"diseaseStatus,omitempty"`

	// The situation that is being documented as an indication for this item.
	DiseaseSymptomProcedure *CodeableReference `json:"diseaseSymptomProcedure,omitempty"`

	// Timing or duration information, that may be associated with use with the
	// indicated condition e.g. Adult patients suffering from myocardial infarction
	// (from a few days until less than 35 days), ischaemic stroke (from 7 days until
	// less than 6 months).
	DurationRange *Range `json:"durationRange,omitempty"`

	// Timing or duration information, that may be associated with use with the
	// indicated condition e.g. Adult patients suffering from myocardial infarction
	// (from a few days until less than 35 days), ischaemic stroke (from 7 days until
	// less than 6 months).
	DurationString_2 *string `json:"durationString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The intended effect, aim or strategy to be achieved.
	IntendedEffect []CodeableReference `json:"intendedEffect,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Information about the use of the medicinal product in relation to other
	// therapies described as part of the contraindication.
	OtherTherapy []ClinicalUseDefinitionOtherTherapy `json:"otherTherapy,omitempty"`

	// An unwanted side effect or negative outcome that may happen if you use the drug
	// (or other subject of this resource) for this indication.
	UndesirableEffect []ClinicalUseDefinitionUndesirableEffect `json:"undesirableEffect,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClinicalUseDefinitionIndication) UnmarshalJSON(value []byte) error {
	type Plain ClinicalUseDefinitionIndication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DurationString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DurationString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DurationString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ClinicalUseDefinitionIndication(plain)
	return nil
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionInteractant struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The specific medication, product, food, substance etc. or laboratory test that
	// interacts.
	ItemCodeableConcept *CodeableConcept `json:"itemCodeableConcept,omitempty"`

	// The specific medication, product, food, substance etc. or laboratory test that
	// interacts.
	ItemReference *Reference `json:"itemReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The route by which the item is administered to cause the interaction.
	Route *CodeableConcept `json:"route,omitempty"`
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionInteraction struct {
	// The effect of the interaction, for example "reduced gastric absorption of
	// primary medication".
	Effect *CodeableReference `json:"effect,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The incidence of the interaction, e.g. theoretical, observed.
	Incidence *CodeableConcept `json:"incidence,omitempty"`

	// The specific medication, product, food, substance etc. or laboratory test that
	// interacts.
	Interactant []ClinicalUseDefinitionInteractant `json:"interactant,omitempty"`

	// Actions for managing the interaction.
	Management []CodeableConcept `json:"management,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The severity of the interaction.
	Severity *CodeableConcept `json:"severity,omitempty"`

	// The type of the interaction e.g. drug-drug interaction, drug-food interaction,
	// drug-lab test interaction.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionOtherTherapy struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of relationship between the medicinal product indication or
	// contraindication and another therapy.
	RelationshipType CodeableConcept `json:"relationshipType"`

	// Reference to a specific medication (active substance, medicinal product or
	// class of products, biological, food etc.) as part of an indication or
	// contraindication.
	Treatment CodeableReference `json:"treatment"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClinicalUseDefinitionOtherTherapy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["relationshipType"]; raw != nil && !ok {
		return fmt.Errorf("field relationshipType in ClinicalUseDefinitionOtherTherapy: required")
	}
	if _, ok := raw["treatment"]; raw != nil && !ok {
		return fmt.Errorf("field treatment in ClinicalUseDefinitionOtherTherapy: required")
	}
	type Plain ClinicalUseDefinitionOtherTherapy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClinicalUseDefinitionOtherTherapy(plain)
	return nil
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionUndesirableEffect struct {
	// High level classification of the effect.
	Classification *CodeableConcept `json:"classification,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// How often the effect is seen.
	FrequencyOfOccurrence *CodeableConcept `json:"frequencyOfOccurrence,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Actions for managing the undesirable effect.
	Management []CodeableConcept `json:"management,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The situation in which the undesirable effect may manifest.
	SymptomConditionEffect *CodeableReference `json:"symptomConditionEffect,omitempty"`
}

// A single issue - either an indication, contraindication, interaction or an
// undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinitionWarning struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// A coded or unformatted textual definition of this warning.
	Code *CodeableConcept `json:"code,omitempty"`

	// A textual definition of this warning, with formatting.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClinicalUseDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ClinicalUseDefinition: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ClinicalUseDefinition: required")
	}
	type Plain ClinicalUseDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ClinicalUseDefinition(plain)
	return nil
}

// A string which has at least one character and no leading or trailing whitespace
// and where there is no whitespace other than single spaces in the contents
type Code string

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystem struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for caseSensitive
	CaseSensitive *Element `json:"_caseSensitive,omitempty"`

	// Extensions for compositional
	Compositional *Element `json:"_compositional,omitempty"`

	// Extensions for content
	Content *Element `json:"_content,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for hierarchyMeaning
	HierarchyMeaning *Element `json:"_hierarchyMeaning,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Extensions for versionNeeded
	VersionNeeded *Element `json:"_versionNeeded,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the CodeSystem.
	Author []ContactDetail `json:"author,omitempty"`

	// If code comparison is case sensitive when codes within this system are compared
	// to each other.
	CaseSensitive_2 *Boolean `json:"caseSensitive,omitempty"`

	// The code system defines a compositional (post-coordination) grammar.
	Compositional_2 *Boolean `json:"compositional,omitempty"`

	// Concepts that are in the code system. The concept definitions are inherently
	// hierarchical, but the definitions must be consulted to determine what the
	// meanings of the hierarchical relationships are.
	Concept []CodeSystemConcept `json:"concept,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CodeSystemContainedElem `json:"contained,omitempty"`

	// The extent of the content of the code system (the concepts and codes it
	// defines) are represented in this resource instance.
	Content_2 *Code `json:"content,omitempty"`

	// A copyright statement relating to the code system and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the code system.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The total number of concepts defined by the code system. Where the code system
	// has a compositional grammar, the basis of this count is defined by the system
	// steward.
	Count_2 *UnsignedInt `json:"count,omitempty"`

	// The date  (and optionally time) when the code system was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the code system changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the code system from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the CodeSystem.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the CodeSystem content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the CodeSystem for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this code system is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A filter that can be used in a value set compose statement when selecting
	// concepts using a filter.
	Filter []CodeSystemFilter `json:"filter,omitempty"`

	// The meaning of the hierarchy of concepts as represented in this resource.
	HierarchyMeaning_2 *Code `json:"hierarchyMeaning,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this code system when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the code system. This name should be usable
	// as an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// A property defines an additional slot through which additional information can
	// be provided about a concept.
	Property []CodeSystemProperty `json:"property,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the code system.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this code system is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts. If the type is `successor` or `predecessor`, the related resource
	// must be a CodeSystem.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a CodeSystem resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the CodeSystem.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this code system. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// The canonical URL of the code system that this code system supplement is adding
	// designations and properties to.
	Supplements *Canonical `json:"supplements,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the code system.
	Title_2 *String `json:"title,omitempty"`

	// Descriptions related to the content of the CodeSystem. Topics provide a
	// high-level categorization as well as keywords for the CodeSystem that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this code system when it is referenced
	// in a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this code system is (or will be) published.
	// This URL can be the target of a canonical reference. It SHALL remain the same
	// when the code system is stored on different servers. This is used in
	// [Coding](datatypes.html#Coding).system.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate code system
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// Canonical reference to the value set that contains all codes in the code system
	// independent of code status.
	ValueSet *Canonical `json:"valueSet,omitempty"`

	// The identifier that is used to identify this version of the code system when it
	// is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the code system author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence. This is used in
	// [Coding](datatypes.html#Coding).version.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which CodeSystem
	// is more current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which CodeSystem
	// is more current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`

	// This flag is used to signify that the code system does not commit to concept
	// permanence across versions. If true, a version must be specified when
	// referencing this code system.
	VersionNeeded_2 *Boolean `json:"versionNeeded,omitempty"`
}

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystemConcept struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for definition
	Definition *Element `json:"_definition,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// A code - a text symbol - that uniquely identifies the concept within the code
	// system.
	Code_2 *Code `json:"code,omitempty"`

	// Defines children of a concept to produce a hierarchy of concepts. The nature of
	// the relationships is variable (is-a/contains/categorizes) - see
	// hierarchyMeaning.
	Concept []CodeSystemConcept `json:"concept,omitempty"`

	// The formal definition of the concept. The code system resource does not make
	// formal definitions required, because of the prevalence of legacy systems.
	// However, they are highly recommended, as without them there is no formal
	// meaning associated with the concept.
	Definition_2 *String `json:"definition,omitempty"`

	// Additional representations for the concept - other languages, aliases,
	// specialized purposes, used for particular purposes, etc.
	Designation []CodeSystemDesignation `json:"designation,omitempty"`

	// A human readable string that is the recommended default way to present this
	// concept to a user.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A property value for this concept.
	Property []CodeSystemProperty1 `json:"property,omitempty"`
}

type CodeSystemContainedElem interface{}

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystemDesignation struct {
	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Additional codes that detail how this designation would be used, if there is
	// more than one use.
	AdditionalUse []Coding `json:"additionalUse,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language this designation is defined for.
	Language_2 *Code `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code that details how this designation would be used.
	Use *Coding `json:"use,omitempty"`

	// The text value for this designation.
	Value_2 *String `json:"value,omitempty"`
}

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystemFilter struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for operator
	Operator []Element `json:"_operator,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// The code that identifies this filter when it is used as a filter in
	// [ValueSet](valueset.html#).compose.include.filter.
	Code_2 *Code `json:"code,omitempty"`

	// A description of how or why the filter is used.
	Description_2 *String `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A list of operators that can be used with the filter.
	Operator_2 []Code `json:"operator,omitempty"`

	// A description of what the value for the filter should be.
	Value_2 *String `json:"value,omitempty"`
}

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystemProperty struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// A code that is used to identify the property. The code is used internally (in
	// CodeSystem.concept.property.code) and also externally, such as in property
	// filters.
	Code_2 *Code `json:"code,omitempty"`

	// A description of the property- why it is defined, and how its value might be
	// used.
	Description_2 *String `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of the property value. Properties of type "code" contain a code
	// defined by the code system (e.g. a reference to another defined concept).
	Type_2 *Code `json:"type,omitempty"`

	// Reference to the formal meaning of the property. One possible source of meaning
	// is the [Concept Properties](codesystem-concept-properties.html) code system.
	Uri_2 *Uri `json:"uri,omitempty"`
}

// The CodeSystem resource is used to declare the existence of and describe a code
// system or code system supplement and its key properties, and optionally define a
// part or all of its content.
type CodeSystemProperty1 struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A code that is a reference to CodeSystem.property.code or is a code from
	// [http://hl7.org/fhir/concept-properties](codesystem.html#defined-props) in the
	// case that there is no corresponding code defined in `CodeSystem.property.code`.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The value of this property.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of this property.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of this property.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of this property.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of this property.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of this property.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of this property.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeSystemProperty1) UnmarshalJSON(value []byte) error {
	type Plain CodeSystemProperty1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = CodeSystemProperty1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeSystem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CodeSystem: required")
	}
	type Plain CodeSystem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = CodeSystem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Code) UnmarshalJSON(value []byte) error {
	type Plain Code
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^[^\s]+( [^\s]+)*$`)
	}
	*j = Code(plain)
	return nil
}

// A concept that may be defined by a formal reference to a terminology or ontology
// or may be provided by text.
type CodeableConcept struct {
	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// A reference to a code defined by a terminology system.
	Coding []Coding `json:"coding,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A human language representation of the concept as seen/selected/uttered by the
	// user who entered the data and/or which represents the intended meaning of the
	// user.
	Text_2 *String `json:"text,omitempty"`
}

// A reference to a resource (by instance), or instead, a reference to a concept
// defined in a terminology or ontology (by class).
type CodeableReference struct {
	// A reference to a concept - e.g. the information is identified by its general
	// class to the degree of precision found in the terminology.
	Concept *CodeableConcept `json:"concept,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A reference to a resource the provides exact details about the information
	// being referenced.
	Reference *Reference `json:"reference,omitempty"`
}

// A reference to a code defined by a terminology system.
type Coding struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for userSelected
	UserSelected *Element `json:"_userSelected,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// A symbol in syntax defined by the system. The symbol may be a predefined code
	// or an expression in a syntax defined by the coding system (e.g.
	// post-coordination).
	Code_2 *Code `json:"code,omitempty"`

	// A representation of the meaning of the code in the system, following the rules
	// of the system.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the code system that defines the meaning of the symbol in
	// the code.
	System_2 *Uri `json:"system,omitempty"`

	// Indicates that this coding was chosen by a user directly - e.g. off a pick list
	// of available items (codes or displays).
	UserSelected_2 *Boolean `json:"userSelected,omitempty"`

	// The version of the code system which was used when choosing this code. Note
	// that a well-maintained code system does not need the version reported, because
	// the meaning of codes is consistent across versions. However this cannot
	// consistently be assured, and when the meaning is not guaranteed to be
	// consistent, the version SHOULD be exchanged.
	Version_2 *String `json:"version,omitempty"`
}

// A clinical or business level record of information being transmitted or shared;
// e.g. an alert that was sent to a responsible provider, a public health agency
// communication to a provider/reporter in response to a case report for a
// reportable condition.
type Communication struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for received
	Received *Element `json:"_received,omitempty"`

	// Extensions for sent
	Sent *Element `json:"_sent,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Other resources that pertain to this communication and to which this
	// communication should be associated.
	About []Reference `json:"about,omitempty"`

	// An order, proposal or plan fulfilled in whole or in part by this Communication.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The type of message conveyed such as alert, notification, reminder,
	// instruction, etc.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CommunicationContainedElem `json:"contained,omitempty"`

	// The Encounter during which this Communication was created or to which the
	// creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this communication by the performer or other
	// systems which remain constant as the resource is updated and propagates from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Prior communication that this communication is in response to.
	InResponseTo []Reference `json:"inResponseTo,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A channel that was used for this communication (e.g. email, fax, SMS).
	Medium []CodeableConcept `json:"medium,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional notes or commentary about the communication by the sender, receiver
	// or other interested parties.
	Note []Annotation `json:"note,omitempty"`

	// A larger event (e.g. Communication, Procedure) of which this particular
	// communication is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// Text, attachment(s), or resource(s) that was communicated to the recipient.
	Payload []CommunicationPayload `json:"payload,omitempty"`

	// Characterizes how quickly the planned or in progress communication must be
	// addressed. Includes concepts such as stat, urgent, routine.
	Priority_2 *Code `json:"priority,omitempty"`

	// The reason or justification for the communication.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The time when this communication arrived at the destination.
	Received_2 *DateTime `json:"received,omitempty"`

	// The entity (e.g. person, organization, clinical information system, care team
	// or device) which is the target of the communication.
	Recipient []Reference `json:"recipient,omitempty"`

	// This is a Communication resource
	ResourceType interface{} `json:"resourceType"`

	// The entity (e.g. person, organization, clinical information system, or device)
	// which is the source of the communication.
	Sender *Reference `json:"sender,omitempty"`

	// The time when this communication was sent.
	Sent_2 *DateTime `json:"sent,omitempty"`

	// The status of the transmission.
	Status_2 *Code `json:"status,omitempty"`

	// Captures the reason for the current state of the Communication.
	StatusReason *CodeableConcept `json:"statusReason,omitempty"`

	// The patient or group that was the focus of this communication.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Description of the purpose/content, similar to a subject line in an email.
	Topic *CodeableConcept `json:"topic,omitempty"`
}

type CommunicationContainedElem interface{}

// A clinical or business level record of information being transmitted or shared;
// e.g. an alert that was sent to a responsible provider, a public health agency
// communication to a provider/reporter in response to a case report for a
// reportable condition.
type CommunicationPayload struct {
	// A communicated content (or for multi-part communications, one portion of the
	// communication).
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`

	// A communicated content (or for multi-part communications, one portion of the
	// communication).
	ContentCodeableConcept *CodeableConcept `json:"contentCodeableConcept,omitempty"`

	// A communicated content (or for multi-part communications, one portion of the
	// communication).
	ContentReference *Reference `json:"contentReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A request to convey information from a sender to a recipient.
type CommunicationRequest struct {
	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Other resources that pertain to this communication request and to which this
	// communication request should be associated.
	About []Reference `json:"about,omitempty"`

	// For draft requests, indicates the date of initial creation.  For requests with
	// other statuses, indicates the date of activation.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// A plan or proposal that is fulfilled in whole or in part by this request.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The type of message to be sent such as alert, notification, reminder,
	// instruction, etc.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CommunicationRequestContainedElem `json:"contained,omitempty"`

	// If true indicates that the CommunicationRequest is asking for the specified
	// action to *not* occur.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// The Encounter during which this CommunicationRequest was created or to which
	// the creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A shared identifier common to multiple independent Request instances that were
	// activated/authorized more or less simultaneously by a single author.  The
	// presence of the same identifier on each request ties those requests together
	// and may have business ramifications in terms of reporting of results, billing,
	// etc.  E.g. a requisition number shared by a set of lab tests ordered together,
	// or a prescription number shared by all meds ordered at one time.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this communication request by the performer or
	// other systems which remain constant as the resource is updated and propagates
	// from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The entity (e.g. person, organization, clinical information system, or device)
	// which is to be the source of the communication.
	InformationProvider []Reference `json:"informationProvider,omitempty"`

	// Indicates the level of authority/intentionality associated with the
	// CommunicationRequest and where the request fits into the workflow chain.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A channel that was used for this communication (e.g. email, fax).
	Medium []CodeableConcept `json:"medium,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the request by the requester, sender, recipient, subject or
	// other participants.
	Note []Annotation `json:"note,omitempty"`

	// The time when this communication is to occur.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The time when this communication is to occur.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// Text, attachment(s), or resource(s) to be communicated to the recipient.
	Payload []CommunicationRequestPayload `json:"payload,omitempty"`

	// Characterizes how quickly the proposed act must be initiated. Includes concepts
	// such as stat, urgent, routine.
	Priority_2 *Code `json:"priority,omitempty"`

	// Describes why the request is being made in coded or textual form.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The entity (e.g. person, organization, clinical information system, device,
	// group, or care team) which is the intended target of the communication.
	Recipient []Reference `json:"recipient,omitempty"`

	// Completed or terminated request(s) whose function is taken by this new request.
	Replaces []Reference `json:"replaces,omitempty"`

	// The device, individual, or organization who asks for the information to be
	// shared.
	Requester *Reference `json:"requester,omitempty"`

	// This is a CommunicationRequest resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the proposal or order.
	Status_2 *Code `json:"status,omitempty"`

	// Captures the reason for the current state of the CommunicationRequest.
	StatusReason *CodeableConcept `json:"statusReason,omitempty"`

	// The patient or group that is the focus of this communication request.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type CommunicationRequestContainedElem interface{}

// A request to convey information from a sender to a recipient.
type CommunicationRequestPayload struct {
	// The content (or for multi-part communications, one portion of the
	// communication) to be communicated.
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`

	// The content (or for multi-part communications, one portion of the
	// communication) to be communicated.
	ContentCodeableConcept *CodeableConcept `json:"contentCodeableConcept,omitempty"`

	// The content (or for multi-part communications, one portion of the
	// communication) to be communicated.
	ContentReference *Reference `json:"contentReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommunicationRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CommunicationRequest: required")
	}
	type Plain CommunicationRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = CommunicationRequest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Communication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Communication: required")
	}
	type Plain Communication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Communication(plain)
	return nil
}

// A compartment definition that defines how resources are accessed on a server.
type CompartmentDefinition struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for search
	Search *Element `json:"_search,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Which compartment this definition describes.
	Code_2 *Code `json:"code,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CompartmentDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the {{title}} and/or its contents. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the {{title}}.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the compartment definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the compartment definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the compartment definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this compartment definition is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this {{title}} when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the compartment definition. This name
	// should be usable as an identifier for the module by machine processing
	// applications such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the compartment definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this compartment definition is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Information about how a resource is related to the compartment.
	Resource []CompartmentDefinitionResource `json:"resource,omitempty"`

	// This is a CompartmentDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// Whether the search syntax is supported,.
	Search_2 *Boolean `json:"search,omitempty"`

	// The status of this compartment definition. Enables tracking the life-cycle of
	// the content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the capability statement.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this compartment definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this compartment definition is
	// (or will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the compartment definition is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate compartment
	// definition instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the compartment
	// definition when it is referenced in a specification, model, design or instance.
	// This is an arbitrary value managed by the compartment definition author and is
	// not expected to be globally unique. For example, it might be a timestamp (e.g.
	// yyyymmdd) if a managed version is not available. There is also no expectation
	// that versions can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type CompartmentDefinitionContainedElem interface{}

// A compartment definition that defines how resources are accessed on a server.
type CompartmentDefinitionResource struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for endParam
	EndParam *Element `json:"_endParam,omitempty"`

	// Extensions for param
	Param []Element `json:"_param,omitempty"`

	// Extensions for startParam
	StartParam *Element `json:"_startParam,omitempty"`

	// The name of a resource supported by the server.
	Code_2 *Code `json:"code,omitempty"`

	// Search Parameter for mapping requests made with $everything.end (e.g. on
	// [Patient.$everything](https://build.fhir.org/ig/HL7/admin-incubator/branches/main/en/OperationDefinition-Patient-everything.html)).
	EndParam_2 *Uri `json:"endParam,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The search parameter 'code' as defined in the core specification that
	// represents the link to the compartment.
	Param_2 []String `json:"param,omitempty"`

	// Search Parameter for mapping requests made with $everything.start (e.g. on
	// [Patient.$everything](https://build.fhir.org/ig/HL7/admin-incubator/branches/main/en/OperationDefinition-Patient-everything.html)).
	StartParam_2 *Uri `json:"startParam,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompartmentDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CompartmentDefinition: required")
	}
	type Plain CompartmentDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = CompartmentDefinition(plain)
	return nil
}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type Composition struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// A participant who has attested to the accuracy of the composition/document.
	Attester []CompositionAttester `json:"attester,omitempty"`

	// Identifies who is responsible for the information in the composition, not
	// necessarily who typed it in.
	Author []Reference `json:"author,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this
	// composition.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// A categorization for the type of the composition - helps for indexing and
	// searching. This may be implied by or derived from the code specified in the
	// Composition Type.
	Category []CodeableConcept `json:"category,omitempty"`

	// References the consents associated with this document. Examples include a
	// consent to perform the clinical service being documented (.event) or a consent
	// for the information contained in the document to be released to a third party.
	Consent []Reference `json:"consent,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CompositionContainedElem `json:"contained,omitempty"`

	// Identifies the organization or group who is responsible for ongoing maintenance
	// of and access to the composition/document information.
	Custodian *Reference `json:"custodian,omitempty"`

	// The composition editing time, when the composition was last logically changed
	// by the author.
	Date_2 *DateTime `json:"date,omitempty"`

	// Describes the clinical encounter or type of care this documentation is
	// associated with.
	Encounter *Reference `json:"encounter,omitempty"`

	// The clinical service, such as a colonoscopy or an appendectomy, being
	// documented.
	Event []CompositionEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A version-independent identifier for the Composition. This identifier stays
	// constant as the composition is changed over time.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the {{title}}. This name should be usable
	// as an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// For any additional notes.
	Note []Annotation `json:"note,omitempty"`

	// Identifies supporting entities, including parents, relatives, caregivers,
	// insurance policyholders, guarantors, and others related in some way to the
	// patient. A supporting person or organization is an individual or an
	// organization with a relationship to the patient. A supporting person who is
	// playing multiple roles would be recorded in multiple participants (e.g.,
	// emergency contact and next-of-kin).
	Participant []CompositionParticipant `json:"participant,omitempty"`

	// Relationships that this composition has with other compositions or documents
	// (FHIR or non-FHIR resources) that already exist.
	RelatesTo []CompositionRelatesTo `json:"relatesTo,omitempty"`

	// This is a Composition resource
	ResourceType interface{} `json:"resourceType"`

	// The root of the sections that make up the composition.
	Section []CompositionSection `json:"section,omitempty"`

	// The workflow/clinical status of this composition. The status is a marker for
	// the clinical standing of the document.
	Status_2 *Code `json:"status,omitempty"`

	// Who or what the composition is about. The composition can be about a person,
	// (patient or healthcare practitioner), a device (e.g. a machine) or even a group
	// of subjects (such as a document about a herd of livestock, or a set of patients
	// that share a common exposure).
	Subject []Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Official human-readable label for the composition.
	Title_2 *String `json:"title,omitempty"`

	// Specifies the particular kind of composition (e.g. History and Physical,
	// Discharge Summary, Progress Note). This usually equates to the purpose of
	// making the composition.
	Type CodeableConcept `json:"type"`

	// An absolute URI that is used to identify this Composition when it is referenced
	// in a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this Composition is (or will be) published.
	// This URL can be the target of a canonical reference. It SHALL remain the same
	// when the Composition is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate Composition
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// An explicitly assigned identifier of a variation of the content in the
	// Composition.
	Version_2 *String `json:"version,omitempty"`
}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type CompositionAttester struct {
	// Extensions for time
	Time *Element `json:"_time,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The type of attestation the authenticator offers.
	Mode CodeableConcept `json:"mode"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Who attested the composition in the specified way.
	Party *Reference `json:"party,omitempty"`

	// When the composition was attested by the party.
	Time_2 *DateTime `json:"time,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompositionAttester) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["mode"]; raw != nil && !ok {
		return fmt.Errorf("field mode in CompositionAttester: required")
	}
	type Plain CompositionAttester
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompositionAttester(plain)
	return nil
}

type CompositionContainedElem interface{}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type CompositionEvent struct {
	// Represents the main clinical acts, such as a colonoscopy or an appendectomy,
	// being documented. In some cases, the event is inherent in the typeCode, such as
	// a "History and Physical Report" in which case the procedure being documented is
	// necessarily a "History and Physical" act. The events may be included as a code
	// or as a reference to an other resource.
	Detail []CodeableReference `json:"detail,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period of time covered by the documentation. There is no assertion that the
	// documentation is a complete representation for this period, only that it
	// documents events during this time.
	Period *Period `json:"period,omitempty"`
}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type CompositionParticipant struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Exact function of the participant in the creation of the clinical document.
	// This is more granular than type.
	Function []CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Who the participant is.
	Party Reference `json:"party"`

	// Time period of participation.
	Time *Period `json:"time,omitempty"`

	// Meaning and purpose of participation, in creation of the clinical document. The
	// list includes: data entry person, informant, primary information recipient, and
	// tracker. Other types are allowed.
	Type []CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompositionParticipant) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["party"]; raw != nil && !ok {
		return fmt.Errorf("field party in CompositionParticipant: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CompositionParticipant: required")
	}
	type Plain CompositionParticipant
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompositionParticipant(plain)
	return nil
}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type CompositionRelatesTo struct {
	// Extensions for targetCanonical
	TargetCanonical *Element `json:"_targetCanonical,omitempty"`

	// Extensions for targetMarkdown
	TargetMarkdown *Element `json:"_targetMarkdown,omitempty"`

	// Extensions for targetUri
	TargetUri *Element `json:"_targetUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The artifact that is related to this Composition Resource.
	TargetAttachment *Attachment `json:"targetAttachment,omitempty"`

	// The artifact that is related to this Composition Resource.
	TargetCanonical_2 *string `json:"targetCanonical,omitempty"`

	// The artifact that is related to this Composition Resource.
	TargetMarkdown_2 *string `json:"targetMarkdown,omitempty"`

	// The artifact that is related to this Composition Resource.
	TargetReference *Reference `json:"targetReference,omitempty"`

	// The artifact that is related to this Composition Resource.
	TargetUri_2 *string `json:"targetUri,omitempty"`

	// The type of relationship to the related artifact.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompositionRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CompositionRelatesTo: required")
	}
	type Plain CompositionRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.TargetUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetUri_2", `^\S*$`)
		}
	}
	*j = CompositionRelatesTo(plain)
	return nil
}

// A set of healthcare-related information that is assembled together into a single
// logical package that provides a single coherent statement of meaning,
// establishes its own context and has traceability to the author who is making the
// statement. A Composition defines the structure and narrative content necessary
// for a document. However, a Composition alone does not constitute a document.
// Rather, the Composition must be the first entry in a Bundle where
// Bundle.type=document, and any other resources referenced from Composition must
// be included as subsequent entries in the Bundle (for example Patient,
// Practitioner, Encounter, etc.).
type CompositionSection struct {
	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Identifies who is responsible for the information in this section, not
	// necessarily who typed it in.
	//
	// The actual author of the section when it is not the author of the composition.
	// If author is not specified, the author is assumed to be the author of the
	// parent section or the author of the composition.
	Author []Reference `json:"author,omitempty"`

	// A code identifying the kind of content contained within the section. This must
	// be consistent with the section title.
	Code *CodeableConcept `json:"code,omitempty"`

	// If the section is empty, why the list is empty. An empty section typically has
	// some text explaining the empty reason.
	EmptyReason *CodeableConcept `json:"emptyReason,omitempty"`

	// A reference to the actual resource from which the narrative in the section is
	// derived.
	Entry []Reference `json:"entry,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual focus of the section when it is not the subject of the composition,
	// but instead represents something or someone associated with the subject such as
	// (for a patient subject) a spouse, parent, fetus, or donor. If not focus is
	// specified, the focus is assumed to be focus of the parent section, or, for a
	// section in the Composition itself, the subject of the composition. Sections
	// with a focus SHALL only include resources where the logical subject (patient,
	// subject, focus, etc.) matches the section focus, or the resources have no
	// logical subject (few resources).
	Focus *Reference `json:"focus,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Information about the section contents that is not represented by any of the
	// section entries.
	Note []Annotation `json:"note,omitempty"`

	// Specifies the order applied to the items in the section entries.
	OrderedBy *CodeableConcept `json:"orderedBy,omitempty"`

	// A nested sub-section within this section.
	Section []CompositionSection `json:"section,omitempty"`

	// A human-readable narrative that contains the attested content of the section,
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	Text *Narrative `json:"text,omitempty"`

	// The label for this particular section.  This will be part of the rendered
	// content for the document, and is often used to build a table of contents.
	Title_2 *String `json:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Composition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Composition: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Composition: required")
	}
	type Plain Composition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Composition(plain)
	return nil
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMap struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for sourceScopeCanonical
	SourceScopeCanonical *Element `json:"_sourceScopeCanonical,omitempty"`

	// Extensions for sourceScopeUri
	SourceScopeUri *Element `json:"_sourceScopeUri,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for targetScopeCanonical
	TargetScopeCanonical *Element `json:"_targetScopeCanonical,omitempty"`

	// Extensions for targetScopeUri
	TargetScopeUri *Element `json:"_targetScopeUri,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// An additionalAttribute defines an additional data element found in the source
	// or target data model where the data will come from or be mapped to. Some
	// mappings are based on data in addition to the source data element, where codes
	// in multiple fields are combined to a single field (or vice versa).
	AdditionalAttribute []ConceptMapAdditionalAttribute `json:"additionalAttribute,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the ConceptMap.
	Author []ContactDetail `json:"author,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ConceptMapContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the concept map and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the concept map.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the concept map was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the concept map changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the concept map from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the ConceptMap.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the ConceptMap content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the ConceptMap for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this concept map is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A group of mappings that all have the same source and target system.
	Group []ConceptMapGroup `json:"group,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this concept map when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the concept map. This name should be usable
	// as an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// A property defines a slot through which additional information can be provided
	// about a map from source -> target.
	Property []ConceptMapProperty `json:"property,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the concept map.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this concept map is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts. If the type is `successor` or `predecessor`, the related resource
	// must be a ConceptMap.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a ConceptMap resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the ConceptMap.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// Identifier for the source value set that contains the concepts that are being
	// mapped and provides context for the mappings.  Limits the scope of the map to
	// source codes (ConceptMap.group.element code or valueSet) that are members of
	// this value set.
	SourceScopeCanonical_2 *string `json:"sourceScopeCanonical,omitempty"`

	// Identifier for the source value set that contains the concepts that are being
	// mapped and provides context for the mappings.  Limits the scope of the map to
	// source codes (ConceptMap.group.element code or valueSet) that are members of
	// this value set.
	SourceScopeUri_2 *string `json:"sourceScopeUri,omitempty"`

	// The status of this concept map. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// Identifier for the target value set that provides important context about how
	// the mapping choices are made.  Limits the scope of the map to target codes
	// (ConceptMap.group.element.target code or valueSet) that are members of this
	// value set.
	TargetScopeCanonical_2 *string `json:"targetScopeCanonical,omitempty"`

	// Identifier for the target value set that provides important context about how
	// the mapping choices are made.  Limits the scope of the map to target codes
	// (ConceptMap.group.element.target code or valueSet) that are members of this
	// value set.
	TargetScopeUri_2 *string `json:"targetScopeUri,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the concept map.
	Title_2 *String `json:"title,omitempty"`

	// Descriptions related to the content of the ConceptMap. Topics provide a
	// high-level categorization as well as keywords for the ConceptMap that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this concept map when it is referenced
	// in a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this concept map is (or will be) published.
	// This URL can be the target of a canonical reference. It SHALL remain the same
	// when the concept map is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate concept map
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the concept map when it
	// is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the concept map author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which ConceptMap
	// is more current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which ConceptMap
	// is more current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapAdditionalAttribute struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// A code that is used to identify this additional data attribute. The code is
	// used internally in ConceptMap.group.element.target.dependsOn.attribute and
	// ConceptMap.group.element.target.product.attribute.
	Code_2 *Code `json:"code,omitempty"`

	// A description of the additional attribute and/or the data element it refers to
	// - why it is defined, and how the value might be used in mappings, and a
	// discussion of issues associated with the use of the data element.
	Description_2 *String `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of the source data contained in this concept map for this data
	// element.
	Type_2 *Code `json:"type,omitempty"`

	// Reference to the formal definition of the source/target data element. For
	// elements defined by the FHIR specification, or using a FHIR logical model, the
	// correct format is {canonical-url}#{element-id}.
	Uri_2 *Uri `json:"uri,omitempty"`
}

type ConceptMapContainedElem interface{}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapDependsOn struct {
	// Extensions for attribute
	Attribute *Element `json:"_attribute,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A reference to the additional attribute that holds a value the map depends on.
	Attribute_2 *Code `json:"attribute,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Data element value that the map depends on / produces. If the data type is a
	// code, that code SHALL come from the .group.source code system for
	// .dependsOn.valueCode or from the .group.target code system for
	// .product.valueCode.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Data element value that the map depends on / produces. If the data type is a
	// code, that code SHALL come from the .group.source code system for
	// .dependsOn.valueCode or from the .group.target code system for
	// .product.valueCode.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Data element value that the map depends on / produces. If the data type is a
	// code, that code SHALL come from the .group.source code system for
	// .dependsOn.valueCode or from the .group.target code system for
	// .product.valueCode.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Data element value that the map depends on / produces. If the data type is a
	// code, that code SHALL come from the .group.source code system for
	// .dependsOn.valueCode or from the .group.target code system for
	// .product.valueCode.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// This mapping applies if the data element value is a code from this value set.
	ValueSet *Canonical `json:"valueSet,omitempty"`

	// Data element value that the map depends on / produces. If the data type is a
	// code, that code SHALL come from the .group.source code system for
	// .dependsOn.valueCode or from the .group.target code system for
	// .product.valueCode.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConceptMapDependsOn) UnmarshalJSON(value []byte) error {
	type Plain ConceptMapDependsOn
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ConceptMapDependsOn(plain)
	return nil
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapElement struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for noMap
	NoMap *Element `json:"_noMap,omitempty"`

	// Identity (code or path) or the element/item being mapped.
	Code_2 *Code `json:"code,omitempty"`

	// Comments related to the mapping of the source element, potentially including
	// why there is no target.
	Comment_2 *String `json:"comment,omitempty"`

	// The display for the code. The display is only provided to help editors when
	// editing the concept map.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// If noMap = true this indicates that no mapping to a target concept exists for
	// this source concept.
	NoMap_2 *Boolean `json:"noMap,omitempty"`

	// A concept from the target value set that this concept maps to.
	Target []ConceptMapTarget `json:"target,omitempty"`

	// The set of concepts from the ConceptMap.group.source code system which are all
	// being mapped to the target as part of this mapping rule.
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapGroup struct {
	// Mappings for an individual concept in the source to one or more concepts in the
	// target.
	Element []ConceptMapElement `json:"element"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An absolute URI that identifies the source system where the concepts to be
	// mapped are defined.
	Source *Canonical `json:"source,omitempty"`

	// An absolute URI that identifies the target system that the concepts will be
	// mapped to.
	Target *Canonical `json:"target,omitempty"`

	// What to do when there is no mapping to a target concept from the source concept
	// and ConceptMap.group.element.noMap is not true. This provides the "default" to
	// be applied when there is no target concept mapping specified or the expansion
	// of ConceptMap.group.element.target.valueSet is empty.
	Unmapped *ConceptMapUnmapped `json:"unmapped,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConceptMapGroup) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["element"]; raw != nil && !ok {
		return fmt.Errorf("field element in ConceptMapGroup: required")
	}
	type Plain ConceptMapGroup
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConceptMapGroup(plain)
	return nil
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapProperty struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// A code that is used to identify the property. The code is used internally (in
	// ConceptMap.group.element.target.property.code) and also in the $translate
	// operation.
	Code_2 *Code `json:"code,omitempty"`

	// A description of the property - why it is defined, and how its value might be
	// used.
	Description_2 *String `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The CodeSystem that defines the codes from which values of type ```code``` in
	// property values.
	System *Canonical `json:"system,omitempty"`

	// The type of the property value.
	Type_2 *Code `json:"type,omitempty"`

	// Reference to the formal meaning of the property.
	Uri_2 *Uri `json:"uri,omitempty"`
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapProperty1 struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A reference to a mapping property defined in ConceptMap.property.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of this property. If the type chosen for this element is 'code', then
	// the property SHALL be defined in a ConceptMap.property element and that
	// ConceptMap.property element SHALL have a system element.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConceptMapProperty1) UnmarshalJSON(value []byte) error {
	type Plain ConceptMapProperty1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ConceptMapProperty1(plain)
	return nil
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapTarget struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for relationship
	Relationship *Element `json:"_relationship,omitempty"`

	// Identity (code or path) or the element/item that the map refers to.
	Code_2 *Code `json:"code,omitempty"`

	// Comments related to the mapping to the target element.
	Comment_2 *String `json:"comment,omitempty"`

	// A set of additional dependencies for this mapping to hold. This mapping is only
	// applicable if the specified data attribute can be resolved, and it has the
	// specified value.
	DependsOn []ConceptMapDependsOn `json:"dependsOn,omitempty"`

	// The display for the code. The display is only provided to help editors when
	// editing the concept map.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Product is the output of a ConceptMap that provides additional values that go
	// in other attributes / data elemnts of the target data.
	Product []ConceptMapDependsOn `json:"product,omitempty"`

	// A property value for this source -> target mapping.
	Property []ConceptMapProperty1 `json:"property,omitempty"`

	// The relationship between the source and target concepts. The relationship is
	// read from source to target (e.g. source-is-narrower-than-target).
	Relationship_2 *Code `json:"relationship,omitempty"`

	// The set of concepts from the ConceptMap.group.target code system which are all
	// being mapped to as part of this mapping rule. The effect of using this data
	// element is the same as having multiple ConceptMap.group.element.target elements
	// with one for each concept in the ConceptMap.group.element.target.valueSet value
	// set.
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

// A statement of relationships from one set of concepts to one or more other
// concepts - either concepts in code systems, or data element/data element
// concepts, or classes in class models.
type ConceptMapUnmapped struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Extensions for relationship
	Relationship *Element `json:"_relationship,omitempty"`

	// The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped
	// to a single fixed code.
	Code_2 *Code `json:"code,omitempty"`

	// Comments related to the choice of how to handle unmapped elements.
	Comment_2 *String `json:"comment,omitempty"`

	// The display for the code. The display is only provided to help editors when
	// editing the concept map.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Defines which action to take if there is no match for the source concept in the
	// target system designated for the group. One of 3 actions are possible: use the
	// unmapped source code (this is useful when doing a mapping between versions, and
	// only a few codes have changed), use a fixed code (a default code), or
	// alternatively, a reference to a different concept map can be provided (by
	// canonical URL).
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical reference to an additional ConceptMap resource instance to use
	// for mapping if this ConceptMap resource contains no matching mapping for the
	// source concept.
	OtherMap *Canonical `json:"otherMap,omitempty"`

	// The default relationship value to apply between the source and target concepts
	// when the source code is unmapped and the mode is 'fixed' or 'use-source-code'.
	Relationship_2 *Code `json:"relationship,omitempty"`

	// The set of fixed codes to use when the mode = 'fixed'  - all unmapped codes are
	// mapped to each of the fixed codes.
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConceptMap) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ConceptMap: required")
	}
	type Plain ConceptMap
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SourceScopeCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SourceScopeCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SourceScopeCanonical_2", `^\S*$`)
		}
	}
	if plain.SourceScopeUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SourceScopeUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SourceScopeUri_2", `^\S*$`)
		}
	}
	if plain.TargetScopeCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetScopeCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetScopeCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetScopeUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetScopeUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetScopeUri_2", `^\S*$`)
		}
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ConceptMap(plain)
	return nil
}

// A clinical condition, problem, diagnosis, or other event, situation, issue, or
// clinical concept that has risen to a level of concern.
type Condition struct {
	// Extensions for abatementDateTime
	AbatementDateTime *Element `json:"_abatementDateTime,omitempty"`

	// Extensions for abatementString
	AbatementString *Element `json:"_abatementString,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for onsetDateTime
	OnsetDateTime *Element `json:"_onsetDateTime,omitempty"`

	// Extensions for onsetString
	OnsetString *Element `json:"_onsetString,omitempty"`

	// Extensions for recordedDate
	RecordedDate *Element `json:"_recordedDate,omitempty"`

	// The date or estimated date that the condition resolved or went into remission.
	// This is called "abatement" because of the many overloaded connotations
	// associated with "remission" or "resolution" - Some conditions, such as chronic
	// conditions, are never really resolved, but they can abate.
	AbatementAge *Age `json:"abatementAge,omitempty"`

	// The date or estimated date that the condition resolved or went into remission.
	// This is called "abatement" because of the many overloaded connotations
	// associated with "remission" or "resolution" - Some conditions, such as chronic
	// conditions, are never really resolved, but they can abate.
	AbatementDateTime_2 *string `json:"abatementDateTime,omitempty"`

	// The date or estimated date that the condition resolved or went into remission.
	// This is called "abatement" because of the many overloaded connotations
	// associated with "remission" or "resolution" - Some conditions, such as chronic
	// conditions, are never really resolved, but they can abate.
	AbatementPeriod *Period `json:"abatementPeriod,omitempty"`

	// The date or estimated date that the condition resolved or went into remission.
	// This is called "abatement" because of the many overloaded connotations
	// associated with "remission" or "resolution" - Some conditions, such as chronic
	// conditions, are never really resolved, but they can abate.
	AbatementRange *Range `json:"abatementRange,omitempty"`

	// The date or estimated date that the condition resolved or went into remission.
	// This is called "abatement" because of the many overloaded connotations
	// associated with "remission" or "resolution" - Some conditions, such as chronic
	// conditions, are never really resolved, but they can abate.
	AbatementString_2 *string `json:"abatementString,omitempty"`

	// Individual or device that is making the condition statement.
	Asserter *Reference `json:"asserter,omitempty"`

	// The anatomical location where this condition manifests itself.
	BodySite []CodeableConcept `json:"bodySite,omitempty"`

	// Indicates the body structure on the subject's body where this condition
	// manifests itself.
	BodyStructure *Reference `json:"bodyStructure,omitempty"`

	// A category assigned to the condition.
	Category []CodeableConcept `json:"category,omitempty"`

	// The clinical status of the condition.
	ClinicalStatus CodeableConcept `json:"clinicalStatus"`

	// Identification of the condition, problem or diagnosis.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ConditionContainedElem `json:"contained,omitempty"`

	// The Encounter during which this Condition was created or to which the creation
	// of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// Supporting evidence / manifestations that are the basis for determining the
	// Condition.
	Evidence []CodeableReference `json:"evidence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this condition by the performer or other
	// systems which remain constant as the resource is updated and propagates from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional information about the Condition. This is a general notes/comments
	// entry  for description of the Condition, its diagnosis and prognosis.
	Note []Annotation `json:"note,omitempty"`

	// Estimated or actual date or date-time the condition, situation, or concern
	// began, in the opinion of the clinician.
	OnsetAge *Age `json:"onsetAge,omitempty"`

	// Estimated or actual date or date-time the condition, situation, or concern
	// began, in the opinion of the clinician.
	OnsetDateTime_2 *string `json:"onsetDateTime,omitempty"`

	// Estimated or actual date or date-time the condition, situation, or concern
	// began, in the opinion of the clinician.
	OnsetPeriod *Period `json:"onsetPeriod,omitempty"`

	// Estimated or actual date or date-time the condition, situation, or concern
	// began, in the opinion of the clinician.
	OnsetRange *Range `json:"onsetRange,omitempty"`

	// Estimated or actual date or date-time the condition, situation, or concern
	// began, in the opinion of the clinician.
	OnsetString_2 *string `json:"onsetString,omitempty"`

	// The recordedDate represents when this particular Condition record was created
	// in the system, which is often a system-generated date.
	RecordedDate_2 *DateTime `json:"recordedDate,omitempty"`

	// Individual who recorded the record and takes responsibility for accurately
	// recording its content.
	Recorder *Reference `json:"recorder,omitempty"`

	// This is a Condition resource
	ResourceType interface{} `json:"resourceType"`

	// A subjective assessment of the severity of the condition as evaluated by the
	// clinician.
	Severity *CodeableConcept `json:"severity,omitempty"`

	// A simple summary of the stage such as "Stage 3" or "Early Onset". The
	// determination of the stage is disease-specific, such as cancer, retinopathy of
	// prematurity, kidney diseases, Alzheimer's, or Parkinson disease.
	Stage []ConditionStage `json:"stage,omitempty"`

	// Indicates the patient or group who the condition record is associated with.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The verification status to support the clinical status of the condition.  The
	// verification status pertains to the condition, itself, not to any specific
	// condition attribute.
	VerificationStatus *CodeableConcept `json:"verificationStatus,omitempty"`
}

type ConditionContainedElem interface{}

// A clinical condition, problem, diagnosis, or other event, situation, issue, or
// clinical concept that has risen to a level of concern.
type ConditionStage struct {
	// Reference to a formal record of the evidence on which the staging assessment is
	// based.
	Assessment []Reference `json:"assessment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A simple summary of the stage such as "Stage 3" or "Early Onset". The
	// determination of the stage is disease-specific, such as cancer, retinopathy of
	// prematurity, kidney diseases, Alzheimer's, or Parkinson disease.
	Summary *CodeableConcept `json:"summary,omitempty"`

	// The kind of staging, such as pathological or clinical staging.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Condition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["clinicalStatus"]; raw != nil && !ok {
		return fmt.Errorf("field clinicalStatus in Condition: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Condition: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in Condition: required")
	}
	type Plain Condition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AbatementDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.AbatementDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AbatementDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.AbatementString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AbatementString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AbatementString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.OnsetDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OnsetDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OnsetDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.OnsetString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.OnsetString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OnsetString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Condition(plain)
	return nil
}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type Consent struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for decision
	Decision *Element `json:"_decision,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A classification of the type of consents found in the statement. This element
	// supports indexing and retrieval of consent statements.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ConsentContainedElem `json:"contained,omitempty"`

	// The actor that controls/enforces the access according to the consent.
	Controller []Reference `json:"controller,omitempty"`

	// Date the consent instance was agreed to.
	Date_2 *Date `json:"date,omitempty"`

	// Action to take - permit or deny - as default.
	Decision_2 *Code `json:"decision,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The entity responsible for complying with the Consent Directive, including any
	// obligations or limitations on authorizations and enforcement of prohibitions.
	Grantee []Reference `json:"grantee,omitempty"`

	// The entity responsible for granting the rights listed in a Consent Directive.
	Grantor []Reference `json:"grantor,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique identifier for this copy of the Consent Statement.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The actor that manages the consent through its lifecycle.
	Manager []Reference `json:"manager,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Effective period for this Consent Resource and all provisions unless specified
	// in that provision.
	Period *Period `json:"period,omitempty"`

	// A Reference or URL used to uniquely identify the policy the organization will
	// enforce for this Consent. This Reference or URL should be specific to the
	// version of the policy and should be dereferencable to a computable policy of
	// some form.
	PolicyBasis *ConsentPolicyBasis `json:"policyBasis,omitempty"`

	// A Reference to the human readable policy explaining the basis for the Consent.
	PolicyText []Reference `json:"policyText,omitempty"`

	// An exception to the base policy of this consent. An exception can be an
	// addition or removal of access permissions.
	Provision []ConsentProvision `json:"provision,omitempty"`

	// A set of codes that indicate the regulatory basis (if any) that this consent
	// supports.
	RegulatoryBasis []CodeableConcept `json:"regulatoryBasis,omitempty"`

	// This is a Consent resource
	ResourceType interface{} `json:"resourceType"`

	// The source on which this consent statement is based. The source might be a
	// scanned original paper form.
	SourceAttachment []Attachment `json:"sourceAttachment,omitempty"`

	// A reference to a consent that links back to such a source, a reference to a
	// document repository (e.g. XDS) that stores the original consent document.
	SourceReference []Reference `json:"sourceReference,omitempty"`

	// Indicates the current state of this Consent resource.
	Status_2 *Code `json:"status,omitempty"`

	// The patient, healthcare practitioner, research subject, or a group of persons
	// to whom this consent applies.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Whether a treatment instruction (e.g. artificial respiration: yes or no) was
	// verified with the patient, his/her family or another authorized person.
	Verification []ConsentVerification `json:"verification,omitempty"`
}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type ConsentActor struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The resource that identifies the actor. To identify actors by type, use group
	// to identify a set of actors by some property they share (e.g. 'admitting
	// officers').
	Reference *Reference `json:"reference,omitempty"`

	// How the individual is involved in the resources content that is described in
	// the exception.
	Role *CodeableConcept `json:"role,omitempty"`
}

type ConsentContainedElem interface{}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type ConsentData struct {
	// Extensions for meaning
	Meaning *Element `json:"_meaning,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// How the resource reference is interpreted when testing consent restrictions.
	Meaning_2 *Code `json:"meaning,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to a specific resource that defines which resources are covered by
	// this consent.
	Reference Reference `json:"reference"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsentData) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in ConsentData: required")
	}
	type Plain ConsentData
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsentData(plain)
	return nil
}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type ConsentPolicyBasis struct {
	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A Reference that identifies the policy the organization will enforce for this
	// Consent.
	Reference *Reference `json:"reference,omitempty"`

	// A URI that links to a computable version of the policy the organization will
	// enforce for this Consent.
	Uri_2 *Uri `json:"uri,omitempty"`
}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type ConsentProvision struct {
	// Actions controlled by this provision.
	Action []CodeableConcept `json:"action,omitempty"`

	// Who or what is controlled by this provision. Use group to identify a set of
	// actors by some property they share (e.g. 'admitting officers').
	Actor []ConsentActor `json:"actor,omitempty"`

	// If this code is found in an instance, then the provision applies.
	Code []CodeableConcept `json:"code,omitempty"`

	// The resources controlled by this provision if specific resources are
	// referenced.
	Data []ConsentData `json:"data,omitempty"`

	// Clinical or Operational Relevant period of time that bounds the data controlled
	// by this provision.
	DataPeriod *Period `json:"dataPeriod,omitempty"`

	// The documentType(s) covered by this provision. The type can be a CDA document,
	// or some other type that indicates what sort of information the consent relates
	// to.
	DocumentType []Coding `json:"documentType,omitempty"`

	// A computable (FHIRPath or other) definition of what is controlled by this
	// consent.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Timeframe for this provision.
	Period *Period `json:"period,omitempty"`

	// Provisions which provide exceptions to the base provision or subprovisions.
	Provision []ConsentProvision `json:"provision,omitempty"`

	// The context of the activities a user is taking - why the user is accessing the
	// data - that are controlled by this provision.
	Purpose []Coding `json:"purpose,omitempty"`

	// The resourceType(s) covered by this provision. The type can be a FHIR resource
	// type or a profile on a type that indicates what information the consent relates
	// to.
	ResourceType []Coding `json:"resourceType,omitempty"`

	// A security label, comprised of 0..* security label fields (Privacy tags), which
	// define which resources are controlled by this exception.
	SecurityLabel []Coding `json:"securityLabel,omitempty"`
}

// A record of a healthcare consumerâ€™s  choices  or choices made on their behalf by
// a third party, which permits or denies identified recipient(s) or recipient
// role(s) to perform one or more actions within a given policy context, for
// specific purposes and periods of time.
type ConsentVerification struct {
	// Extensions for date
	Date []Element `json:"_date,omitempty"`

	// Extensions for verified
	Verified *Element `json:"_verified,omitempty"`

	// Date(s) verification was collected.
	Date_2 []DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Extensible list of verification type starting with verification and
	// re-validation.
	Type *CodeableConcept `json:"type,omitempty"`

	// Has the instruction been verified.
	Verified_2 *Boolean `json:"verified,omitempty"`

	// The person who conducted the verification/validation of the Grantor decision.
	VerifiedBy *Reference `json:"verifiedBy,omitempty"`

	// Who verified the instruction (Patient, Relative or other Authorized Person).
	VerifiedWith *Reference `json:"verifiedWith,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Consent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Consent: required")
	}
	type Plain Consent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Consent(plain)
	return nil
}

// Specifies contact information for a person or organization.
type ContactDetail struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The name of an individual to contact.
	Name_2 *String `json:"name,omitempty"`

	// The contact details for the individual (if a name was provided) or the
	// organization.
	Telecom []ContactPoint `json:"telecom,omitempty"`
}

// Details for all kinds of technology mediated contact points for a person or
// organization, including telephone, email, etc.
type ContactPoint struct {
	// Extensions for rank
	Rank *Element `json:"_rank,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Time period when the contact point was/is in use.
	Period *Period `json:"period,omitempty"`

	// Specifies a preferred order in which to use a set of contacts. ContactPoints
	// with lower rank values are more preferred than those with higher rank values.
	Rank_2 *PositiveInt `json:"rank,omitempty"`

	// Telecommunications form for contact point - what communications system is
	// required to make use of the contact.
	System_2 *ContactPointSystem_2 `json:"system,omitempty"`

	// Identifies the purpose for the contact point.
	Use_2 *ContactPointUse_2 `json:"use,omitempty"`

	// The actual contact point details, in a form that is meaningful to the
	// designated communication system (i.e. phone number or email address).
	Value_2 *String `json:"value,omitempty"`
}

type ContactPointSystem_2 string

const ContactPointSystem_2_Email ContactPointSystem_2 = "email"
const ContactPointSystem_2_Fax ContactPointSystem_2 = "fax"
const ContactPointSystem_2_Other ContactPointSystem_2 = "other"
const ContactPointSystem_2_Pager ContactPointSystem_2 = "pager"
const ContactPointSystem_2_Phone ContactPointSystem_2 = "phone"
const ContactPointSystem_2_Sms ContactPointSystem_2 = "sms"
const ContactPointSystem_2_Url ContactPointSystem_2 = "url"

var enumValues_ContactPointSystem_2 = []interface{}{
	"phone",
	"fax",
	"email",
	"pager",
	"url",
	"sms",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContactPointSystem_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContactPointSystem_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContactPointSystem_2, v)
	}
	*j = ContactPointSystem_2(v)
	return nil
}

type ContactPointUse_2 string

const ContactPointUse_2_Home ContactPointUse_2 = "home"
const ContactPointUse_2_Mobile ContactPointUse_2 = "mobile"
const ContactPointUse_2_Old ContactPointUse_2 = "old"
const ContactPointUse_2_Temp ContactPointUse_2 = "temp"
const ContactPointUse_2_Work ContactPointUse_2 = "work"

var enumValues_ContactPointUse_2 = []interface{}{
	"home",
	"work",
	"temp",
	"old",
	"mobile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContactPointUse_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContactPointUse_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContactPointUse_2, v)
	}
	*j = ContactPointUse_2(v)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type Contract struct {
	// Extensions for alias
	Alias []Element `json:"_alias,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for instantiatesUri
	InstantiatesUri *Element `json:"_instantiatesUri,omitempty"`

	// Extensions for issued
	Issued *Element `json:"_issued,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Alternative representation of the title for this Contract definition,
	// derivative, or instance in any legal state., e.g., a domain specific contract
	// number related to legislation.
	Alias_2 []String `json:"alias,omitempty"`

	// Relevant time or time-period when this Contract is applicable.
	Applies *Period `json:"applies,omitempty"`

	// The individual or organization that authored the Contract definition,
	// derivative, or instance in any legal state.
	Author *Reference `json:"author,omitempty"`

	// A formally or informally recognized grouping of people, principals,
	// organizations, or jurisdictions formed for the purpose of achieving some form
	// of collective action such as the promulgation, administration and enforcement
	// of contracts and policies.
	Authority []Reference `json:"authority,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ContractContainedElem `json:"contained,omitempty"`

	// Precusory content developed with a focus and intent of supporting the formation
	// a Contract instance, which may be associated with and transformable into a
	// Contract.
	ContentDefinition *ContractContentDefinition `json:"contentDefinition,omitempty"`

	// The minimal content derived from the basal information source at a specific
	// stage in its lifecycle.
	ContentDerivative *CodeableConcept `json:"contentDerivative,omitempty"`

	// Recognized governance framework or system operating with a circumscribed scope
	// in accordance with specified principles, policies, processes or procedures for
	// managing rights, actions, or behaviors of parties or principals relative to
	// resources.
	Domain []Reference `json:"domain,omitempty"`

	// Event resulting in discontinuation or termination of this Contract instance by
	// one or more parties to the contract.
	ExpirationType *CodeableConcept `json:"expirationType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The "patient friendly language" versionof the Contract in whole or in parts.
	// "Patient friendly language" means the representation of the Contract and
	// Contract Provisions in a manner that is readily accessible and understandable
	// by a layperson in accordance with best practices for communication styles that
	// ensure that those agreeing to or signing the Contract understand the roles,
	// actions, obligations, responsibilities, and implication of the agreement.
	Friendly []ContractFriendly `json:"friendly,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique identifier for this Contract or a derivative that references a Source
	// Contract.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The URL pointing to a FHIR-defined Contract Definition that is adhered to in
	// whole or part by this Contract.
	InstantiatesCanonical *Reference `json:"instantiatesCanonical,omitempty"`

	// The URL pointing to an externally maintained definition that is adhered to in
	// whole or in part by this Contract.
	InstantiatesUri_2 *Uri `json:"instantiatesUri,omitempty"`

	// When this  Contract was issued.
	Issued_2 *DateTime `json:"issued,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// List of Legal expressions or representations of this Contract.
	Legal []ContractLegal `json:"legal,omitempty"`

	// Legal states of the formation of a legal instrument, which is a formally
	// executed written document that can be formally attributed to its author,
	// records and formally expresses a legally enforceable act, process, or
	// contractual duty, obligation, or right, and therefore evidences that act,
	// process, or agreement.
	LegalState *CodeableConcept `json:"legalState,omitempty"`

	// Legally binding Contract: This is the signed and legally recognized
	// representation of the Contract, which is considered the "source of truth" and
	// which would be the basis for legal action related to enforcement of this
	// Contract.
	LegallyBindingAttachment *Attachment `json:"legallyBindingAttachment,omitempty"`

	// Legally binding Contract: This is the signed and legally recognized
	// representation of the Contract, which is considered the "source of truth" and
	// which would be the basis for legal action related to enforcement of this
	// Contract.
	LegallyBindingReference *Reference `json:"legallyBindingReference,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying this Contract definition, derivative, or
	// instance in any legal state. Provides additional information about its content.
	// This name should be usable as an identifier for the module by machine
	// processing applications such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Links to Provenance records for past versions of this Contract definition,
	// derivative, or instance, which identify key state transitions or updates that
	// are likely to be relevant to a user looking at the current version of the
	// Contract.  The Provenance.entity indicates the target that was changed in the
	// update (see
	// [Provenance.entity](provenance-definitions.html#Provenance.entity)).
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`

	// This is a Contract resource
	ResourceType interface{} `json:"resourceType"`

	// List of Computable Policy Rule Language Representations of this Contract.
	Rule []ContractRule `json:"rule,omitempty"`

	// A selector of legal concerns for this Contract definition, derivative, or
	// instance in any legal state.
	Scope *CodeableConcept `json:"scope,omitempty"`

	// Parties with legal standing in the Contract, including the principal parties,
	// the grantor(s) and grantee(s), which are any person or organization bound by
	// the contract, and any ancillary parties, which facilitate the execution of the
	// contract such as a notary or witness.
	Signer []ContractSigner `json:"signer,omitempty"`

	// Sites in which the contract is complied with,  exercised, or in force.
	Site []Reference `json:"site,omitempty"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Sub-category for the Contract that distinguishes the kinds of systems that
	// would be interested in the Contract within the context of the Contract's scope.
	SubType []CodeableConcept `json:"subType,omitempty"`

	// The target entity impacted by or of interest to parties to the agreement.
	Subject []Reference `json:"subject,omitempty"`

	// A more detailed or qualifying explanatory or alternate user-friendly title for
	// this Contract definition, derivative, or instance in any legal state.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// Information that may be needed by/relevant to the performer in their execution
	// of this term action.
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`

	// One or more Contract Provisions, which may be related and conveyed as a group,
	// and may contain nested groups.
	Term []ContractTerm `json:"term,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for this Contract definition,
	// derivative, or instance in any legal state.
	Title_2 *String `json:"title,omitempty"`

	// Narrows the range of legal concerns to focus on the achievement of specific
	// contractual objectives.
	TopicCodeableConcept *CodeableConcept `json:"topicCodeableConcept,omitempty"`

	// Narrows the range of legal concerns to focus on the achievement of specific
	// contractual objectives.
	TopicReference *Reference `json:"topicReference,omitempty"`

	// A high-level category for the legal instrument, whether constructed as a
	// Contract definition, derivative, or instance in any legal state.  Provides
	// additional information about its content within the context of the Contract's
	// scope to distinguish the kinds of systems that would be interested in the
	// contract.
	Type *CodeableConcept `json:"type,omitempty"`

	// Canonical identifier for this contract, represented as a URI (globally unique).
	Url_2 *Uri `json:"url,omitempty"`

	// An edition identifier used for business purposes to label business significant
	// variants.
	Version_2 *String `json:"version,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractAction struct {
	// Extensions for contextLinkId
	ContextLinkID []Element `json:"_contextLinkId,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for linkId
	LinkID []Element `json:"_linkId,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for performerLinkId
	PerformerLinkID []Element `json:"_performerLinkId,omitempty"`

	// Extensions for reasonLinkId
	ReasonLinkID []Element `json:"_reasonLinkId,omitempty"`

	// Extensions for requesterLinkId
	RequesterLinkID []Element `json:"_requesterLinkId,omitempty"`

	// Extensions for securityLabelNumber
	SecurityLabelNumber []Element `json:"_securityLabelNumber,omitempty"`

	// Encounter or Episode with primary association to the specified term activity.
	Context *Reference `json:"context,omitempty"`

	// Id [identifier??] of the clause or question text related to the requester of
	// this action in the referenced form or QuestionnaireResponse.
	ContextLinkID_2 []String `json:"contextLinkId,omitempty"`

	// True if the term prohibits the  action.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Reason or purpose for the action stipulated by this Contract Provision.
	Intent CodeableConcept `json:"intent"`

	// Id [identifier??] of the clause or question text related to this action in the
	// referenced form or QuestionnaireResponse.
	LinkID_2 []String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the term action made by the requester, performer, subject
	// or other participants.
	Note []Annotation `json:"note,omitempty"`

	// When action happens.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// When action happens.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// When action happens.
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`

	// Indicates who or what is being asked to perform (or not perform) the ction.
	Performer *Reference `json:"performer,omitempty"`

	// Id [identifier??] of the clause or question text related to the reason type or
	// reference of this  action in the referenced form or QuestionnaireResponse.
	PerformerLinkID_2 []String `json:"performerLinkId,omitempty"`

	// The type of role or competency of an individual desired or required to perform
	// or not perform the action.
	PerformerRole *CodeableConcept `json:"performerRole,omitempty"`

	// The type of individual that is desired or required to perform or not perform
	// the action.
	PerformerType []CodeableConcept `json:"performerType,omitempty"`

	// Rationale for the action to be performed or not performed. Describes why the
	// action is permitted or prohibited. Either a coded concept, or another resource
	// whose existence justifies permitting or not permitting this action.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Id [identifier??] of the clause or question text related to the reason type or
	// reference of this  action in the referenced form or QuestionnaireResponse.
	ReasonLinkID_2 []String `json:"reasonLinkId,omitempty"`

	// Who or what initiated the action and has responsibility for its activation.
	Requester []Reference `json:"requester,omitempty"`

	// Id [identifier??] of the clause or question text related to the requester of
	// this action in the referenced form or QuestionnaireResponse.
	RequesterLinkID_2 []String `json:"requesterLinkId,omitempty"`

	// Security labels that protects the action.
	SecurityLabelNumber_2 []UnsignedInt `json:"securityLabelNumber,omitempty"`

	// Current state of the term action.
	Status CodeableConcept `json:"status"`

	// Entity of the action.
	Subject []ContractSubject `json:"subject,omitempty"`

	// Activity or service obligation to be done or not done, performed or not
	// performed, effectuated or not by this Contract term.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractAction) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["intent"]; raw != nil && !ok {
		return fmt.Errorf("field intent in ContractAction: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in ContractAction: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContractAction: required")
	}
	type Plain ContractAction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = ContractAction(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractAnswer struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Response to an offer clause or question text,  which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warranty duration, or whether biospecimen may be used
	// for further research.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractAnswer) UnmarshalJSON(value []byte) error {
	type Plain ContractAnswer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = ContractAnswer(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractAsset struct {
	// Extensions for condition
	Condition *Element `json:"_condition,omitempty"`

	// Extensions for linkId
	LinkID []Element `json:"_linkId,omitempty"`

	// Extensions for securityLabelNumber
	SecurityLabelNumber []Element `json:"_securityLabelNumber,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Response to assets.
	Answer []ContractAnswer `json:"answer,omitempty"`

	// Description of the quality and completeness of the asset that may be a factor
	// in its valuation.
	Condition_2 *String `json:"condition,omitempty"`

	// Circumstance of the asset.
	Context []ContractContext `json:"context,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Id [identifier??] of the clause or question text about the asset in the
	// referenced form or QuestionnaireResponse.
	LinkID_2 []String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Asset relevant contractual time period.
	Period []Period `json:"period,omitempty"`

	// Type of Asset availability for use or ownership.
	PeriodType []CodeableConcept `json:"periodType,omitempty"`

	// Specifies the applicability of the term to an asset resource instance, and
	// instances it refers to or instances that refer to it, and/or are owned by the
	// offeree.
	Relationship *Coding `json:"relationship,omitempty"`

	// Differentiates the kind of the asset .
	Scope *CodeableConcept `json:"scope,omitempty"`

	// Security labels that protects the asset.
	SecurityLabelNumber_2 []UnsignedInt `json:"securityLabelNumber,omitempty"`

	// May be a subtype or part of an offered asset.
	Subtype []CodeableConcept `json:"subtype,omitempty"`

	// Clause or question text (Prose Object) concerning the asset in a linked form,
	// such as a QuestionnaireResponse used in the formation of the contract.
	Text_2 *String `json:"text,omitempty"`

	// Target entity type about which the term may be concerned.
	Type []CodeableConcept `json:"type,omitempty"`

	// Associated entities.
	TypeReference []Reference `json:"typeReference,omitempty"`

	// Time period of asset use.
	UsePeriod []Period `json:"usePeriod,omitempty"`

	// Contract Valued Item List.
	ValuedItem []ContractValuedItem `json:"valuedItem,omitempty"`
}

type ContractContainedElem interface{}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractContentDefinition struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for publicationDate
	PublicationDate *Element `json:"_publicationDate,omitempty"`

	// Extensions for publicationStatus
	PublicationStatus *Element `json:"_publicationStatus,omitempty"`

	// A copyright statement relating to Contract precursor content. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the Contract precursor content.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The date (and optionally time) when the contract was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the contract changes.
	PublicationDate_2 *DateTime `json:"publicationDate,omitempty"`

	// amended | appended | cancelled | disputed | entered-in-error | executable +.
	PublicationStatus_2 *Code `json:"publicationStatus,omitempty"`

	// The  individual or organization that published the Contract precursor content.
	Publisher *Reference `json:"publisher,omitempty"`

	// Detailed Precusory content type.
	SubType *CodeableConcept `json:"subType,omitempty"`

	// Precusory content structure and use, i.e., a boilerplate, template, application
	// for a contract such as an insurance policy or benefits under a program, e.g.,
	// workers compensation.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractContentDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContractContentDefinition: required")
	}
	type Plain ContractContentDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractContentDefinition(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractContext struct {
	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Coded representation of the context generally or of the Referenced entity, such
	// as the asset holder type or location.
	Code []CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Asset context reference may include the creator, custodian, or owning Person or
	// Organization (e.g., bank, repository),  location held, e.g., building,
	// jurisdiction.
	Reference *Reference `json:"reference,omitempty"`

	// Context description.
	Text_2 *String `json:"text,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractFriendly struct {
	// Human readable rendering of this Contract in a format and representation
	// intended to enhance comprehension and ensure understandability.
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`

	// Human readable rendering of this Contract in a format and representation
	// intended to enhance comprehension and ensure understandability.
	ContentReference *Reference `json:"contentReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractLegal struct {
	// Contract legal text in human renderable form.
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`

	// Contract legal text in human renderable form.
	ContentReference *Reference `json:"contentReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractOffer struct {
	// Extensions for linkId
	LinkID []Element `json:"_linkId,omitempty"`

	// Extensions for securityLabelNumber
	SecurityLabelNumber []Element `json:"_securityLabelNumber,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Response to offer text.
	Answer []ContractAnswer `json:"answer,omitempty"`

	// Type of choice made by accepting party with respect to an offer made by an
	// offeror/ grantee.
	Decision *CodeableConcept `json:"decision,omitempty"`

	// How the decision about a Contract was conveyed.
	DecisionMode []CodeableConcept `json:"decisionMode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Unique identifier for this particular Contract Provision.
	Identifier []Identifier `json:"identifier,omitempty"`

	// The id of the clause or question text of the offer in the referenced
	// questionnaire/response.
	LinkID_2 []String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Offer Recipient.
	Party []ContractParty `json:"party,omitempty"`

	// Security labels that protects the offer.
	SecurityLabelNumber_2 []UnsignedInt `json:"securityLabelNumber,omitempty"`

	// Human readable form of this Contract Offer.
	Text_2 *String `json:"text,omitempty"`

	// The owner of an asset has the residual control rights over the asset: the right
	// to decide all usages of the asset in any way not inconsistent with a prior
	// contract, custom, or law (Hart, 1995, p. 30).
	Topic *Reference `json:"topic,omitempty"`

	// Type of Contract Provision such as specific requirements, purposes for actions,
	// obligations, prohibitions, e.g. life time maximum benefit.
	Type *CodeableConcept `json:"type,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractParty struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Participant in the offer.
	Reference []Reference `json:"reference"`

	// How the party participates in the offer.
	Role CodeableConcept `json:"role"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractParty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in ContractParty: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in ContractParty: required")
	}
	type Plain ContractParty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractParty(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractRule struct {
	// Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL,
	// SecPal).
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`

	// Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL,
	// SecPal).
	ContentReference *Reference `json:"contentReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractSecurityLabel struct {
	// Extensions for number
	Number []Element `json:"_number,omitempty"`

	// Security label privacy tag that specifies the applicable privacy and security
	// policies governing this term and/or term elements.
	Category []Coding `json:"category,omitempty"`

	// Security label privacy tag that specifies the level of confidentiality
	// protection required for this term and/or term elements.
	Classification Coding `json:"classification"`

	// Security label privacy tag that specifies the manner in which term and/or term
	// elements are to be protected.
	Control []Coding `json:"control,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Number used to link this term or term element to the applicable Security Label.
	Number_2 []UnsignedInt `json:"number,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractSecurityLabel) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["classification"]; raw != nil && !ok {
		return fmt.Errorf("field classification in ContractSecurityLabel: required")
	}
	type Plain ContractSecurityLabel
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractSecurityLabel(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractSigner struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Party which is a signator to this Contract.
	Party Reference `json:"party"`

	// Legally binding Contract DSIG signature contents in Base64.
	Signature []Signature `json:"signature"`

	// Role of this Contract signer, e.g. notary, grantee.
	Type Coding `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractSigner) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["party"]; raw != nil && !ok {
		return fmt.Errorf("field party in ContractSigner: required")
	}
	if _, ok := raw["signature"]; raw != nil && !ok {
		return fmt.Errorf("field signature in ContractSigner: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContractSigner: required")
	}
	type Plain ContractSigner
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractSigner(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractSubject struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The entity the action is performed or not performed on or for.
	Reference []Reference `json:"reference"`

	// Role type of agent assigned roles in this Contract.
	Role *CodeableConcept `json:"role,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractSubject) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in ContractSubject: required")
	}
	type Plain ContractSubject
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractSubject(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractTerm struct {
	// Extensions for issued
	Issued *Element `json:"_issued,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// An actor taking a role in an activity for which it can be assigned some degree
	// of responsibility for the activity taking place.
	Action []ContractAction `json:"action,omitempty"`

	// Relevant time or time-period when this Contract Provision is applicable.
	Applies *Period `json:"applies,omitempty"`

	// Contract Term Asset List.
	Asset []ContractAsset `json:"asset,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Nested group of Contract Provisions.
	Group []ContractTerm `json:"group,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Unique identifier for this particular Contract Provision.
	Identifier *Identifier `json:"identifier,omitempty"`

	// When this Contract Provision was issued.
	Issued_2 *DateTime `json:"issued,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The matter of concern in the context of this provision of the agrement.
	Offer ContractOffer `json:"offer"`

	// Security labels that protect the handling of information about the term and its
	// elements, which may be specifically identified.
	SecurityLabel []ContractSecurityLabel `json:"securityLabel,omitempty"`

	// A specialized legal clause or condition based on overarching contract type.
	SubType *CodeableConcept `json:"subType,omitempty"`

	// Statement of a provision in a policy or a contract.
	Text_2 *Markdown `json:"text,omitempty"`

	// The entity that the term applies to.
	TopicCodeableConcept *CodeableConcept `json:"topicCodeableConcept,omitempty"`

	// The entity that the term applies to.
	TopicReference *Reference `json:"topicReference,omitempty"`

	// A legal clause or condition contained within a contract that requires one or
	// both parties to perform a particular requirement by some specified time or
	// prevents one or both parties from performing a particular requirement by some
	// specified time.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractTerm) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["offer"]; raw != nil && !ok {
		return fmt.Errorf("field offer in ContractTerm: required")
	}
	type Plain ContractTerm
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ContractTerm(plain)
	return nil
}

// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a
// policy or agreement.
type ContractValuedItem struct {
	// Extensions for effectiveTime
	EffectiveTime *Element `json:"_effectiveTime,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for linkId
	LinkID []Element `json:"_linkId,omitempty"`

	// Extensions for payment
	Payment *Element `json:"_payment,omitempty"`

	// Extensions for paymentDate
	PaymentDate *Element `json:"_paymentDate,omitempty"`

	// Extensions for points
	Points *Element `json:"_points,omitempty"`

	// Extensions for securityLabelNumber
	SecurityLabelNumber []Element `json:"_securityLabelNumber,omitempty"`

	// Indicates the time during which this Contract ValuedItem information is
	// effective.
	EffectiveTime_2 *DateTime `json:"effectiveTime,omitempty"`

	// Specific type of Contract Valued Item that may be priced.
	EntityCodeableConcept *CodeableConcept `json:"entityCodeableConcept,omitempty"`

	// Specific type of Contract Valued Item that may be priced.
	EntityReference *Reference `json:"entityReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of the Contract Valued Item delivered. The concept of a Factor allows for
	// a discount or surcharge multiplier to be applied to a monetary amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifies a Contract Valued Item instance.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Id  of the clause or question text related to the context of this valuedItem in
	// the referenced form or QuestionnaireResponse.
	LinkID_2 []String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Expresses the product of the Contract Valued Item unitQuantity and the
	// unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per
	// Point) * factor Number  * points = net Amount. Quantity, factor and points are
	// assumed to be 1 if not supplied.
	Net *Money `json:"net,omitempty"`

	// Terms of valuation.
	Payment_2 *String `json:"payment,omitempty"`

	// When payment is due.
	PaymentDate_2 *DateTime `json:"paymentDate,omitempty"`

	// An amount that expresses the weighting (based on difficulty, cost and/or
	// resource intensiveness) associated with the Contract Valued Item delivered. The
	// concept of Points allows for assignment of point values for a Contract Valued
	// Item, such that a monetary amount can be assigned to each point.
	Points_2 *Decimal `json:"points,omitempty"`

	// Specifies the units by which the Contract Valued Item is measured or counted,
	// and quantifies the countable or measurable Contract Valued Item instances.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Who will receive payment.
	Recipient *Reference `json:"recipient,omitempty"`

	// Who will make payment.
	Responsible *Reference `json:"responsible,omitempty"`

	// A set of security labels that define which terms are controlled by this
	// condition.
	SecurityLabelNumber_2 []UnsignedInt `json:"securityLabelNumber,omitempty"`

	// A Contract Valued Item unit valuation measure.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Contract) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Contract: required")
	}
	type Plain Contract
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Contract(plain)
	return nil
}

// A measured amount (or an amount that can potentially be measured). Note that
// measured amounts include amounts that are not precisely quantified, including
// amounts involving arbitrary units and floating currencies.
type Count struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A computer processable form of the unit in some unit representation system.
	Code_2 *Code `json:"code,omitempty"`

	// How the value should be understood and represented - whether the actual value
	// is greater or less than the stated value due to measurement issues; e.g. if the
	// comparator is "<" , then the real value is < stated value.
	Comparator_2 *CountComparator_2 `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the system that provides the coded form of the unit.
	System_2 *Uri `json:"system,omitempty"`

	// A human-readable form of the unit.
	Unit_2 *String `json:"unit,omitempty"`

	// The value of the measured amount. The value includes an implicit precision in
	// the presentation of the value.
	Value_2 *Decimal `json:"value,omitempty"`
}

type CountComparator_2 string

const CountComparator_2_Ad CountComparator_2 = "ad"
const CountComparator_2_GE CountComparator_2 = ">="
const CountComparator_2_GT CountComparator_2 = ">"
const CountComparator_2_LT CountComparator_2 = "<"
const CountComparator_2_LE CountComparator_2 = "<="

var enumValues_CountComparator_2 = []interface{}{
	"<",
	"<=",
	">=",
	">",
	"ad",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CountComparator_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CountComparator_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CountComparator_2, v)
	}
	*j = CountComparator_2(v)
	return nil
}

// Financial instrument which may be used to reimburse or pay for health care
// products and services. Includes both insurance and self-payment.
type Coverage struct {
	// Extensions for dependent
	Dependent *Element `json:"_dependent,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for network
	Network *Element `json:"_network,omitempty"`

	// Extensions for order
	Order *Element `json:"_order,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// Extensions for subrogation
	Subrogation *Element `json:"_subrogation,omitempty"`

	// The party who benefits from the insurance coverage; the patient when products
	// and/or services are provided.
	Beneficiary Reference `json:"beneficiary"`

	// A suite of underwriter specific classifiers.
	Class []CoverageClass `json:"class,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CoverageContainedElem `json:"contained,omitempty"`

	// The policy(s) which constitute this insurance coverage.
	Contract []Reference `json:"contract,omitempty"`

	// A suite of codes indicating the cost category and associated amount which have
	// been detailed in the policy and may have been  included on the health card.
	CostToBeneficiary []CoverageCostToBeneficiary `json:"costToBeneficiary,omitempty"`

	// A designator for a dependent under the coverage.
	Dependent_2 *String `json:"dependent,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The identifier of the coverage as issued by the insurer.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The insurance plan details, benefits and costs, which constitute this insurance
	// coverage.
	InsurancePlan *Reference `json:"insurancePlan,omitempty"`

	// The program or plan underwriter, payor, insurance company.
	Insurer *Reference `json:"insurer,omitempty"`

	// The nature of the coverage be it insurance, or cash payment such as self-pay.
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The insurer-specific identifier for the insurer-defined network of providers to
	// which the beneficiary may seek treatment which will be covered at the
	// 'in-network' rate, otherwise 'out of network' terms and conditions apply.
	Network_2 *String `json:"network,omitempty"`

	// The order of applicability of this coverage relative to other coverages which
	// are currently in force. Note, there may be gaps in the numbering and this does
	// not imply primary, secondary etc. as the specific positioning of coverages
	// depends upon the episode of care. For example; a patient might have (0) auto
	// insurance (1) their own health insurance and (2) spouse's health insurance.
	// When claiming for treatments which were not the result of an auto accident then
	// only coverages (1) and (2) above would be applicable and would apply in the
	// order specified in parenthesis. Coverage.order conveys the Coordination of
	// Benefit (COB) ordering of coverage independent of use-case, for a use-case
	// dependent set of Coverages see Account.coverage.priority.
	Order_2 *PositiveInt `json:"order,omitempty"`

	// Link to the paying party and optionally what specifically they will be
	// responsible to pay.
	PaymentBy []CoveragePaymentBy `json:"paymentBy,omitempty"`

	// Time period during which the coverage is in force. A missing start date
	// indicates the start date isn't known, a missing end date means the coverage is
	// continuing to be in force. When non-contiguous periods of coverage need to be
	// documented it is recommended that this is accomplished through the use of an
	// extension,rather than complicating coverage period calculations for many users
	// of the Coverage resource.
	Period *Period `json:"period,omitempty"`

	// The party who 'owns' the insurance policy.
	PolicyHolder *Reference `json:"policyHolder,omitempty"`

	// The relationship of beneficiary (patient) to the subscriber.
	Relationship *CodeableConcept `json:"relationship,omitempty"`

	// This is a Coverage resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance. The status element does not indicate
	// whether the policy reflected in the instance is in-force at any particular
	// point in time, that would be conveyed via the 'period' element.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// When 'subrogation=true' this insurance instance has been included not for
	// adjudication but to provide insurers with the details to recover costs.
	Subrogation_2 *Boolean `json:"subrogation,omitempty"`

	// The party who has signed-up for or 'owns' the contractual relationship to the
	// policy or to whom the benefit of the policy for services rendered to them or
	// their family is due.
	Subscriber *Reference `json:"subscriber,omitempty"`

	// The insurer assigned ID for the Subscriber.
	SubscriberID []Identifier `json:"subscriberId,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The type of coverage: social program, medical plan, accident coverage (workers
	// compensation, auto), group health or payment by an individual or organization.
	Type *CodeableConcept `json:"type,omitempty"`
}

// Financial instrument which may be used to reimburse or pay for health care
// products and services. Includes both insurance and self-payment.
type CoverageClass struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A short description for the class.
	Name_2 *String `json:"name,omitempty"`

	// The type of classification for which an insurer-specific class label or number
	// and optional name is provided.  For example, type may be used to identify a
	// class of coverage or employer group, policy, or plan.
	Type CodeableConcept `json:"type"`

	// The alphanumeric identifier associated with the insurer issued label.
	Value Identifier `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageClass) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CoverageClass: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in CoverageClass: required")
	}
	type Plain CoverageClass
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageClass(plain)
	return nil
}

type CoverageContainedElem interface{}

// Financial instrument which may be used to reimburse or pay for health care
// products and services. Includes both insurance and self-payment.
type CoverageCostToBeneficiary struct {
	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// A suite of codes indicating exceptions or reductions to patient costs and their
	// effective periods.
	Exception []CoverageException `json:"exception,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Is a flag to indicate whether the benefits refer to in-network providers or
	// out-of-network providers.
	Network *CodeableConcept `json:"network,omitempty"`

	// The term or period of the values such as 'maximum lifetime benefit' or 'maximum
	// annual visits'.
	Term *CodeableConcept `json:"term,omitempty"`

	// The category of patient centric costs associated with treatment.
	Type *CodeableConcept `json:"type,omitempty"`

	// Indicates if the benefits apply to an individual or to the family.
	Unit *CodeableConcept `json:"unit,omitempty"`

	// The amount due from the patient for the cost category.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// The amount due from the patient for the cost category.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequest struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for purpose
	Purpose []Element `json:"_purpose,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CoverageEligibilityRequestContainedElem `json:"contained,omitempty"`

	// The date when this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// Person who created the request.
	Enterer *Reference `json:"enterer,omitempty"`

	// Information code for an event with a corresponding date or period.
	Event []CoverageEligibilityRequestEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Facility where the services are intended to be provided.
	Facility *Reference `json:"facility,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this coverage eligiblity request.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Financial instruments for reimbursement for the health care products and
	// services.
	Insurance []CoverageEligibilityRequestInsurance `json:"insurance,omitempty"`

	// The Insurer who issued the coverage in question and is the recipient of the
	// request.
	Insurer Reference `json:"insurer"`

	// Service categories or billable services for which benefit details and/or an
	// authorization prior to service delivery may be required by the payor.
	Item []CoverageEligibilityRequestItem `json:"item,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The party who is the beneficiary of the supplied coverage and for whom
	// eligibility is sought.
	Patient Reference `json:"patient"`

	// When the requestor expects the processor to complete processing.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// The provider which is responsible for the request.
	Provider *Reference `json:"provider,omitempty"`

	// Code to specify whether requesting: prior authorization requirements for some
	// service categories or billing codes; benefits for coverages specified or
	// discovered; discovery and return of coverages for the patient; and/or
	// validation that the specified coverage is in-force at the date/period specified
	// or 'now' if not specified.
	Purpose_2 []Code `json:"purpose,omitempty"`

	// This is a CoverageEligibilityRequest resource
	ResourceType interface{} `json:"resourceType"`

	// The date or dates when the enclosed suite of services were performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the enclosed suite of services were performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// Additional information codes regarding exceptions, special considerations, the
	// condition, situation, prior or concurrent issues.
	SupportingInfo []CoverageEligibilityRequestSupportingInfo `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type CoverageEligibilityRequestContainedElem interface{}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequestDiagnosis struct {
	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisCodeableConcept *CodeableConcept `json:"diagnosisCodeableConcept,omitempty"`

	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisReference *Reference `json:"diagnosisReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequestEvent struct {
	// Extensions for whenDateTime
	WhenDateTime *Element `json:"_whenDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A coded event such as when a service is expected or a card printed.
	Type CodeableConcept `json:"type"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenDateTime_2 *string `json:"whenDateTime,omitempty"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityRequestEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CoverageEligibilityRequestEvent: required")
	}
	type Plain CoverageEligibilityRequestEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.WhenDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.WhenDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WhenDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = CoverageEligibilityRequestEvent(plain)
	return nil
}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequestInsurance struct {
	// Extensions for businessArrangement
	BusinessArrangement *Element `json:"_businessArrangement,omitempty"`

	// Extensions for focal
	Focal *Element `json:"_focal,omitempty"`

	// A business agreement number established between the provider and the insurer
	// for special business processing purposes.
	BusinessArrangement_2 *String `json:"businessArrangement,omitempty"`

	// Reference to the insurance card level information contained in the Coverage
	// resource. The coverage issuing insurer will use these details to locate the
	// patient's actual coverage within the insurer's information system.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A flag to indicate that this Coverage is to be used for evaluation of this
	// request when set to true.
	Focal_2 *Boolean `json:"focal,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityRequestInsurance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in CoverageEligibilityRequestInsurance: required")
	}
	type Plain CoverageEligibilityRequestInsurance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageEligibilityRequestInsurance(plain)
	return nil
}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequestItem struct {
	// Extensions for supportingInfoSequence
	SupportingInfoSequence []Element `json:"_supportingInfoSequence,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// The plan/proposal/order describing the proposed service in detail.
	Detail []Reference `json:"detail,omitempty"`

	// Patient diagnosis for which care is sought.
	Diagnosis []CoverageEligibilityRequestDiagnosis `json:"diagnosis,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Facility where the services will be provided.
	Facility *Reference `json:"facility,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This contains the product, service, drug or other billing code for the item.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// The practitioner who is responsible for the product or service to be rendered
	// to the patient.
	Provider *Reference `json:"provider,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product line.
	SupportingInfoSequence_2 []PositiveInt `json:"supportingInfoSequence,omitempty"`

	// The amount charged to the patient by the provider for a single unit.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// The CoverageEligibilityRequest provides patient and insurance coverage
// information to an insurer for them to respond, in the form of an
// CoverageEligibilityResponse, with information regarding whether the stated
// coverage is valid and in-force and optionally to provide the insurance details
// of the policy.
type CoverageEligibilityRequestSupportingInfo struct {
	// Extensions for appliesToAll
	AppliesToAll *Element `json:"_appliesToAll,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The supporting materials are applicable for all detail items, product/servce
	// categories and specific billing codes.
	AppliesToAll_2 *Boolean `json:"appliesToAll,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	Information Reference `json:"information"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A number to uniquely identify supporting information entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityRequestSupportingInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["information"]; raw != nil && !ok {
		return fmt.Errorf("field information in CoverageEligibilityRequestSupportingInfo: required")
	}
	type Plain CoverageEligibilityRequestSupportingInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageEligibilityRequestSupportingInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["insurer"]; raw != nil && !ok {
		return fmt.Errorf("field insurer in CoverageEligibilityRequest: required")
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in CoverageEligibilityRequest: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CoverageEligibilityRequest: required")
	}
	type Plain CoverageEligibilityRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = CoverageEligibilityRequest(plain)
	return nil
}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponse struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outcome
	Outcome *Element `json:"_outcome,omitempty"`

	// Extensions for preAuthRef
	PreAuthRef *Element `json:"_preAuthRef,omitempty"`

	// Extensions for purpose
	Purpose []Element `json:"_purpose,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []CoverageEligibilityResponseContainedElem `json:"contained,omitempty"`

	// The date this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// A human readable description of the status of the adjudication.
	Disposition_2 *String `json:"disposition,omitempty"`

	// Errors encountered during the processing of the request.
	Error []CoverageEligibilityResponseError `json:"error,omitempty"`

	// Information code for an event with a corresponding date or period.
	Event []CoverageEligibilityResponseEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A code for the form to be used for printing the content.
	Form *CodeableConcept `json:"form,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this coverage eligiblity request.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Financial instruments for reimbursement for the health care products and
	// services.
	Insurance []CoverageEligibilityResponseInsurance `json:"insurance,omitempty"`

	// The Insurer who issued the coverage in question and is the author of the
	// response.
	Insurer Reference `json:"insurer"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The outcome of the request processing.
	Outcome_2 *Code `json:"outcome,omitempty"`

	// The party who is the beneficiary of the supplied coverage and for whom
	// eligibility is sought.
	Patient Reference `json:"patient"`

	// A reference from the Insurer to which these services pertain to be used on
	// further communication and as proof that the request occurred.
	PreAuthRef_2 *String `json:"preAuthRef,omitempty"`

	// Code to specify whether requesting: prior authorization requirements for some
	// service categories or billing codes; benefits for coverages specified or
	// discovered; discovery and return of coverages for the patient; and/or
	// validation that the specified coverage is in-force at the date/period specified
	// or 'now' if not specified.
	Purpose_2 []Code `json:"purpose,omitempty"`

	// Reference to the original request resource.
	Request *Reference `json:"request,omitempty"`

	// The provider which is responsible for the eligibility, claim, predetermination
	// or preauthorization request.
	Requestor *Reference `json:"requestor,omitempty"`

	// This is a CoverageEligibilityResponse resource
	ResourceType interface{} `json:"resourceType"`

	// The date or dates when the enclosed suite of services were performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the enclosed suite of services were performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponseBenefit struct {
	// Extensions for allowedString
	AllowedString *Element `json:"_allowedString,omitempty"`

	// Extensions for allowedUnsignedInt
	AllowedUnsignedInt *Element `json:"_allowedUnsignedInt,omitempty"`

	// Extensions for usedString
	UsedString *Element `json:"_usedString,omitempty"`

	// Extensions for usedUnsignedInt
	UsedUnsignedInt *Element `json:"_usedUnsignedInt,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedMoney *Money `json:"allowedMoney,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedString_2 *string `json:"allowedString,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedUnsignedInt_2 *float64 `json:"allowedUnsignedInt,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Classification of benefit being provided.
	Type CodeableConcept `json:"type"`

	// The quantity of the benefit which have been consumed to date.
	UsedMoney *Money `json:"usedMoney,omitempty"`

	// The quantity of the benefit which have been consumed to date.
	UsedString_2 *string `json:"usedString,omitempty"`

	// The quantity of the benefit which have been consumed to date.
	UsedUnsignedInt_2 *float64 `json:"usedUnsignedInt,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityResponseBenefit) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CoverageEligibilityResponseBenefit: required")
	}
	type Plain CoverageEligibilityResponseBenefit
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AllowedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AllowedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AllowedString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.UsedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.UsedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "UsedString_2", `^^[\s\S]+$$`)
		}
	}
	*j = CoverageEligibilityResponseBenefit(plain)
	return nil
}

type CoverageEligibilityResponseContainedElem interface{}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponseError struct {
	// Extensions for expression
	Expression []Element `json:"_expression,omitempty"`

	// An error code,from a specified code system, which details why the eligibility
	// check could not be performed.
	Code CodeableConcept `json:"code"`

	// A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names,
	// repetition indicators and the default child accessor that identifies one of the
	// elements in the resource that caused this issue to be raised.
	Expression_2 []String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityResponseError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in CoverageEligibilityResponseError: required")
	}
	type Plain CoverageEligibilityResponseError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageEligibilityResponseError(plain)
	return nil
}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponseEvent struct {
	// Extensions for whenDateTime
	WhenDateTime *Element `json:"_whenDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A coded event such as when a service is expected or a card printed.
	Type CodeableConcept `json:"type"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenDateTime_2 *string `json:"whenDateTime,omitempty"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityResponseEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CoverageEligibilityResponseEvent: required")
	}
	type Plain CoverageEligibilityResponseEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.WhenDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.WhenDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WhenDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = CoverageEligibilityResponseEvent(plain)
	return nil
}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponseInsurance struct {
	// Extensions for inforce
	Inforce *Element `json:"_inforce,omitempty"`

	// The term of the benefits documented in this response.
	BenefitPeriod *Period `json:"benefitPeriod,omitempty"`

	// Reference to the insurance card level information contained in the Coverage
	// resource. The coverage issuing insurer will use these details to locate the
	// patient's actual coverage within the insurer's information system.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Flag indicating if the coverage provided is inforce currently if no service
	// date(s) specified or for the whole duration of the service dates.
	Inforce_2 *Boolean `json:"inforce,omitempty"`

	// Benefits and optionally current balances, and authorization details by category
	// or service.
	Item []CoverageEligibilityResponseItem `json:"item,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityResponseInsurance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in CoverageEligibilityResponseInsurance: required")
	}
	type Plain CoverageEligibilityResponseInsurance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageEligibilityResponseInsurance(plain)
	return nil
}

// This resource provides eligibility and plan details from the processing of an
// CoverageEligibilityRequest resource.
type CoverageEligibilityResponseItem struct {
	// Extensions for authorizationRequired
	AuthorizationRequired *Element `json:"_authorizationRequired,omitempty"`

	// Extensions for authorizationUrl
	AuthorizationUrl *Element `json:"_authorizationUrl,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for excluded
	Excluded *Element `json:"_excluded,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// A boolean flag indicating whether a preauthorization is required prior to
	// actual service delivery.
	AuthorizationRequired_2 *Boolean `json:"authorizationRequired,omitempty"`

	// Codes or comments regarding information or actions associated with the
	// preauthorization.
	AuthorizationSupporting []CodeableConcept `json:"authorizationSupporting,omitempty"`

	// A web location for obtaining requirements or descriptive information regarding
	// the preauthorization.
	AuthorizationUrl_2 *Uri `json:"authorizationUrl,omitempty"`

	// Benefits used to date.
	Benefit []CoverageEligibilityResponseBenefit `json:"benefit,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// A richer description of the benefit or services covered.
	Description_2 *Markdown `json:"description,omitempty"`

	// True if the indicated class of service is excluded from the plan, missing or
	// False indicates the product or service is included in the coverage.
	Excluded_2 *Boolean `json:"excluded,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A short name or tag for the benefit.
	Name_2 *String `json:"name,omitempty"`

	// Is a flag to indicate whether the benefits refer to in-network providers or
	// out-of-network providers.
	Network *CodeableConcept `json:"network,omitempty"`

	// This contains the product, service, drug or other billing code for the item.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// The practitioner who is eligible for the provision of the product or service.
	Provider *Reference `json:"provider,omitempty"`

	// The term or period of the values such as 'maximum lifetime benefit' or 'maximum
	// annual visits'.
	Term *CodeableConcept `json:"term,omitempty"`

	// Indicates if the benefits apply to an individual or to the family.
	Unit *CodeableConcept `json:"unit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageEligibilityResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["insurer"]; raw != nil && !ok {
		return fmt.Errorf("field insurer in CoverageEligibilityResponse: required")
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in CoverageEligibilityResponse: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in CoverageEligibilityResponse: required")
	}
	type Plain CoverageEligibilityResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = CoverageEligibilityResponse(plain)
	return nil
}

// Financial instrument which may be used to reimburse or pay for health care
// products and services. Includes both insurance and self-payment.
type CoverageException struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The timeframe the exception is in force.
	Period *Period `json:"period,omitempty"`

	// The code for the specific exception.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoverageException) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CoverageException: required")
	}
	type Plain CoverageException
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoverageException(plain)
	return nil
}

// Financial instrument which may be used to reimburse or pay for health care
// products and services. Includes both insurance and self-payment.
type CoveragePaymentBy struct {
	// Extensions for responsibility
	Responsibility *Element `json:"_responsibility,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The list of parties providing non-insurance payment for the treatment costs.
	Party Reference `json:"party"`

	//  Description of the financial responsibility.
	Responsibility_2 *String `json:"responsibility,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoveragePaymentBy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["party"]; raw != nil && !ok {
		return fmt.Errorf("field party in CoveragePaymentBy: required")
	}
	type Plain CoveragePaymentBy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CoveragePaymentBy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Coverage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["beneficiary"]; raw != nil && !ok {
		return fmt.Errorf("field beneficiary in Coverage: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Coverage: required")
	}
	type Plain Coverage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Coverage(plain)
	return nil
}

// Describes a required data item for evaluation in terms of the type of data, and
// optional code or date-based filters of the data.
type DataRequirement struct {
	// Extensions for limit
	Limit *Element `json:"_limit,omitempty"`

	// Extensions for mustSupport
	MustSupport []Element `json:"_mustSupport,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Code filters specify additional constraints on the data, specifying the value
	// set of interest for a particular element of the data. Each code filter defines
	// an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
	CodeFilter []DataRequirementCodeFilter `json:"codeFilter,omitempty"`

	// Date filters specify additional constraints on the data in terms of the
	// applicable date range for specific elements. Each date filter specifies an
	// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
	DateFilter []DataRequirementDateFilter `json:"dateFilter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Specifies a maximum number of results that are required (uses the _count search
	// parameter).
	Limit_2 *PositiveInt `json:"limit,omitempty"`

	// Indicates that specific elements of the type are referenced by the knowledge
	// module and must be supported by the consumer in order to obtain an effective
	// evaluation. This does not mean that a value is required for this element, only
	// that the consuming system must understand the element and be able to provide
	// values for it if they are available.
	//
	// The value of mustSupport SHALL be a FHIRPath resolvable on the type of the
	// DataRequirement. The path SHALL consist only of identifiers, constant indexers,
	// and .resolve() (see the [Simple FHIRPath Profile](fhirpath.html#simple) for
	// full details).
	MustSupport_2 []String `json:"mustSupport,omitempty"`

	// The profile of the required data, specified as the uri of the profile
	// definition.
	Profile []Canonical `json:"profile,omitempty"`

	// Specifies the order of the results to be returned.
	Sort []DataRequirementSort `json:"sort,omitempty"`

	// The intended subjects of the data requirement. If this element is not provided,
	// a Patient subject is assumed.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// The intended subjects of the data requirement. If this element is not provided,
	// a Patient subject is assumed.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// The type of the required data, specified as the type name of a resource. For
	// profiles, this value is set to the type of the base resource of the profile.
	Type_2 *Code `json:"type,omitempty"`

	// Value filters specify additional constraints on the data for elements other
	// than code-valued or date-valued. Each value filter specifies an additional
	// constraint on the data (i.e. valueFilters are AND'ed, not OR'ed).
	ValueFilter []DataRequirementValueFilter `json:"valueFilter,omitempty"`
}

// Describes a required data item for evaluation in terms of the type of data, and
// optional code or date-based filters of the data.
type DataRequirementCodeFilter struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// Extensions for searchParam
	SearchParam *Element `json:"_searchParam,omitempty"`

	// The codes for the code filter. If values are given, the filter will return only
	// those data items for which the code-valued attribute specified by the path has
	// a value that is one of the specified codes. If codes are specified in addition
	// to a value set, the filter returns items matching a code in the value set or
	// one of the specified codes.
	Code []Coding `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The code-valued attribute of the filter. The specified path SHALL be a FHIRPath
	// resolvable on the specified type of the DataRequirement, and SHALL consist only
	// of identifiers, constant indexers, and .resolve(). The path is allowed to
	// contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to
	// traverse multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details). Note that the index must be
	// an integer constant. The path must resolve to an element of type code, Coding,
	// or CodeableConcept.
	Path_2 *String `json:"path,omitempty"`

	// A token parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type code,
	// Coding, or CodeableConcept.
	SearchParam_2 *String `json:"searchParam,omitempty"`

	// The valueset for the code filter. The valueSet and code elements are additive.
	// If valueSet is specified, the filter will return only those data items for
	// which the value of the code-valued element specified in the path is a member of
	// the specified valueset.
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

// Describes a required data item for evaluation in terms of the type of data, and
// optional code or date-based filters of the data.
type DataRequirementDateFilter struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// Extensions for searchParam
	SearchParam *Element `json:"_searchParam,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The date-valued attribute of the filter. The specified path SHALL be a FHIRPath
	// resolvable on the specified type of the DataRequirement, and SHALL consist only
	// of identifiers, constant indexers, and .resolve(). The path is allowed to
	// contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to
	// traverse multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details). Note that the index must be
	// an integer constant. The path must resolve to an element of type date,
	// dateTime, Period, Schedule, or Timing.
	Path_2 *String `json:"path,omitempty"`

	// A date parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type date,
	// dateTime, Period, Schedule, or Timing.
	SearchParam_2 *String `json:"searchParam,omitempty"`

	// The value of the filter. If period is specified, the filter will return only
	// those data items that fall within the bounds determined by the Period,
	// inclusive of the period boundaries. If dateTime is specified, the filter will
	// return only those data items that are equal to the specified dateTime. If a
	// Duration is specified, the filter will return only those data items that fall
	// within Duration before now.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of the filter. If period is specified, the filter will return only
	// those data items that fall within the bounds determined by the Period,
	// inclusive of the period boundaries. If dateTime is specified, the filter will
	// return only those data items that are equal to the specified dateTime. If a
	// Duration is specified, the filter will return only those data items that fall
	// within Duration before now.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The value of the filter. If period is specified, the filter will return only
	// those data items that fall within the bounds determined by the Period,
	// inclusive of the period boundaries. If dateTime is specified, the filter will
	// return only those data items that are equal to the specified dateTime. If a
	// Duration is specified, the filter will return only those data items that fall
	// within Duration before now.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataRequirementDateFilter) UnmarshalJSON(value []byte) error {
	type Plain DataRequirementDateFilter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = DataRequirementDateFilter(plain)
	return nil
}

// Describes a required data item for evaluation in terms of the type of data, and
// optional code or date-based filters of the data.
type DataRequirementSort struct {
	// Extensions for direction
	Direction *Element `json:"_direction,omitempty"`

	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// The direction of the sort, ascending or descending.
	Direction_2 *DataRequirementSortDirection_2 `json:"direction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The attribute of the sort. The specified path must be resolvable from the type
	// of the required data. The path is allowed to contain qualifiers (.) to traverse
	// sub-elements, as well as indexers ([x]) to traverse multiple-cardinality
	// sub-elements. Note that the index must be an integer constant.
	Path_2 *String `json:"path,omitempty"`
}

type DataRequirementSortDirection_2 string

const DataRequirementSortDirection_2_Ascending DataRequirementSortDirection_2 = "ascending"
const DataRequirementSortDirection_2_Descending DataRequirementSortDirection_2 = "descending"

var enumValues_DataRequirementSortDirection_2 = []interface{}{
	"ascending",
	"descending",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataRequirementSortDirection_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DataRequirementSortDirection_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DataRequirementSortDirection_2, v)
	}
	*j = DataRequirementSortDirection_2(v)
	return nil
}

// Describes a required data item for evaluation in terms of the type of data, and
// optional code or date-based filters of the data.
type DataRequirementValueFilter struct {
	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// Extensions for searchParam
	SearchParam *Element `json:"_searchParam,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// The comparator to be used to determine whether the value is matching.
	Comparator_2 *Code `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The attribute of the filter. The specified path SHALL be a FHIRPath resolvable
	// on the specified type of the DataRequirement, and SHALL consist only of
	// identifiers, constant indexers, and .resolve(). The path is allowed to contain
	// qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details). Note that the index must be
	// an integer constant. The path must resolve to an element of a type that is
	// comparable to the valueFilter.value[x] element for the filter.
	Path_2 *String `json:"path,omitempty"`

	// A search parameter defined on the specified type of the DataRequirement, and
	// which searches on elements of a type compatible with the type of the
	// valueFilter.value[x] for the filter.
	SearchParam_2 *String `json:"searchParam,omitempty"`

	// The value of the filter.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of the filter.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The value of the filter.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataRequirementValueFilter) UnmarshalJSON(value []byte) error {
	type Plain DataRequirementValueFilter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = DataRequirementValueFilter(plain)
	return nil
}

// The base class for all re-useable types defined as part of the FHIR
// Specification.
type DataType struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`
}

// A date or partial date (e.g. just year or year + month). There is no UTC offset.
// The format is a union of the schema types gYear, gYearMonth and date.  Dates
// SHALL be valid dates.
type Date string

// A date, date-time or partial date (e.g. just year or year + month).  If hours
// and minutes are specified, a UTC offset SHALL be populated. The format is a
// union of the schema types gYear, gYearMonth, date and dateTime. Seconds must be
// provided due to schema type constraints but may be zero-filled and may be
// ignored.                 Dates SHALL be valid dates.
type DateTime string

// UnmarshalJSON implements json.Unmarshaler.
func (j *DateTime) UnmarshalJSON(value []byte) error {
	type Plain DateTime
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
	}
	*j = DateTime(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Date) UnmarshalJSON(value []byte) error {
	type Plain Date
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
	}
	*j = Date(plain)
	return nil
}

// A rational number with implicit precision
type Decimal float64

// Indicates an actual or potential clinical issue with or between one or more
// active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
// Ineffective treatment frequency, Procedure-condition conflict, gaps in care,
// etc.
type DetectedIssue struct {
	// Extensions for detail
	Detail *Element `json:"_detail,omitempty"`

	// Extensions for identifiedDateTime
	IdentifiedDateTime *Element `json:"_identifiedDateTime,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for reference
	Reference *Element `json:"_reference,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Individual or device responsible for the issue being raised.  For example, a
	// decision support application or a pharmacist conducting a medication review.
	Author *Reference `json:"author,omitempty"`

	// Partitions the detected issue into one or more categories that can be used to
	// filter searching, to govern access control and/or to guide system behavior.
	Category []CodeableConcept `json:"category,omitempty"`

	// A code that identifies the specific type of issue detected.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DetectedIssueContainedElem `json:"contained,omitempty"`

	// A textual explanation of the detected issue.
	Detail_2 *Markdown `json:"detail,omitempty"`

	// The Encounter during which this detected issue was created or to which the
	// creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// Supporting evidence or manifestations that provide the basis for identifying
	// the detected issue such as a GuidanceResponse or MeasureReport.
	Evidence []DetectedIssueEvidence `json:"evidence,omitempty"`

	// The time frame in which the clinical effects of the detected issue may be
	// expected to occur. Rapid refers to an expected onset within 24 hours. Delayed
	// refers to an expected onset in more than 24 hours.
	ExpectedOnsetType *CodeableConcept `json:"expectedOnsetType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The date, period or timing when the detected issue did occur or is occurring.
	IdentifiedDateTime_2 *string `json:"identifiedDateTime,omitempty"`

	// The date, period or timing when the detected issue did occur or is occurring.
	IdentifiedPeriod *Period `json:"identifiedPeriod,omitempty"`

	// The date, period or timing when the detected issue did occur or is occurring.
	IdentifiedTiming *Timing `json:"identifiedTiming,omitempty"`

	// Business identifiers assigned to this detected issue by the performer and/or
	// other systems.  These identifiers remain constant as the resource is updated
	// and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Indicates the resource representing the current activity or proposed activity
	// that is potentially problematic.
	Implicated []Reference `json:"implicated,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// An indication of the importance or type of step that should or may be taken in
	// order to address the detected issue. This is different than mitigation in that
	// it is not specifically providing actions to be taken, rather general
	// suggestions about approach.
	ManagementCode *CodeableConcept `json:"managementCode,omitempty"`

	// Represents the medication class that is responsible for the detected issue.
	MedicationClass []CodeableConcept `json:"medicationClass,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// Indicates an action that has been taken or is committed to reduce or eliminate
	// the likelihood of the risk identified by the detected issue from manifesting.
	// Can also reflect an observation of known mitigating factors that may
	// reduce/eliminate the need for any action.
	Mitigation []DetectedIssueMitigation `json:"mitigation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The quality of the evidence supporting identification of the detected issue.
	// The code system used specifies the quality scale used to grade this evidence
	// source while the code specifies the actual quality score (represented as a
	// coded value) associated with the evidence.
	QualityOfEvidence *CodeableConcept `json:"qualityOfEvidence,omitempty"`

	// The literature, knowledge-base or similar reference that describes the
	// propensity for the detected issue identified.
	Reference_2 *Uri `json:"reference,omitempty"`

	// This is a DetectedIssue resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates the degree of importance associated with the identified issue based
	// on the potential impact on the patient.
	Severity *CodeableConcept `json:"severity,omitempty"`

	// The current state of the detected issue.
	Status_2 *Code `json:"status,omitempty"`

	// Indicates the subject whose record the detected issue is associated with.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type DetectedIssueContainedElem interface{}

// Indicates an actual or potential clinical issue with or between one or more
// active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
// Ineffective treatment frequency, Procedure-condition conflict, gaps in care,
// etc.
type DetectedIssueEvidence struct {
	// A manifestation that led to the recording of this detected issue.
	Code []CodeableConcept `json:"code,omitempty"`

	// Links to resources that constitute evidence for the detected issue such as a
	// GuidanceResponse or MeasureReport.
	Detail []Reference `json:"detail,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Indicates an actual or potential clinical issue with or between one or more
// active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
// Ineffective treatment frequency, Procedure-condition conflict, gaps in care,
// etc.
type DetectedIssueMitigation struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Describes the action that was taken or the observation that was made that
	// reduces/eliminates the risk associated with the identified issue.
	Action CodeableConcept `json:"action"`

	// Identifies the practitioner who determined the mitigation and takes
	// responsibility for the mitigation step occurring.
	Author *Reference `json:"author,omitempty"`

	// Indicates when the mitigating action was documented.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Clinicians may add additional notes or justifications about the mitigation
	// action. For example, patient can have this drug because they have had it before
	// without any issues. Multiple justifications may be provided.
	Note []Annotation `json:"note,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DetectedIssueMitigation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in DetectedIssueMitigation: required")
	}
	type Plain DetectedIssueMitigation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DetectedIssueMitigation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DetectedIssue) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DetectedIssue: required")
	}
	type Plain DetectedIssue
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.IdentifiedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.IdentifiedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "IdentifiedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = DetectedIssue(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type Device struct {
	// Extensions for expirationDate
	ExpirationDate *Element `json:"_expirationDate,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lotNumber
	LotNumber *Element `json:"_lotNumber,omitempty"`

	// Extensions for manufactureDate
	ManufactureDate *Element `json:"_manufactureDate,omitempty"`

	// Extensions for manufacturer
	Manufacturer *Element `json:"_manufacturer,omitempty"`

	// Extensions for modelNumber
	ModelNumber *Element `json:"_modelNumber,omitempty"`

	// Extensions for partNumber
	PartNumber *Element `json:"_partNumber,omitempty"`

	// Extensions for serialNumber
	SerialNumber *Element `json:"_serialNumber,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Material added to a container device (typically used in specimen collection or
	// initial processing).  The material may be added by the device manufacturer or
	// by a different party subsequent to manufacturing.
	Additive []DeviceAdditive `json:"additive,omitempty"`

	// The availability of the device.
	AvailabilityStatus *CodeableConcept `json:"availabilityStatus,omitempty"`

	// A production identifier of the donation, collection, or pooling event from
	// which biological material in this device was derived.
	BiologicalSourceEvent *Identifier `json:"biologicalSourceEvent,omitempty"`

	// Devices may be associated with one or more categories.
	Category []CodeableConcept `json:"category,omitempty"`

	// Identifies the standards, specifications, or formal guidances for the
	// capabilities supported by the device. The device may be certified as conformant
	// to these specifications e.g., communication, performance, process, measurement,
	// or specialization standards.
	ConformsTo []DeviceConformsTo `json:"conformsTo,omitempty"`

	// Contact details for an organization or a particular human that is responsible
	// for the device.
	Contact []ContactPoint `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceContainedElem `json:"contained,omitempty"`

	// The reference to the definition for the device.
	Definition *Canonical `json:"definition,omitempty"`

	// The actual design of the device or software version running on the device.
	DeviceVersion []DeviceDeviceVersion `json:"deviceVersion,omitempty"`

	// The date and time beyond which this device is no longer valid or should not be
	// used (if applicable).
	ExpirationDate_2 *DateTime `json:"expirationDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique instance identifiers assigned to a device by manufacturers other
	// organizations or owners.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The place where the device can be found.
	Location *Reference `json:"location,omitempty"`

	// Lot number assigned by the manufacturer.
	LotNumber_2 *String `json:"lotNumber,omitempty"`

	// The date and time when the device was manufactured.
	ManufactureDate_2 *DateTime `json:"manufactureDate,omitempty"`

	// A name of the manufacturer or entity legally responsible for the device.
	Manufacturer_2 *String `json:"manufacturer,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The manufacturer's model number for the device.
	ModelNumber_2 *String `json:"modelNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This represents the manufacturer's name of the device as provided by the
	// device, from a UDI label, or by a person describing the Device.  This typically
	// would be used when a person provides the name(s) or when the device represents
	// one of the names available from DeviceDefinition.
	Name []DeviceName `json:"name,omitempty"`

	// Descriptive information, usage information or implantation information that is
	// not captured in an existing element.
	Note []Annotation `json:"note,omitempty"`

	// The higher level or encompassing device that this device is a logical part of.
	Parent *Reference `json:"parent,omitempty"`

	// The part number or catalog number of the device.
	PartNumber_2 *String `json:"partNumber,omitempty"`

	// Static or essentially fixed characteristics or features of the device (e.g.,
	// time or timing attributes, resolution, accuracy, intended use or instructions
	// for use, and physical attributes) that are not otherwise captured in more
	// specific attributes.
	Property []DeviceProperty `json:"property,omitempty"`

	// This is a Device resource
	ResourceType interface{} `json:"resourceType"`

	// Provides additional safety characteristics about a medical device.  For example
	// devices containing latex.
	Safety []CodeableConcept `json:"safety,omitempty"`

	// The serial number assigned by the organization when the device was
	// manufactured.
	SerialNumber_2 *String `json:"serialNumber,omitempty"`

	// The Device record status. This is not the status of the device like
	// availability.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The kind or type of device. A device instance may have more than one type - in
	// which case those are the types that apply to the specific instance of the
	// device.
	Type []CodeableConcept `json:"type,omitempty"`

	// Unique Device Identifier (UDI) placed on a device label or package. Note that
	// the Device may include multiple UDIs if it is sold in multiple jurisdictions.
	UdiCarrier []DeviceUdiCarrier `json:"udiCarrier,omitempty"`
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceAdditive struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The quantity of the additive substance in the container; may be volume,
	// dimensions, or other appropriate measurements, depending on the container and
	// additive substance type.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of the substance added to the container.  This is represented as a
	// concept from a code system or described in a Substance resource.
	Type CodeableReference `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceAdditive) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceAdditive: required")
	}
	type Plain DeviceAdditive
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceAdditive(plain)
	return nil
}

// Describes a noteworthy condition or occurrence determined to exist by a device.
type DeviceAlert struct {
	// Extensions for acknowledged
	Acknowledged *Element `json:"_acknowledged,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for label
	Label *Element `json:"_label,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for presence
	Presence *Element `json:"_presence,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// An indication of whether (true) or not (false) the alert condition has been
	// acknowledged.
	Acknowledged_2 *Boolean `json:"acknowledged,omitempty"`

	// An indication of who or what acknowledged the alert condition.
	AcknowledgedBy *Reference `json:"acknowledgedBy,omitempty"`

	// Partitions the device alert into one or more categories that can be used to
	// filter searching, to govern access control and/or to guide system behavior.
	Category []CodeableConcept `json:"category,omitempty"`

	// A code that indicates the specific condition that triggered the alert.
	Code CodeableConcept `json:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceAlertContainedElem `json:"contained,omitempty"`

	// The value causing the alert condition.
	DerivedFrom []DeviceAlertDerivedFrom `json:"derivedFrom,omitempty"`

	// Indicates the device that detected the alert condition. The device could be a
	// top-level Device or component Device (such as an MDS, VMD, or Channel); or
	// might identify the specific DeviceMetric of a Device (e.g., a heart rate
	// reading) that was in an alert condition.
	Device *Reference `json:"device,omitempty"`

	// The Encounter during which the alert condition was raised.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this alert, by the source device, gateway
	// software, manufacturers, or other systems or organizations. These identifiers
	// remain constant as the resource is updated and propagates from server to
	// server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The label might combine information from the alert code, priority, the
	// measurement type, measurement value, body sites and other sources, e.g., â€œHR >
	// 180â€.
	Label_2 *String `json:"label,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The principal physical location of the subject at the time the alert condition
	// occurred. This could be different from the location of the alerting device at
	// that time, and from the current location of either the subject or the alert
	// condition detecting device.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This element is used to record the date or time period when the alert condition
	// did occur or is occurring.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// This element is used to record the date or time period when the alert condition
	// did occur or is occurring.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// Whether the alert condition is currently active.
	Presence_2 *Boolean `json:"presence,omitempty"`

	// The alert priority is usually reported by the source device. A priority of
	// `info` SHOULD indicate that the alert is â€œfor information onlyâ€ and urgent
	// action is not required. The element MAY be omitted if the priority is unknown.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// The procedure (or procedures) during which the alert condition was raised.
	Procedure []Reference `json:"procedure,omitempty"`

	// This is a DeviceAlert resource
	ResourceType interface{} `json:"resourceType"`

	// Annunciation or notification of the alert condition.
	Signal []DeviceAlertSignal `json:"signal,omitempty"`

	// The current state of the device alert.
	Status_2 *Code `json:"status,omitempty"`

	// Who or what the alert is about.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// physiological | technical.
	Type *CodeableConcept `json:"type,omitempty"`
}

type DeviceAlertContainedElem interface{}

// Describes a noteworthy condition or occurrence determined to exist by a device.
type DeviceAlertDerivedFrom struct {
	// If applicable, the code of the component (of the Observation identified in
	// `derivedFrom.observation`) having a value causing the alert condition. This
	// might be used when the alert is associated with a specific component of an
	// Observation, rather than the overall Observation; for example, a low diastolic
	// blood pressure. Since the component is identified by matching
	// `Observation.component.code`, if more than one component have the same code,
	// the specific component is ambiguous. Repetitions of this element indicate
	// additional components contributing to the alert condition.
	Component *Coding `json:"component,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The limits beyond which a value was detected to cause the alert condition. The
	// actual value is the `Observation.value[x]` referenced by
	// `derivedFrom.observation` or, if specified, the
	// `Observation.component.value[x]` of the component (with
	// `Observation.component.code` matching `derivedFrom.component`) of the reference
	// Observation.
	Limit *Range `json:"limit,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the Observation whose value is causing the alert condition; or, if
	// `component` is present, the Observation with a component causing the alert
	// condition.
	Observation Reference `json:"observation"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceAlertDerivedFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["observation"]; raw != nil && !ok {
		return fmt.Errorf("field observation in DeviceAlertDerivedFrom: required")
	}
	type Plain DeviceAlertDerivedFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceAlertDerivedFrom(plain)
	return nil
}

// Describes a noteworthy condition or occurrence determined to exist by a device.
type DeviceAlertSignal struct {
	// Paused indicates that annunciation has temporarily been disabled ("snooze").
	ActivationState CodeableConcept `json:"activationState"`

	// Signalling by the source device is local; signalling elsewhere is considered
	// remote. A reference to the "top level" signalling device could also be present.
	Annunciator *CodeableReference `json:"annunciator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The period during which the signal was being annunciated. If there is no
	// indicated period end, the annunciation is on-going.
	Indication *Period `json:"indication,omitempty"`

	// How the signal is being annunciated.
	Manifestation *CodeableConcept `json:"manifestation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether the signal is currently being annunciated. An on signal is
	// currently being annunciated; a latched signal is currently being being
	// annunciated although the alert condition has ended; an off signal is not
	// currently being annunciated; and an acknowledged signal is not currently being
	// annunciated because the user has acknowledged the signal.
	Presence *CodeableConcept `json:"presence,omitempty"`

	// Details of the signal manifestation, such as a 1 meter visual indicator or a 4
	// meter visual indicator.
	Type []CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceAlertSignal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["activationState"]; raw != nil && !ok {
		return fmt.Errorf("field activationState in DeviceAlertSignal: required")
	}
	type Plain DeviceAlertSignal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceAlertSignal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceAlert) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in DeviceAlert: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DeviceAlert: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in DeviceAlert: required")
	}
	type Plain DeviceAlert
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = DeviceAlert(plain)
	return nil
}

// A record of association or dissociation of a device with a subject (e.g.
// patient) and/or operator.
type DeviceAssociation struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// State of the deviceâ€™s association (e.g., implanted, attached, on, off, standby,
	// defective).
	AssociationStatus *CodeableConcept `json:"associationStatus,omitempty"`

	// Current anatomical location of the device in/on subject.
	BodyStructure *Reference `json:"bodyStructure,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceAssociationContainedElem `json:"contained,omitempty"`

	// Reference to the device that is being associated.
	Device Reference `json:"device"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The entity for which the device is being used, benefitting from the device, or
	// which the device is being operated upon, which is usually distinct from the
	// association subject, such as an operator or similar.
	Focus *Reference `json:"focus,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Instance identifier.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Begin and end dates and times for the device association.
	Period *Period `json:"period,omitempty"`

	// Describes the relationship between the device and subject.
	Relationship []CodeableConcept `json:"relationship,omitempty"`

	// This is a DeviceAssociation resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates the state of the Device association.
	Status_2 *Code `json:"status,omitempty"`

	// The reasons given for the current association status.
	StatusReason []CodeableConcept `json:"statusReason,omitempty"`

	// The individual, group of individuals or device that the device is on or
	// associated with.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type DeviceAssociationContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceAssociation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["device"]; raw != nil && !ok {
		return fmt.Errorf("field device in DeviceAssociation: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DeviceAssociation: required")
	}
	type Plain DeviceAssociation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceAssociation(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceConformsTo struct {
	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Describes the type of the standard, specification, or formal guidance.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Code that identifies the specific standard, specification, protocol, formal
	// guidance, regulation, legislation, or certification scheme to which the device
	// adheres.
	Specification CodeableConcept `json:"specification"`

	// Identifies the specific form or variant of the standard, specification, or
	// formal guidance. This may be a 'version number', release, document edition,
	// publication year, or other label.
	Version_2 *String `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceConformsTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["specification"]; raw != nil && !ok {
		return fmt.Errorf("field specification in DeviceConformsTo: required")
	}
	type Plain DeviceConformsTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceConformsTo(plain)
	return nil
}

type DeviceContainedElem interface{}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for modelNumber
	ModelNumber *Element `json:"_modelNumber,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for outputLanguage
	OutputLanguage []Element `json:"_outputLanguage,omitempty"`

	// Extensions for partNumber
	PartNumber *Element `json:"_partNumber,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the asset content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// Billing code or reference associated with the device.
	ChargeItem []DeviceDefinitionChargeItem `json:"chargeItem,omitempty"`

	// What kind of device or device system this is.
	Classification []DeviceDefinitionClassification `json:"classification,omitempty"`

	// Identifies the standards, specifications, or formal guidances for the
	// capabilities supported by the device. The device may be certified as conformant
	// to these specifications e.g., communication, performance, process, measurement,
	// or specialization standards.
	ConformsTo []DeviceDefinitionConformsTo `json:"conformsTo,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the DeviceDefinition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the DeviceDefinition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// Tracking of latest field safety corrective action.
	CorrectiveAction *DeviceDefinitionCorrectiveAction `json:"correctiveAction,omitempty"`

	// The date (and optionally time) when the DeviceDefinition was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the DeviceDefinition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the DeviceDefinition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// The name or names of the device as given by the manufacturer.
	DeviceName []DeviceDefinitionDeviceName `json:"deviceName,omitempty"`

	// The version of the device or software.
	DeviceVersion []DeviceDefinitionDeviceVersion `json:"deviceVersion,omitempty"`

	// The period during which the DeviceDefinition content was or is planned to be
	// effective.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// A Boolean value to indicate that this DeviceDefinition is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Information aimed at providing directions for the usage of this model of
	// device.
	Guideline *DeviceDefinitionGuideline `json:"guideline,omitempty"`

	// A device that is part (for example a component) of the present device.
	HasPart []DeviceDefinitionHasPart `json:"hasPart,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this DeviceDefinition when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the asset content was last reviewed. Review happens
	// periodically after that, but doesn't change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// An associated device, attached to, used with, communicating with or linking a
	// previous or new device model to the focal device.
	Link []DeviceDefinitionLink `json:"link,omitempty"`

	// A name of the manufacturer  or legal representative e.g. labeler. Whether this
	// is the actual manufacturer or the labeler or responsible depends on
	// implementation and jurisdiction.
	Manufacturer *Reference `json:"manufacturer,omitempty"`

	// A substance used to create the material(s) of which the device is made.
	Material []DeviceDefinitionMaterial `json:"material,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The model number for the device for example as defined by the manufacturer or
	// labeler, or other agency.
	ModelNumber_2 *String `json:"modelNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the DeviceDefinition. This name should be
	// usable as an identifier for the resource by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Descriptive information, usage information or implantation information that is
	// not captured in an existing element.
	Note []Annotation `json:"note,omitempty"`

	// Language code for the human-readable text strings produced by the device (all
	// supported).
	OutputLanguage_2 []Code `json:"outputLanguage,omitempty"`

	// Information about the packaging of the device, i.e. how the device is packaged.
	Packaging []DeviceDefinitionPackaging `json:"packaging,omitempty"`

	// The part number or catalog number of the device.
	PartNumber_2 *String `json:"partNumber,omitempty"`

	// Indicates the production identifier(s) that are expected to appear in the UDI
	// carrier on the device label.
	ProductionIdentifierInUDI []CodeableConcept `json:"productionIdentifierInUDI,omitempty"`

	// Static or essentially fixed characteristics or features of this kind of device
	// that are otherwise not captured in more specific attributes, e.g., time or
	// timing attributes, resolution, accuracy, and physical attributes.
	Property []DeviceDefinitionProperty `json:"property,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the DeviceDefinition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this DeviceDefinition is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Identifier associated with the regulatory documentation (certificates,
	// technical documentation, post-market surveillance documentation and reports) of
	// a set of device models sharing the same intended purpose, risk class and
	// essential design and manufacturing characteristics. One example is the Basic
	// UDI-DI in Europe.
	RegulatoryIdentifier []DeviceDefinitionRegulatoryIdentifier `json:"regulatoryIdentifier,omitempty"`

	// This is a DeviceDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// Safety characteristics of the device.
	Safety []CodeableConcept `json:"safety,omitempty"`

	// Shelf Life and storage information.
	ShelfLifeStorage []ProductShelfLife `json:"shelfLifeStorage,omitempty"`

	// The current state of this DeviceDefinition.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the DeviceDefinition.
	Title_2 *String `json:"title,omitempty"`

	// The Device Identifier (DI) portion of the Unique Device Identifier (UDI) placed
	// on a device label or package. Also known as UDI-DI. Note that the
	// DeviceDefinition may include multiple UDI-DIs if it is sold in multiple
	// jurisdictions.
	UdiDeviceIdentifier []DeviceDefinitionUdiDeviceIdentifier `json:"udiDeviceIdentifier,omitempty"`

	// An absolute URI that is used to identify this DeviceDefinition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier.  This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this DeviceDefinition is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the DeviceDefinition is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate
	// DeviceDefinitions.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the DeviceDefinition
	// when it is referenced in a specification.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionChargeItem struct {
	// The code or reference for the charge item.
	ChargeItemCode CodeableReference `json:"chargeItemCode"`

	// Coefficient applicable to the billing code.
	Count Quantity `json:"count"`

	// A specific time period in which this charge item applies.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The context to which this charge item applies.
	UseContext []UsageContext `json:"useContext,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionChargeItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["chargeItemCode"]; raw != nil && !ok {
		return fmt.Errorf("field chargeItemCode in DeviceDefinitionChargeItem: required")
	}
	if _, ok := raw["count"]; raw != nil && !ok {
		return fmt.Errorf("field count in DeviceDefinitionChargeItem: required")
	}
	type Plain DeviceDefinitionChargeItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionChargeItem(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionClassification struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Further information qualifying this classification of the device model.
	Justification []RelatedArtifact `json:"justification,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A classification or risk class of the device model.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionClassification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceDefinitionClassification: required")
	}
	type Plain DeviceDefinitionClassification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionClassification(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionConformsTo struct {
	// Extensions for version
	Version []Element `json:"_version,omitempty"`

	// Describes the type of the standard, specification, or formal guidance.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Standard, regulation, certification, or guidance website, document, or other
	// publication, or similar, supporting the conformance.
	Source []RelatedArtifact `json:"source,omitempty"`

	// Code that identifies the specific standard, specification, protocol, formal
	// guidance, regulation, legislation, or certification scheme to which the device
	// adheres.
	Specification CodeableConcept `json:"specification"`

	// Identifies the specific form or variant of the standard, specification, or
	// formal guidance. This may be a 'version number', release, document edition,
	// publication year, or other label.
	Version_2 []String `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionConformsTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["specification"]; raw != nil && !ok {
		return fmt.Errorf("field specification in DeviceDefinitionConformsTo: required")
	}
	type Plain DeviceDefinitionConformsTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionConformsTo(plain)
	return nil
}

type DeviceDefinitionContainedElem interface{}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionCorrectiveAction struct {
	// Extensions for recall
	Recall *Element `json:"_recall,omitempty"`

	// Extensions for scope
	Scope *Element `json:"_scope,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Start and end dates of the  corrective action.
	Period Period `json:"period"`

	// Whether the last corrective action known for this device was a recall.
	Recall_2 *Boolean `json:"recall,omitempty"`

	// The scope of the corrective action - whether the action targeted all units of a
	// given device model, or only a specific set of batches identified by lot
	// numbers, or individually identified devices identified by the serial name.
	Scope_2 *Code `json:"scope,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionCorrectiveAction) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["period"]; raw != nil && !ok {
		return fmt.Errorf("field period in DeviceDefinitionCorrectiveAction: required")
	}
	type Plain DeviceDefinitionCorrectiveAction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionCorrectiveAction(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionDeviceName struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A human-friendly name that is used to refer to the device - depending on the
	// type, it can be the brand name, the common name or alias, or other.
	Name_2 *String `json:"name,omitempty"`

	// The type of deviceName.
	// RegisteredName | UserFriendlyName | PatientReportedName.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionDeviceName) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceDefinitionDeviceName: required")
	}
	type Plain DeviceDefinitionDeviceName
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionDeviceName(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionDeviceVersion struct {
	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// The hardware or software module of the device to which the version applies.
	Component *Identifier `json:"component,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of the device version, e.g. manufacturer, approved, internal.
	Type *CodeableConcept `json:"type,omitempty"`

	// The version text.
	Value_2 *String `json:"value,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionDistributor struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Distributor's human-readable name.
	Name_2 *String `json:"name,omitempty"`

	// Distributor as an Organization resource.
	OrganizationReference []Reference `json:"organizationReference,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionGuideline struct {
	// Extensions for intendedUse
	IntendedUse *Element `json:"_intendedUse,omitempty"`

	// Extensions for usageInstruction
	UsageInstruction *Element `json:"_usageInstruction,omitempty"`

	// A specific situation when a device should not be used because it may cause
	// harm.
	Contraindication []CodeableConcept `json:"contraindication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A clinical condition for which the device was designed to be used.
	Indication []CodeableConcept `json:"indication,omitempty"`

	// A description of the general purpose or medical use of the device or its
	// function.
	IntendedUse_2 *String `json:"intendedUse,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A source of information or reference for this guideline.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// Detailed written and visual directions for the user on how to use the device.
	UsageInstruction_2 *Markdown `json:"usageInstruction,omitempty"`

	// The circumstances that form the setting for using the device.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// Specific hazard alert information that a user needs to know before using the
	// device.
	Warning []CodeableConcept `json:"warning,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionHasPart struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// Extensions for definitionCanonical
	DefinitionCanonical *Element `json:"_definitionCanonical,omitempty"`

	// Number of instances of the component device in the current device.
	Count_2 *Integer `json:"count,omitempty"`

	// The device that is part of the current device.
	DefinitionCanonical_2 *string `json:"definitionCanonical,omitempty"`

	// The device that is part of the current device.
	DefinitionCodeableConcept *CodeableConcept `json:"definitionCodeableConcept,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionHasPart) UnmarshalJSON(value []byte) error {
	type Plain DeviceDefinitionHasPart
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DefinitionCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefinitionCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefinitionCanonical_2", `^\S*$`)
		}
	}
	*j = DeviceDefinitionHasPart(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionLink struct {
	// Extensions for relatedDeviceCanonical
	RelatedDeviceCanonical *Element `json:"_relatedDeviceCanonical,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to the linked device.
	RelatedDeviceCanonical_2 *string `json:"relatedDeviceCanonical,omitempty"`

	// A reference to the linked device.
	RelatedDeviceCodeableConcept *CodeableConcept `json:"relatedDeviceCodeableConcept,omitempty"`

	// The type indicates the relationship of the related device to the device
	// instance.
	Relation Coding `json:"relation"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionLink) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["relation"]; raw != nil && !ok {
		return fmt.Errorf("field relation in DeviceDefinitionLink: required")
	}
	type Plain DeviceDefinitionLink
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.RelatedDeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.RelatedDeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "RelatedDeviceCanonical_2", `^\S*$`)
		}
	}
	*j = DeviceDefinitionLink(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionMarketDistribution struct {
	// Extensions for subJurisdiction
	SubJurisdiction *Element `json:"_subJurisdiction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Begin and end dates for the commercial distribution of the device.
	MarketPeriod Period `json:"marketPeriod"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// National state or territory to which the marketDistribution recers, typically
	// where the device is commercialized.
	SubJurisdiction_2 *Uri `json:"subJurisdiction,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionMarketDistribution) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["marketPeriod"]; raw != nil && !ok {
		return fmt.Errorf("field marketPeriod in DeviceDefinitionMarketDistribution: required")
	}
	type Plain DeviceDefinitionMarketDistribution
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionMarketDistribution(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionMaterial struct {
	// Extensions for allergenicIndicator
	AllergenicIndicator *Element `json:"_allergenicIndicator,omitempty"`

	// Extensions for alternate
	Alternate *Element `json:"_alternate,omitempty"`

	// Whether the substance is a known or suspected allergen.
	AllergenicIndicator_2 *Boolean `json:"allergenicIndicator,omitempty"`

	// Indicates an alternative material of the device.
	Alternate_2 *Boolean `json:"alternate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A substance that the device contains, may contain, or is made of - for example
	// latex - to be used to determine patient compatibility. This is not intended to
	// represent the composition of the device, only the clinically relevant
	// materials.
	Substance CodeableConcept `json:"substance"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionMaterial) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["substance"]; raw != nil && !ok {
		return fmt.Errorf("field substance in DeviceDefinitionMaterial: required")
	}
	type Plain DeviceDefinitionMaterial
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceDefinitionMaterial(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionPackaging struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// The number of items contained in the package (devices or sub-packages).
	Count_2 *Integer `json:"count,omitempty"`

	// An organization that distributes the packaged device.
	Distributor []DeviceDefinitionDistributor `json:"distributor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The business identifier of the packaged medication.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Allows packages within packages.
	Packaging []DeviceDefinitionPackaging `json:"packaging,omitempty"`

	// A code that defines the specific type of packaging.
	Type *CodeableConcept `json:"type,omitempty"`

	// Unique Device Identifier (UDI) Barcode string on the packaging.
	UdiDeviceIdentifier []DeviceDefinitionUdiDeviceIdentifier `json:"udiDeviceIdentifier,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Code that specifies the property such as a resolution or color being
	// represented.
	Type CodeableConcept `json:"type"`

	// The value of the property specified by the associated property.type code.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinitionProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceDefinitionProperty: required")
	}
	type Plain DeviceDefinitionProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = DeviceDefinitionProperty(plain)
	return nil
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionRegulatoryIdentifier struct {
	// Extensions for identifier
	Identifier *Element `json:"_identifier,omitempty"`

	// Extensions for identifierSystem
	IdentifierSystem *Element `json:"_identifierSystem,omitempty"`

	// Extensions for issuer
	Issuer *Element `json:"_issuer,omitempty"`

	// Extensions for jurisdiction
	Jurisdiction *Element `json:"_jurisdiction,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identifier used in the associated regulatory context.
	Identifier_2 *String `json:"identifier,omitempty"`

	// Establishes the namespace for the issuing agency's system (e.g, GS1's GTIN,
	// ICCBBA's ISBT-128) used to create the identifier.
	IdentifierSystem_2 *Uri `json:"identifierSystem,omitempty"`

	// The organization that issued this identifier.
	Issuer_2 *Uri `json:"issuer,omitempty"`

	// The applicable jurisdiction overseeing the enforcement of the Identifier.
	Jurisdiction_2 *Uri `json:"jurisdiction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of identifier itself.
	Type_2 *Code `json:"type,omitempty"`
}

// The definition of a kind of device or device component. Typically, this
// definition corresponds to a device model although it may be a broader category
// of device.
type DeviceDefinitionUdiDeviceIdentifier struct {
	// Extensions for deviceIdentifier
	DeviceIdentifier *Element `json:"_deviceIdentifier,omitempty"`

	// Extensions for deviceIdentifierSystem
	DeviceIdentifierSystem *Element `json:"_deviceIdentifierSystem,omitempty"`

	// Extensions for issuer
	Issuer *Element `json:"_issuer,omitempty"`

	// Extensions for jurisdiction
	Jurisdiction *Element `json:"_jurisdiction,omitempty"`

	// The identifier that is to be associated with every Device that references this
	// DeviceDefintiion for the issuer and jurisdiction provided in the
	// DeviceDefinition.udiDeviceIdentifier.
	DeviceIdentifier_2 *String `json:"deviceIdentifier,omitempty"`

	// Establishes the namespace for the issuing agency's system (e.g, GS1's GTIN,
	// ICCBBA's ISBT-128) used to create the device identifier.
	DeviceIdentifierSystem_2 *Uri `json:"deviceIdentifierSystem,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The organization that assigns the identifier algorithm.
	Issuer_2 *Uri `json:"issuer,omitempty"`

	// The jurisdiction to which the deviceIdentifier applies.
	Jurisdiction_2 *Uri `json:"jurisdiction,omitempty"`

	// Indicates where and when the device is available on the market.
	MarketDistribution []DeviceDefinitionMarketDistribution `json:"marketDistribution,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DeviceDefinition: required")
	}
	type Plain DeviceDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = DeviceDefinition(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceDeviceVersion struct {
	// Extensions for installDate
	InstallDate *Element `json:"_installDate,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// The hardware or software module of the device to which the version applies.
	Component *Identifier `json:"component,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The date the version was installed on the device.
	InstallDate_2 *DateTime `json:"installDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of the device version, e.g. manufacturer, approved, internal.
	Type *CodeableConcept `json:"type,omitempty"`

	// The version text.
	Value_2 *String `json:"value,omitempty"`
}

// Describes a measurement, calculation or setting capability of a device.
type DeviceMetric struct {
	// Extensions for color
	Color *Element `json:"_color,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for operationalStatus
	OperationalStatus *Element `json:"_operationalStatus,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Indicates whether the metric is derived (measured) by a continuous means or by
	// an intermittent means.
	Availability *CodeableConcept `json:"availability,omitempty"`

	// Describes the calibrations that have been performed or that are required to be
	// performed.
	Calibration []DeviceMetricCalibration `json:"calibration,omitempty"`

	// Indicates the category of the observation generation process. A DeviceMetric
	// can be, for example, a setting, measurement, or calculation.
	Category CodeableConcept `json:"category"`

	// The preferred color associated with the metric (e.g., display color). This is
	// often used to aid clinicians to track and identify parameter types by color. In
	// practice, consider a Patient Monitor that has ECG/HR and Pleth; the metrics are
	// displayed in different characteristic colors, such as HR in blue, BP in green,
	// and PR and SpO2 in magenta.
	Color_2 *Code `json:"color,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceMetricContainedElem `json:"contained,omitempty"`

	// The device to which this DeviceMetric applies. The referenced device could be a
	// top-level device or a component of a device.
	Device Reference `json:"device"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Instance identifiers assigned to a device, by the device or gateway software,
	// manufacturers, other organizations or owners. For example, handle ID.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The frequency at which the metric is taken or recorded. Devices measure metrics
	// at a wide range of frequencies; for example, an ECG might sample measurements
	// in the millisecond range, while an NIBP might trigger only once an hour. Less
	// often, the measurementFrequency is based on a unit other than time, such as
	// distance (e.g., for a measuring wheel). The update period could be different
	// than the measurement frequency, if the device does not update the published
	// observed value with the same frequency as it was measured.
	MeasurementFrequency *Quantity `json:"measurementFrequency,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates current operational state of the device. For example: On, Off,
	// Standby, etc.
	OperationalStatus_2 *Code `json:"operationalStatus,omitempty"`

	// This is a DeviceMetric resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates current state of the record.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc.
	Type CodeableConcept `json:"type"`

	// Describes the unit that an observed value determined for this metric will have.
	// For example: Percent, Seconds, etc.
	Unit *CodeableConcept `json:"unit,omitempty"`
}

// Describes a measurement, calculation or setting capability of a device.
type DeviceMetricCalibration struct {
	// Extensions for state
	State *Element `json:"_state,omitempty"`

	// Extensions for time
	Time *Element `json:"_time,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Describes the state of the calibration.
	State_2 *Code `json:"state,omitempty"`

	// Describes the time last calibration has been performed.
	Time_2 *Instant `json:"time,omitempty"`

	// Describes the type of the calibration method.
	Type *CodeableConcept `json:"type,omitempty"`
}

type DeviceMetricContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceMetric) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in DeviceMetric: required")
	}
	if _, ok := raw["device"]; raw != nil && !ok {
		return fmt.Errorf("field device in DeviceMetric: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DeviceMetric: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceMetric: required")
	}
	type Plain DeviceMetric
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceMetric(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceName struct {
	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Indicates the default or preferred name to be displayed.
	Display_2 *Boolean `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the kind of name. RegisteredName | UserFriendlyName |
	// PatientReportedName.
	Type CodeableConcept `json:"type"`

	// The actual name that identifies the device.
	Value_2 *String `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceName) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceName: required")
	}
	type Plain DeviceName
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DeviceName(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Code that specifies the property, such as resolution, color, size, being
	// represented.
	Type CodeableConcept `json:"type"`

	// The value of the property specified by the associated property.type code.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value of the property specified by the associated property.type code.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DeviceProperty: required")
	}
	type Plain DeviceProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = DeviceProperty(plain)
	return nil
}

// Represents a request for a patient to employ a medical device. The device may be
// an implantable device, or an external assistive device, such as a walker.
type DeviceRequest struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for productCanonical
	ProductCanonical *Element `json:"_productCanonical,omitempty"`

	// Extensions for quantity
	Quantity *Element `json:"_quantity,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// This status is to indicate whether the request is a PRN or may be given as
	// needed.
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// The reason for using the device.
	AsNeededFor *CodeableConcept `json:"asNeededFor,omitempty"`

	// When the request transitioned to being actionable.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// Plan/proposal/order fulfilled by this request.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DeviceRequestContainedElem `json:"contained,omitempty"`

	// If true, indicates that the provider is asking for the patient to either stop
	// using or to not start using the specified device or category of devices. For
	// example, the patient has undergone surgery and the provider is indicating that
	// the patient should not wear contact lenses.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// An encounter that provides additional context in which this request is made.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A shared identifier common to multiple independent Request instances that were
	// activated/authorized more or less simultaneously by a single author.  The
	// presence of the same identifier on each request ties those requests together
	// and may have business ramifications in terms of reporting of results, billing,
	// etc.  E.g. a requisition number shared by a set of lab tests ordered together,
	// or a prescription number shared by all meds ordered at one time.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this order by the orderer or by the receiver.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Insurance plans, coverage extensions, pre-authorizations and/or
	// pre-determinations that may be required for delivering the requested service.
	Insurance []Reference `json:"insurance,omitempty"`

	// Whether the request is a proposal, plan, an original order or a reflex order.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The preferred location(s) where the device should actually be used in coded or
	// free text form. E.g. at home or nursing day care center.
	Location []CodeableReference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Details about this request that were not represented at all or sufficiently in
	// one of the attributes provided in a class. These may include for example a
	// comment, an instruction, or a note associated with the statement.
	Note []Annotation `json:"note,omitempty"`

	// The timing schedule for the use of the device. The Schedule data type allows
	// many different expressions, for example. "Every 8 hours"; "Three times a day";
	// "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17
	// Oct 2013 and 1 Nov 2013".
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The timing schedule for the use of the device. The Schedule data type allows
	// many different expressions, for example. "Every 8 hours"; "Three times a day";
	// "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17
	// Oct 2013 and 1 Nov 2013".
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// The timing schedule for the use of the device. The Schedule data type allows
	// many different expressions, for example. "Every 8 hours"; "Three times a day";
	// "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17
	// Oct 2013 and 1 Nov 2013".
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`

	// Specific parameters for the ordered item.  For example, the prism value for
	// lenses.
	Parameter []DeviceRequestParameter `json:"parameter,omitempty"`

	// The desired individual or entity to provide the device to the subject of the
	// request (e.g., patient, location).
	Performer *CodeableReference `json:"performer,omitempty"`

	// Indicates how quickly the request should be addressed with respect to other
	// requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// The details of the device to be used.
	ProductCanonical_2 *string `json:"productCanonical,omitempty"`

	// The details of the device to be used.
	ProductCodeableConcept *CodeableConcept `json:"productCodeableConcept,omitempty"`

	// The details of the device to be used.
	ProductReference *Reference `json:"productReference,omitempty"`

	// The number of devices to be provided.
	Quantity_2 *Integer `json:"quantity,omitempty"`

	// Reason or justification for the use of this device.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Key events in the history of the request.
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`

	// The request takes the place of the referenced completed or terminated
	// request(s).
	Replaces []Reference `json:"replaces,omitempty"`

	// The individual or entity who initiated the request and has responsibility for
	// its activation.
	Requester *Reference `json:"requester,omitempty"`

	// This is a DeviceRequest resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the request.
	Status_2 *Code `json:"status,omitempty"`

	// The patient who will use the device.
	Subject Reference `json:"subject"`

	// Additional clinical information about the patient that may influence the
	// request fulfilment.  For example, this may include where on the subject's body
	// the device will be used (i.e. the target site).
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type DeviceRequestContainedElem interface{}

// Represents a request for a patient to employ a medical device. The device may be
// an implantable device, or an external assistive device, such as a walker.
type DeviceRequestParameter struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// A code or string that identifies the device detail being asserted.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The value of the device detail.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the device detail.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the device detail.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the device detail.
	ValueRange *Range `json:"valueRange,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeviceRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DeviceRequest: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in DeviceRequest: required")
	}
	type Plain DeviceRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ProductCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ProductCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ProductCanonical_2", `^\S*$`)
		}
	}
	*j = DeviceRequest(plain)
	return nil
}

// A manufactured item that is used in the provision of healthcare without being
// substantially changed through that activity. The device may be a medical or
// non-medical device.
type DeviceUdiCarrier struct {
	// Extensions for carrierAIDC
	CarrierAIDC *Element `json:"_carrierAIDC,omitempty"`

	// Extensions for carrierHRF
	CarrierHRF *Element `json:"_carrierHRF,omitempty"`

	// Extensions for deviceIdentifier
	DeviceIdentifier *Element `json:"_deviceIdentifier,omitempty"`

	// Extensions for deviceIdentifierSystem
	DeviceIdentifierSystem *Element `json:"_deviceIdentifierSystem,omitempty"`

	// Extensions for entryType
	EntryType *Element `json:"_entryType,omitempty"`

	// Extensions for issuer
	Issuer *Element `json:"_issuer,omitempty"`

	// Extensions for jurisdiction
	Jurisdiction *Element `json:"_jurisdiction,omitempty"`

	// The full UDI carrier of the Automatic Identification and Data Capture (AIDC)
	// technology representation as printed on the packaging of the device - e.g., a
	// barcode , 2D Matrix, or RFID. Some AIDC representations contain non-printable
	// characters and cannot be represented in a string format.  For this reason, AIDC
	// format SHALL be base64Binary encoded.
	CarrierAIDC_2 *Base64Binary `json:"carrierAIDC,omitempty"`

	// The full UDI carrier as the human readable form (HRF) representation as printed
	// on the packaging of the device.
	CarrierHRF_2 *String `json:"carrierHRF,omitempty"`

	// The device identifier (UDI-DI) is a mandatory, fixed portion of a UDI that
	// identifies the labeler and the specific version or model of a device. The
	// UDI-DI portion is placed on a device label or package. Note that the
	// DeviceDefinition may include multiple UDI-DIs if it is sold in multiple
	// jurisdictions.
	DeviceIdentifier_2 *String `json:"deviceIdentifier,omitempty"`

	// Establishes the namespace for the issuing agency's system (e.g, GS1's GTIN,
	// ICCBBA's ISBT-128) used to create the device identifier.
	DeviceIdentifierSystem_2 *Uri `json:"deviceIdentifierSystem,omitempty"`

	// A coded entry to indicate how the data was entered.
	EntryType_2 *Code `json:"entryType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Organization that is charged with issuing UDIs for devices. For example, the US
	// FDA issuers include:
	// 1) GS1: http://hl7.org/fhir/NamingSystem/gs1-di,
	// 2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-diI,
	// 3) ICCBBA for blood containers:
	// http://hl7.org/fhir/NamingSystem/iccbba-blood-di,
	// 4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di #
	// Informationsstelle fÃ¼r ArzneispezialitÃ¤ten (IFA GmbH) (EU only):
	// http://hl7.org/fhir/NamingSystem/ifa-gmbh-di.
	Issuer_2 *Uri `json:"issuer,omitempty"`

	// The identity of the authoritative source for UDI generation within a
	// jurisdiction. All UDIs are globally unique within a single namespace with the
	// appropriate repository uri as the system. For example, UDIs of devices managed
	// in the U.S. by the FDA, the value is
	// http://hl7.org/fhir/NamingSystem/us-fda-udi or in the European Union by the
	// European Commission http://hl7.org/fhir/NamingSystem/eu-ec-udi.
	Jurisdiction_2 *Uri `json:"jurisdiction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Device) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Device: required")
	}
	type Plain Device
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Device(plain)
	return nil
}

// The findings and interpretation of diagnostic tests performed on patients,
// groups of patients, products, substances, devices, and locations, and/or
// specimens derived from these. The report includes clinical context such as
// requesting provider information, and some mix of atomic results, images, textual
// and coded interpretations, and formatted representation of diagnostic reports.
// The report also includes non-clinical context such as batch analysis and
// stability reporting of products and substances.
type DiagnosticReport struct {
	// Extensions for conclusion
	Conclusion *Element `json:"_conclusion,omitempty"`

	// Extensions for effectiveDateTime
	EffectiveDateTime *Element `json:"_effectiveDateTime,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for issued
	Issued *Element `json:"_issued,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Details concerning a service requested.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// A code that classifies the clinical discipline, department or diagnostic
	// service that created the report (e.g. cardiology, biochemistry, hematology,
	// MRI). This is used for searching, sorting and display purposes.
	Category []CodeableConcept `json:"category,omitempty"`

	// A code or name that describes this diagnostic report.
	Code CodeableConcept `json:"code"`

	// Communications initiated during the generation of the DiagnosticReport by
	// members of the organization fulfilling that order. e.g. direct communication of
	// time critical results by the radiologist to the referring physician.
	Communication []Reference `json:"communication,omitempty"`

	// Prior data and findings made available for comparison when determining the
	// current interpretation.
	Comparison *Reference `json:"comparison,omitempty"`

	// Reference to a Composition resource instance that provides structure for
	// organizing the contents of the DiagnosticReport.
	Composition *Reference `json:"composition,omitempty"`

	// Concise and clinically contextualized summary conclusion
	// (interpretation/impression) of the diagnostic report.
	Conclusion_2 *Markdown `json:"conclusion,omitempty"`

	// One or more codes and/or references that represent the summary conclusion
	// (interpretation/impression) of the diagnostic report.
	ConclusionCode []CodeableReference `json:"conclusionCode,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DiagnosticReportContainedElem `json:"contained,omitempty"`

	// The time or time-period the observed values are related to. When the subject of
	// the report is a patient, this is usually either the time of the procedure or of
	// specimen collection(s), but very often the source of the date/time is not
	// known, only the date/time itself.
	EffectiveDateTime_2 *string `json:"effectiveDateTime,omitempty"`

	// The time or time-period the observed values are related to. When the subject of
	// the report is a patient, this is usually either the time of the procedure or of
	// specimen collection(s), but very often the source of the date/time is not
	// known, only the date/time itself.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// The encounter (e.g. a patient and healthcare provider interaction) that is
	// associated with the DiagnosticReport.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this report by the performer or other systems.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The date and time that this version of the report was made available to
	// providers, typically after the report was reviewed and verified.
	Issued_2 *DateTime `json:"issued,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A list of key images or data associated with this report. The images or data
	// are generally created during the diagnostic process, and may be directly of the
	// patient, or of treated specimens (i.e. slides of interest).
	Media []DiagnosticReportMedia `json:"media,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments about the diagnostic report.
	Note []Annotation `json:"note,omitempty"`

	// The diagnostic service that is responsible for issuing the report.
	Performer []Reference `json:"performer,omitempty"`

	// Rich text representation of the entire result as issued by the diagnostic
	// service. Multiple formats are allowed but they SHALL be semantically
	// equivalent.
	PresentedForm []Attachment `json:"presentedForm,omitempty"`

	// The performed procedure(s) that are reported on in the DiagnosticReport.
	Procedure []Reference `json:"procedure,omitempty"`

	// Proposed follow-up actions based on the findings and interpretations of the
	// diagnostic test for which this report is the subject.
	Recomendation []CodeableReference `json:"recomendation,omitempty"`

	// Other DiagnosticReports that the current DiagnosticReport replaces, amendens,
	// extends, or otherwise relates to.
	RelatesTo []RelatedArtifact `json:"relatesTo,omitempty"`

	// This is a DiagnosticReport resource
	ResourceType interface{} `json:"resourceType"`

	// [Observations](observation.html)  that are part of this diagnostic report.
	Result []Reference `json:"result,omitempty"`

	// The practitioner or organization that is responsible for the report's
	// conclusions and interpretations.
	ResultsInterpreter []Reference `json:"resultsInterpreter,omitempty"`

	// Details about the specimens on which this diagnostic report is based.
	Specimen []Reference `json:"specimen,omitempty"`

	// The status of the diagnostic report.
	Status_2 *Code `json:"status,omitempty"`

	// One or more links to full details of any study performed during the diagnostic
	// investigation. An ImagingStudy might comprise a set of radiologic images
	// obtained via a procedure that are analyzed as a group. Typically, this is
	// imaging performed by DICOM enabled modalities, but this is not required. A
	// fully enabled PACS viewer can use this information to provide views of the
	// source images. A GenomicStudy might comprise one or more analyses, each serving
	// a specific purpose. These analyses may vary in method (e.g., karyotyping, CNV,
	// or SNV detection), performer, software, devices used, or regions targeted.
	Study []Reference `json:"study,omitempty"`

	// The subject of the report. Usually, but not always, this is a patient. However,
	// diagnostic services also perform analyses on specimens collected from a variety
	// of other sources.
	Subject *Reference `json:"subject,omitempty"`

	// This backbone element contains supporting information that was used in the
	// creation of the report not included in the results already included in the
	// report.
	SupportingInfo []DiagnosticReportSupportingInfo `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type DiagnosticReportContainedElem interface{}

// The findings and interpretation of diagnostic tests performed on patients,
// groups of patients, products, substances, devices, and locations, and/or
// specimens derived from these. The report includes clinical context such as
// requesting provider information, and some mix of atomic results, images, textual
// and coded interpretations, and formatted representation of diagnostic reports.
// The report also includes non-clinical context such as batch analysis and
// stability reporting of products and substances.
type DiagnosticReportMedia struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// A comment about the image or data. Typically, this is used to provide an
	// explanation for why the image or data is included, or to draw the viewer's
	// attention to important features.
	Comment_2 *String `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Reference to the image or data source.
	Link Reference `json:"link"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiagnosticReportMedia) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["link"]; raw != nil && !ok {
		return fmt.Errorf("field link in DiagnosticReportMedia: required")
	}
	type Plain DiagnosticReportMedia
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DiagnosticReportMedia(plain)
	return nil
}

// The findings and interpretation of diagnostic tests performed on patients,
// groups of patients, products, substances, devices, and locations, and/or
// specimens derived from these. The report includes clinical context such as
// requesting provider information, and some mix of atomic results, images, textual
// and coded interpretations, and formatted representation of diagnostic reports.
// The report also includes non-clinical context such as batch analysis and
// stability reporting of products and substances.
type DiagnosticReportSupportingInfo struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The reference for the supporting information in the diagnostic report.
	Reference Reference `json:"reference"`

	// The code value for the role of the supporting information in the diagnostic
	// report.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiagnosticReportSupportingInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in DiagnosticReportSupportingInfo: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DiagnosticReportSupportingInfo: required")
	}
	type Plain DiagnosticReportSupportingInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DiagnosticReportSupportingInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiagnosticReport) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in DiagnosticReport: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DiagnosticReport: required")
	}
	type Plain DiagnosticReport
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EffectiveDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.EffectiveDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectiveDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = DiagnosticReport(plain)
	return nil
}

// A length - a value with a unit that is a physical distance.
type Distance struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A computer processable form of the unit in some unit representation system.
	Code_2 *Code `json:"code,omitempty"`

	// How the value should be understood and represented - whether the actual value
	// is greater or less than the stated value due to measurement issues; e.g. if the
	// comparator is "<" , then the real value is < stated value.
	Comparator_2 *DistanceComparator_2 `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the system that provides the coded form of the unit.
	System_2 *Uri `json:"system,omitempty"`

	// A human-readable form of the unit.
	Unit_2 *String `json:"unit,omitempty"`

	// The value of the measured amount. The value includes an implicit precision in
	// the presentation of the value.
	Value_2 *Decimal `json:"value,omitempty"`
}

type DistanceComparator_2 string

const DistanceComparator_2_Ad DistanceComparator_2 = "ad"
const DistanceComparator_2_LE DistanceComparator_2 = "<="
const DistanceComparator_2_GE DistanceComparator_2 = ">="
const DistanceComparator_2_GT DistanceComparator_2 = ">"
const DistanceComparator_2_LT DistanceComparator_2 = "<"

var enumValues_DistanceComparator_2 = []interface{}{
	"<",
	"<=",
	">=",
	">",
	"ad",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistanceComparator_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DistanceComparator_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DistanceComparator_2, v)
	}
	*j = DistanceComparator_2(v)
	return nil
}

// A reference to a document of any kind for any purpose. While the term â€œdocumentâ€
// implies a more narrow focus, for this resource this "document" encompasses *any*
// serialized object with a mime-type, it includes formal patient-centric documents
// (CDA), clinical notes, scanned paper, non-patient specific documents like policy
// text, as well as a photo, video, or audio recording acquired or used in
// healthcare.  The DocumentReference resource provides metadata about the document
// so that the document can be discovered and managed.  The actual content may be
// inline base64 encoded data or provided by direct reference.
type DocumentReference struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for docStatus
	DocStatus *Element `json:"_docStatus,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// A participant who has authenticated the accuracy of the document.
	Attester []DocumentReferenceAttester `json:"attester,omitempty"`

	// Identifies who is responsible for adding the information to the document.
	Author []Reference `json:"author,omitempty"`

	// A procedure that is fulfilled in whole or in part by the creation of this
	// media.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The anatomic structures included in the document.
	BodyStructure []CodeableReference `json:"bodyStructure,omitempty"`

	// A categorization for the type of document referenced - helps for indexing and
	// searching. This may be implied by or derived from the code specified in the
	// DocumentReference.type.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []DocumentReferenceContainedElem `json:"contained,omitempty"`

	// The document and format referenced.  If there are multiple content element
	// repetitions, these must all represent the same document in different format, or
	// attachment metadata.
	Content []DocumentReferenceContent `json:"content"`

	// The Encounter during which this document reference was created or to which the
	// creation of this record is tightly associated.
	Context []Reference `json:"context,omitempty"`

	// Identifies the organization or group who is responsible for ongoing maintenance
	// of and access to the document.
	Custodian *Reference `json:"custodian,omitempty"`

	// When the document reference was created.
	Date_2 *DateTime `json:"date,omitempty"`

	// Human-readable description of the source document.
	Description_2 *Markdown `json:"description,omitempty"`

	// The status of the underlying document.
	DocStatus_2 *Code `json:"docStatus,omitempty"`

	// This list of codes represents the main clinical acts, such as a colonoscopy or
	// an appendectomy, being documented. In some cases, the event is inherent in the
	// type Code, such as a "History and Physical Report" in which the procedure being
	// documented is necessarily a "History and Physical" act.
	Event []CodeableReference `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The kind of facility where the patient was seen.
	FacilityType *CodeableConcept `json:"facilityType,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this document reference by the performer
	// and/or other systems.  These identifiers remain constant as the resource is
	// updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// Imaging modality used. This may include both acquisition and non-acquisition
	// modalities.
	Modality []CodeableConcept `json:"modality,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time period over which the service that is described by the document was
	// provided.
	Period *Period `json:"period,omitempty"`

	// This property may convey specifics about the practice setting where the content
	// was created, often reflecting the clinical specialty.
	PracticeSetting *CodeableConcept `json:"practiceSetting,omitempty"`

	// Any other resource this document reference was created or to which the creation
	// of this record is tightly associated.
	Related []Reference `json:"related,omitempty"`

	// Relationships that this document has with other document references that
	// already exist.
	RelatesTo []DocumentReferenceRelatesTo `json:"relatesTo,omitempty"`

	// This is a DocumentReference resource
	ResourceType interface{} `json:"resourceType"`

	// A set of Security-Tag codes specifying the level of privacy/security of the
	// Document found at DocumentReference.content.attachment.url. Note that
	// DocumentReference.meta.security contains the security labels of the data
	// elements in DocumentReference, while DocumentReference.securityLabel contains
	// the security labels for the document the reference refers to. The distinction
	// recognizes that the document may contain sensitive information, while the
	// DocumentReference is metadata about the document and thus might not be as
	// sensitive as the document. For example: a psychotherapy episode may contain
	// highly sensitive information, while the metadata may simply indicate that some
	// episode happened.
	SecurityLabel []CodeableConcept `json:"securityLabel,omitempty"`

	// The current state of the document reference.
	Status_2 *Code `json:"status,omitempty"`

	// Who or what the document is about. The document can be about a person, (patient
	// or healthcare practitioner), a device (e.g. a machine) or even a group of
	// subjects (such as a document about a herd of farm animals, or a set of patients
	// that share a common exposure).
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Specifies the particular kind of document referenced  (e.g. History and
	// Physical, Discharge Summary, Progress Note). This usually equates to the
	// purpose of making the document referenced.
	Type *CodeableConcept `json:"type,omitempty"`

	// An explicitly assigned identifier of a variation of the content in the
	// DocumentReference.
	Version_2 *String `json:"version,omitempty"`
}

// A reference to a document of any kind for any purpose. While the term â€œdocumentâ€
// implies a more narrow focus, for this resource this "document" encompasses *any*
// serialized object with a mime-type, it includes formal patient-centric documents
// (CDA), clinical notes, scanned paper, non-patient specific documents like policy
// text, as well as a photo, video, or audio recording acquired or used in
// healthcare.  The DocumentReference resource provides metadata about the document
// so that the document can be discovered and managed.  The actual content may be
// inline base64 encoded data or provided by direct reference.
type DocumentReferenceAttester struct {
	// Extensions for time
	Time *Element `json:"_time,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The type of attestation the authenticator offers.
	Mode CodeableConcept `json:"mode"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Who attested the document in the specified way.
	Party *Reference `json:"party,omitempty"`

	// When the document was attested by the party.
	Time_2 *DateTime `json:"time,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentReferenceAttester) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["mode"]; raw != nil && !ok {
		return fmt.Errorf("field mode in DocumentReferenceAttester: required")
	}
	type Plain DocumentReferenceAttester
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DocumentReferenceAttester(plain)
	return nil
}

type DocumentReferenceContainedElem interface{}

// A reference to a document of any kind for any purpose. While the term â€œdocumentâ€
// implies a more narrow focus, for this resource this "document" encompasses *any*
// serialized object with a mime-type, it includes formal patient-centric documents
// (CDA), clinical notes, scanned paper, non-patient specific documents like policy
// text, as well as a photo, video, or audio recording acquired or used in
// healthcare.  The DocumentReference resource provides metadata about the document
// so that the document can be discovered and managed.  The actual content may be
// inline base64 encoded data or provided by direct reference.
type DocumentReferenceContent struct {
	// The document or URL of the document along with critical metadata to prove
	// content has integrity.
	Attachment Attachment `json:"attachment"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An identifier of the document constraints, encoding, structure, and template
	// that the document conforms to beyond the base format indicated in the mimeType.
	Profile []DocumentReferenceProfile `json:"profile,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentReferenceContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["attachment"]; raw != nil && !ok {
		return fmt.Errorf("field attachment in DocumentReferenceContent: required")
	}
	type Plain DocumentReferenceContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DocumentReferenceContent(plain)
	return nil
}

// A reference to a document of any kind for any purpose. While the term â€œdocumentâ€
// implies a more narrow focus, for this resource this "document" encompasses *any*
// serialized object with a mime-type, it includes formal patient-centric documents
// (CDA), clinical notes, scanned paper, non-patient specific documents like policy
// text, as well as a photo, video, or audio recording acquired or used in
// healthcare.  The DocumentReference resource provides metadata about the document
// so that the document can be discovered and managed.  The actual content may be
// inline base64 encoded data or provided by direct reference.
type DocumentReferenceProfile struct {
	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Code|uri|canonical.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Code|uri|canonical.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Code|uri|canonical.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentReferenceProfile) UnmarshalJSON(value []byte) error {
	type Plain DocumentReferenceProfile
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = DocumentReferenceProfile(plain)
	return nil
}

// A reference to a document of any kind for any purpose. While the term â€œdocumentâ€
// implies a more narrow focus, for this resource this "document" encompasses *any*
// serialized object with a mime-type, it includes formal patient-centric documents
// (CDA), clinical notes, scanned paper, non-patient specific documents like policy
// text, as well as a photo, video, or audio recording acquired or used in
// healthcare.  The DocumentReference resource provides metadata about the document
// so that the document can be discovered and managed.  The actual content may be
// inline base64 encoded data or provided by direct reference.
type DocumentReferenceRelatesTo struct {
	// The type of relationship that this document has with anther document.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The target document of this relationship.
	Target Reference `json:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentReferenceRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in DocumentReferenceRelatesTo: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in DocumentReferenceRelatesTo: required")
	}
	type Plain DocumentReferenceRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DocumentReferenceRelatesTo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in DocumentReference: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in DocumentReference: required")
	}
	type Plain DocumentReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DocumentReference(plain)
	return nil
}

// Indicates how the medication is/was taken or should be taken by the patient.
type Dosage struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Extensions for patientInstruction
	PatientInstruction *Element `json:"_patientInstruction,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Supplemental instructions to the patient on how to take the medication  (e.g.
	// "with meals" or"take half to one hour before food") or warnings for the patient
	// about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to
	// direct sunlight or sunlamps").
	AdditionalInstruction []CodeableConcept `json:"additionalInstruction,omitempty"`

	// Indicates whether the Medication is only taken when needed within a specific
	// dosing schedule (Boolean option).
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// Indicates whether the Medication is only taken based on a precondition for
	// taking the Medication (CodeableConcept).
	AsNeededFor []CodeableConcept `json:"asNeededFor,omitempty"`

	// Whether the dosage applies (e.g. as a whole). The Disage applies if any of the
	// conditions are true.
	Condition []DosageCondition `json:"condition,omitempty"`

	// Depending on the resource,this is the amount of medication administered, to  be
	// administered or typical amount to be administered.
	DoseAndRate []DosageDoseAndRate `json:"doseAndRate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Technique for administering medication.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Instructions in terms that are understood by the patient or consumer.
	PatientInstruction_2 *String `json:"patientInstruction,omitempty"`

	// How drug should enter body.
	Route *CodeableConcept `json:"route,omitempty"`

	// Safety Information about the this dosage instructions.
	Safety *DosageSafety `json:"safety,omitempty"`

	// Body site to administer to.
	Site *CodeableConcept `json:"site,omitempty"`

	// Free text dosage instructions e.g. SIG.
	Text_2 *String `json:"text,omitempty"`

	// When medication should be administered.
	Timing *Timing `json:"timing,omitempty"`
}

// DosageCondition expresses a time or time period as relative to the time of an
// event defined in data types other than dateTime.
type DosageCondition struct {
	// Extensions for operation
	Operation *Element `json:"_operation,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// The specific event occurrence or resource context used as a base point
	// (reference point) in time.  This establishes the context in which the 'path' is
	// evaluated.
	Code CodeableConcept `json:"code"`

	// Additional details about the event - depends on the code.
	Details *CodeableConcept `json:"details,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// How the value is tested.
	Operation_2 *Code `json:"operation,omitempty"`

	// Free-text (human-readable) description.
	Text_2 *String `json:"text,omitempty"`

	// The value for this critera.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// The value for this critera.
	ValueAge *Age `json:"valueAge,omitempty"`

	// The value for this critera.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// The value for this critera.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The value for this critera.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// The value for this critera.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The value for this critera.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value for this critera.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// The value for this critera.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value for this critera.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value for this critera.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// The value for this critera.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value for this critera.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// The value for this critera.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// The value for this critera.
	ValueCount *Count `json:"valueCount,omitempty"`

	// The value for this critera.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// The value for this critera.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The value for this critera.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value for this critera.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value for this critera.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// The value for this critera.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// The value for this critera.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The value for this critera.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// The value for this critera.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// The value for this critera.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// The value for this critera.
	ValueID_2 *string `json:"valueId,omitempty"`

	// The value for this critera.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// The value for this critera.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// The value for this critera.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value for this critera.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// The value for this critera.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// The value for this critera.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// The value for this critera.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// The value for this critera.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// The value for this critera.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// The value for this critera.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The value for this critera.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// The value for this critera.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value for this critera.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value for this critera.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The value for this critera.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// The value for this critera.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The value for this critera.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// The value for this critera.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The value for this critera.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// The value for this critera.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The value for this critera.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The value for this critera.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// The value for this critera.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// The value for this critera.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// The value for this critera.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// The value for this critera.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// The value for this critera.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// The value for this critera.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// The value for this critera.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DosageCondition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in DosageCondition: required")
	}
	type Plain DosageCondition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = DosageCondition(plain)
	return nil
}

// Indicates how the medication is/was taken or should be taken by the patient.
type DosageDetails struct {
	// Extensions for renderedInstruction
	RenderedInstruction *Element `json:"_renderedInstruction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The full representation of the dose of the medication included in all dosage
	// instructions.  To be used when multiple dosage instructions are included to
	// represent complex dosing such as increasing or tapering doses.
	RenderedInstruction_2 *Markdown `json:"renderedInstruction,omitempty"`

	// Safety Information about the combined dose course.
	Safety *DosageSafety `json:"safety,omitempty"`

	// Dosage details if it is a simple dose - a single dosage regime with no
	// dependencies or multiple steps.
	Simple *Dosage `json:"simple,omitempty"`

	// One step in a sequence of steps that comprise the dosage course.
	Step []DosageDetailsStep `json:"step,omitempty"`
}

// Indicates how the medication is/was taken or should be taken by the patient.
type DosageDetailsStep struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// A dosage details that is part of this step.
	Component []Dosage `json:"component"`

	// How many times to do this step (if not 1).
	Count_2 *Integer `json:"count,omitempty"`

	// When the step ends. In the absence of a linked event, the step is assumed to
	// end when the internal timing schedule termnates.
	End *RelativeTime `json:"end,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Safety Information about this step of the dose course.
	Safety *DosageSafety `json:"safety,omitempty"`

	// When the step starts. In the absence of a linked event, the step is assumed to
	// start immediately (or after the previous step).
	Start *RelativeTime `json:"start,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DosageDetailsStep) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["component"]; raw != nil && !ok {
		return fmt.Errorf("field component in DosageDetailsStep: required")
	}
	type Plain DosageDetailsStep
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DosageDetailsStep(plain)
	return nil
}

// Indicates how the medication is/was taken or should be taken by the patient.
type DosageDoseAndRate struct {
	// Amount of medication per dose.
	DoseExpression *Expression `json:"doseExpression,omitempty"`

	// Amount of medication per dose.
	DoseQuantity *Quantity `json:"doseQuantity,omitempty"`

	// Amount of medication per dose.
	DoseRange *Range `json:"doseRange,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Amount of medication per unit of time.
	RateExpression *Expression `json:"rateExpression,omitempty"`

	// Amount of medication per unit of time.
	RateQuantity *Quantity `json:"rateQuantity,omitempty"`

	// Amount of medication per unit of time.
	RateRange *Range `json:"rateRange,omitempty"`

	// Amount of medication per unit of time.
	RateRatio *Ratio `json:"rateRatio,omitempty"`

	// The kind of dose or rate specified, for example, ordered or calculated.
	Type *CodeableConcept `json:"type,omitempty"`
}

// Safety Details about the usage of the medication.
type DosageSafety struct {
	// Extensions for ifExceeded
	IfExceeded *Element `json:"_ifExceeded,omitempty"`

	// A dose limit for safe use of the medication.
	DoseLimit []DosageSafetyDoseLimit `json:"doseLimit,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// What to do if the instructions lead to exceeding the dose limits.
	IfExceeded_2 *String `json:"ifExceeded,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Safety Details about the usage of the medication.
type DosageSafetyDoseLimit struct {
	// Extensions for scope
	Scope *Element `json:"_scope,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period over which the quantity is safe to use (if scope = period).
	Period *Duration `json:"period,omitempty"`

	// dosage | period | administration | lifetime - The scope of the dose limitation.
	Scope_2 *Code `json:"scope,omitempty"`

	// Additional notes about the dose limit.
	Text_2 *String `json:"text,omitempty"`

	// Quantity that is safe to use.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Quantity that is safe to use.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Quantity that is safe to use.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
}

// A length of time.
type Duration struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A computer processable form of the unit in some unit representation system.
	Code_2 *Code `json:"code,omitempty"`

	// How the value should be understood and represented - whether the actual value
	// is greater or less than the stated value due to measurement issues; e.g. if the
	// comparator is "<" , then the real value is < stated value.
	Comparator_2 *DurationComparator_2 `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the system that provides the coded form of the unit.
	System_2 *Uri `json:"system,omitempty"`

	// A human-readable form of the unit.
	Unit_2 *String `json:"unit,omitempty"`

	// The value of the measured amount. The value includes an implicit precision in
	// the presentation of the value.
	Value_2 *Decimal `json:"value,omitempty"`
}

type DurationComparator_2 string

const DurationComparator_2_Ad DurationComparator_2 = "ad"
const DurationComparator_2_GE DurationComparator_2 = ">="
const DurationComparator_2_LE DurationComparator_2 = "<="
const DurationComparator_2_LT DurationComparator_2 = "<"
const DurationComparator_2_GT DurationComparator_2 = ">"

var enumValues_DurationComparator_2 = []interface{}{
	"<",
	"<=",
	">=",
	">",
	"ad",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DurationComparator_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DurationComparator_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DurationComparator_2, v)
	}
	*j = DurationComparator_2(v)
	return nil
}

// Base definition for all elements in a resource.
type Element struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinition struct {
	// Extensions for alias
	Alias []Element `json:"_alias,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for condition
	Condition []Element `json:"_condition,omitempty"`

	// Extensions for contentReference
	ContentReference *Element `json:"_contentReference,omitempty"`

	// Extensions for defaultValueBase64Binary
	DefaultValueBase64Binary *Element `json:"_defaultValueBase64Binary,omitempty"`

	// Extensions for defaultValueBoolean
	DefaultValueBoolean *Element `json:"_defaultValueBoolean,omitempty"`

	// Extensions for defaultValueCanonical
	DefaultValueCanonical *Element `json:"_defaultValueCanonical,omitempty"`

	// Extensions for defaultValueCode
	DefaultValueCode *Element `json:"_defaultValueCode,omitempty"`

	// Extensions for defaultValueDate
	DefaultValueDate *Element `json:"_defaultValueDate,omitempty"`

	// Extensions for defaultValueDateTime
	DefaultValueDateTime *Element `json:"_defaultValueDateTime,omitempty"`

	// Extensions for defaultValueDecimal
	DefaultValueDecimal *Element `json:"_defaultValueDecimal,omitempty"`

	// Extensions for defaultValueId
	DefaultValueID *Element `json:"_defaultValueId,omitempty"`

	// Extensions for defaultValueInstant
	DefaultValueInstant *Element `json:"_defaultValueInstant,omitempty"`

	// Extensions for defaultValueInteger
	DefaultValueInteger *Element `json:"_defaultValueInteger,omitempty"`

	// Extensions for defaultValueInteger64
	DefaultValueInteger64 *Element `json:"_defaultValueInteger64,omitempty"`

	// Extensions for defaultValueMarkdown
	DefaultValueMarkdown *Element `json:"_defaultValueMarkdown,omitempty"`

	// Extensions for defaultValueOid
	DefaultValueOid *Element `json:"_defaultValueOid,omitempty"`

	// Extensions for defaultValuePositiveInt
	DefaultValuePositiveInt *Element `json:"_defaultValuePositiveInt,omitempty"`

	// Extensions for defaultValueString
	DefaultValueString *Element `json:"_defaultValueString,omitempty"`

	// Extensions for defaultValueTime
	DefaultValueTime *Element `json:"_defaultValueTime,omitempty"`

	// Extensions for defaultValueUnsignedInt
	DefaultValueUnsignedInt *Element `json:"_defaultValueUnsignedInt,omitempty"`

	// Extensions for defaultValueUri
	DefaultValueUri *Element `json:"_defaultValueUri,omitempty"`

	// Extensions for defaultValueUrl
	DefaultValueUrl *Element `json:"_defaultValueUrl,omitempty"`

	// Extensions for defaultValueUuid
	DefaultValueUuid *Element `json:"_defaultValueUuid,omitempty"`

	// Extensions for definition
	Definition *Element `json:"_definition,omitempty"`

	// Extensions for fixedBase64Binary
	FixedBase64Binary *Element `json:"_fixedBase64Binary,omitempty"`

	// Extensions for fixedBoolean
	FixedBoolean *Element `json:"_fixedBoolean,omitempty"`

	// Extensions for fixedCanonical
	FixedCanonical *Element `json:"_fixedCanonical,omitempty"`

	// Extensions for fixedCode
	FixedCode *Element `json:"_fixedCode,omitempty"`

	// Extensions for fixedDate
	FixedDate *Element `json:"_fixedDate,omitempty"`

	// Extensions for fixedDateTime
	FixedDateTime *Element `json:"_fixedDateTime,omitempty"`

	// Extensions for fixedDecimal
	FixedDecimal *Element `json:"_fixedDecimal,omitempty"`

	// Extensions for fixedId
	FixedID *Element `json:"_fixedId,omitempty"`

	// Extensions for fixedInstant
	FixedInstant *Element `json:"_fixedInstant,omitempty"`

	// Extensions for fixedInteger
	FixedInteger *Element `json:"_fixedInteger,omitempty"`

	// Extensions for fixedInteger64
	FixedInteger64 *Element `json:"_fixedInteger64,omitempty"`

	// Extensions for fixedMarkdown
	FixedMarkdown *Element `json:"_fixedMarkdown,omitempty"`

	// Extensions for fixedOid
	FixedOid *Element `json:"_fixedOid,omitempty"`

	// Extensions for fixedPositiveInt
	FixedPositiveInt *Element `json:"_fixedPositiveInt,omitempty"`

	// Extensions for fixedString
	FixedString *Element `json:"_fixedString,omitempty"`

	// Extensions for fixedTime
	FixedTime *Element `json:"_fixedTime,omitempty"`

	// Extensions for fixedUnsignedInt
	FixedUnsignedInt *Element `json:"_fixedUnsignedInt,omitempty"`

	// Extensions for fixedUri
	FixedUri *Element `json:"_fixedUri,omitempty"`

	// Extensions for fixedUrl
	FixedUrl *Element `json:"_fixedUrl,omitempty"`

	// Extensions for fixedUuid
	FixedUuid *Element `json:"_fixedUuid,omitempty"`

	// Extensions for isModifier
	IsModifier *Element `json:"_isModifier,omitempty"`

	// Extensions for isModifierReason
	IsModifierReason *Element `json:"_isModifierReason,omitempty"`

	// Extensions for isSummary
	IsSummary *Element `json:"_isSummary,omitempty"`

	// Extensions for label
	Label *Element `json:"_label,omitempty"`

	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for maxLength
	MaxLength *Element `json:"_maxLength,omitempty"`

	// Extensions for maxValueDate
	MaxValueDate *Element `json:"_maxValueDate,omitempty"`

	// Extensions for maxValueDateTime
	MaxValueDateTime *Element `json:"_maxValueDateTime,omitempty"`

	// Extensions for maxValueDecimal
	MaxValueDecimal *Element `json:"_maxValueDecimal,omitempty"`

	// Extensions for maxValueInstant
	MaxValueInstant *Element `json:"_maxValueInstant,omitempty"`

	// Extensions for maxValueInteger
	MaxValueInteger *Element `json:"_maxValueInteger,omitempty"`

	// Extensions for maxValueInteger64
	MaxValueInteger64 *Element `json:"_maxValueInteger64,omitempty"`

	// Extensions for maxValuePositiveInt
	MaxValuePositiveInt *Element `json:"_maxValuePositiveInt,omitempty"`

	// Extensions for maxValueTime
	MaxValueTime *Element `json:"_maxValueTime,omitempty"`

	// Extensions for maxValueUnsignedInt
	MaxValueUnsignedInt *Element `json:"_maxValueUnsignedInt,omitempty"`

	// Extensions for meaningWhenMissing
	MeaningWhenMissing *Element `json:"_meaningWhenMissing,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// Extensions for minValueDate
	MinValueDate *Element `json:"_minValueDate,omitempty"`

	// Extensions for minValueDateTime
	MinValueDateTime *Element `json:"_minValueDateTime,omitempty"`

	// Extensions for minValueDecimal
	MinValueDecimal *Element `json:"_minValueDecimal,omitempty"`

	// Extensions for minValueInstant
	MinValueInstant *Element `json:"_minValueInstant,omitempty"`

	// Extensions for minValueInteger
	MinValueInteger *Element `json:"_minValueInteger,omitempty"`

	// Extensions for minValueInteger64
	MinValueInteger64 *Element `json:"_minValueInteger64,omitempty"`

	// Extensions for minValuePositiveInt
	MinValuePositiveInt *Element `json:"_minValuePositiveInt,omitempty"`

	// Extensions for minValueTime
	MinValueTime *Element `json:"_minValueTime,omitempty"`

	// Extensions for minValueUnsignedInt
	MinValueUnsignedInt *Element `json:"_minValueUnsignedInt,omitempty"`

	// Extensions for mustHaveValue
	MustHaveValue *Element `json:"_mustHaveValue,omitempty"`

	// Extensions for mustSupport
	MustSupport *Element `json:"_mustSupport,omitempty"`

	// Extensions for orderMeaning
	OrderMeaning *Element `json:"_orderMeaning,omitempty"`

	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// Extensions for patternBase64Binary
	PatternBase64Binary *Element `json:"_patternBase64Binary,omitempty"`

	// Extensions for patternBoolean
	PatternBoolean *Element `json:"_patternBoolean,omitempty"`

	// Extensions for patternCanonical
	PatternCanonical *Element `json:"_patternCanonical,omitempty"`

	// Extensions for patternCode
	PatternCode *Element `json:"_patternCode,omitempty"`

	// Extensions for patternDate
	PatternDate *Element `json:"_patternDate,omitempty"`

	// Extensions for patternDateTime
	PatternDateTime *Element `json:"_patternDateTime,omitempty"`

	// Extensions for patternDecimal
	PatternDecimal *Element `json:"_patternDecimal,omitempty"`

	// Extensions for patternId
	PatternID *Element `json:"_patternId,omitempty"`

	// Extensions for patternInstant
	PatternInstant *Element `json:"_patternInstant,omitempty"`

	// Extensions for patternInteger
	PatternInteger *Element `json:"_patternInteger,omitempty"`

	// Extensions for patternInteger64
	PatternInteger64 *Element `json:"_patternInteger64,omitempty"`

	// Extensions for patternMarkdown
	PatternMarkdown *Element `json:"_patternMarkdown,omitempty"`

	// Extensions for patternOid
	PatternOid *Element `json:"_patternOid,omitempty"`

	// Extensions for patternPositiveInt
	PatternPositiveInt *Element `json:"_patternPositiveInt,omitempty"`

	// Extensions for patternString
	PatternString *Element `json:"_patternString,omitempty"`

	// Extensions for patternTime
	PatternTime *Element `json:"_patternTime,omitempty"`

	// Extensions for patternUnsignedInt
	PatternUnsignedInt *Element `json:"_patternUnsignedInt,omitempty"`

	// Extensions for patternUri
	PatternUri *Element `json:"_patternUri,omitempty"`

	// Extensions for patternUrl
	PatternUrl *Element `json:"_patternUrl,omitempty"`

	// Extensions for patternUuid
	PatternUuid *Element `json:"_patternUuid,omitempty"`

	// Extensions for representation
	Representation []Element `json:"_representation,omitempty"`

	// Extensions for requirements
	Requirements *Element `json:"_requirements,omitempty"`

	// Extensions for short
	Short *Element `json:"_short,omitempty"`

	// Extensions for sliceIsConstraining
	SliceIsConstraining *Element `json:"_sliceIsConstraining,omitempty"`

	// Extensions for sliceName
	SliceName *Element `json:"_sliceName,omitempty"`

	// Identifies additional names by which this element might also be known.
	Alias_2 []String `json:"alias,omitempty"`

	// Information about the base definition of the element, provided to make it
	// unnecessary for tools to trace the deviation of the element through the derived
	// and related profiles. When the element definition is not the original
	// definition of an element - e.g. either in a constraint on another type, or for
	// elements from a super type in a snap shot - then the information in provided in
	// the element definition may be different to the base definition. On the original
	// definition of the element, it will be same.
	Base *ElementDefinitionBase `json:"base,omitempty"`

	// Binds to a value set if this element is coded (code, Coding, CodeableConcept,
	// Quantity), or the data types (string, uri).
	Binding *ElementDefinitionBinding `json:"binding,omitempty"`

	// A code that has the same meaning as the element in a particular terminology.
	Code []Coding `json:"code,omitempty"`

	// Explanatory notes and implementation guidance about the data element, including
	// notes about how to use the data properly, exceptions to proper use, etc. (Note:
	// The text you are reading is specified in ElementDefinition.comment).
	Comment_2 *Markdown `json:"comment,omitempty"`

	// A reference to an invariant that may make additional statements about the
	// cardinality or value in the instance.
	Condition_2 []ID `json:"condition,omitempty"`

	// Formal constraints such as co-occurrence and other constraints that can be
	// computationally evaluated within the context of the instance.
	Constraint []ElementDefinitionConstraint `json:"constraint,omitempty"`

	// Identifies an element defined elsewhere in the definition whose content rules
	// should be applied to the current element. ContentReferences bring across all
	// the rules that are in the ElementDefinition for the element, including
	// definitions, cardinality constraints, bindings, invariants etc.
	ContentReference_2 *Uri `json:"contentReference,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueAddress *Address `json:"defaultValueAddress,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueAge *Age `json:"defaultValueAge,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueAnnotation *Annotation `json:"defaultValueAnnotation,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueAttachment *Attachment `json:"defaultValueAttachment,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueAvailability *Availability `json:"defaultValueAvailability,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueBase64Binary_2 *string `json:"defaultValueBase64Binary,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueBoolean_2 *bool `json:"defaultValueBoolean,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCanonical_2 *string `json:"defaultValueCanonical,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCode_2 *string `json:"defaultValueCode,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCodeableConcept *CodeableConcept `json:"defaultValueCodeableConcept,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCodeableReference *CodeableReference `json:"defaultValueCodeableReference,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCoding *Coding `json:"defaultValueCoding,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueContactDetail *ContactDetail `json:"defaultValueContactDetail,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueContactPoint *ContactPoint `json:"defaultValueContactPoint,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueCount *Count `json:"defaultValueCount,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDataRequirement *DataRequirement `json:"defaultValueDataRequirement,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDate_2 *string `json:"defaultValueDate,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDateTime_2 *string `json:"defaultValueDateTime,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDecimal_2 *float64 `json:"defaultValueDecimal,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDistance *Distance `json:"defaultValueDistance,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDosage *Dosage `json:"defaultValueDosage,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueDuration *Duration `json:"defaultValueDuration,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueExpression *Expression `json:"defaultValueExpression,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueExtendedContactDetail *ExtendedContactDetail `json:"defaultValueExtendedContactDetail,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueHumanName *HumanName `json:"defaultValueHumanName,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueID_2 *string `json:"defaultValueId,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueIdentifier *Identifier `json:"defaultValueIdentifier,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueInstant_2 *string `json:"defaultValueInstant,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueInteger_2 *float64 `json:"defaultValueInteger,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueInteger64_2 *string `json:"defaultValueInteger64,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueMarkdown_2 *string `json:"defaultValueMarkdown,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueMeta *Meta `json:"defaultValueMeta,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueMoney *Money `json:"defaultValueMoney,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueOid_2 *string `json:"defaultValueOid,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueParameterDefinition *ParameterDefinition `json:"defaultValueParameterDefinition,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValuePeriod *Period `json:"defaultValuePeriod,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValuePositiveInt_2 *float64 `json:"defaultValuePositiveInt,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueQuantity *Quantity `json:"defaultValueQuantity,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueRange *Range `json:"defaultValueRange,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueRatio *Ratio `json:"defaultValueRatio,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueRatioRange *RatioRange `json:"defaultValueRatioRange,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueReference *Reference `json:"defaultValueReference,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueRelatedArtifact *RelatedArtifact `json:"defaultValueRelatedArtifact,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueSampledData *SampledData `json:"defaultValueSampledData,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueSignature *Signature `json:"defaultValueSignature,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueString_2 *string `json:"defaultValueString,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueTime_2 *string `json:"defaultValueTime,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueTiming *Timing `json:"defaultValueTiming,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueTriggerDefinition *TriggerDefinition `json:"defaultValueTriggerDefinition,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueUnsignedInt_2 *float64 `json:"defaultValueUnsignedInt,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueUri_2 *string `json:"defaultValueUri,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueUrl_2 *string `json:"defaultValueUrl,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueUsageContext *UsageContext `json:"defaultValueUsageContext,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueUuid_2 *string `json:"defaultValueUuid,omitempty"`

	// The value that should be used if there is no value stated in the instance (e.g.
	// 'if not otherwise specified, the abstract is false').
	DefaultValueVirtualServiceDetail *VirtualServiceDetail `json:"defaultValueVirtualServiceDetail,omitempty"`

	// Provides a complete explanation of the meaning of the data element for human
	// readability.  For the case of elements derived from existing elements (e.g.
	// constraints), the definition SHALL be consistent with the base definition, but
	// convey the meaning of the element in the particular context of use of the
	// resource. (Note: The text you are reading is specified in
	// ElementDefinition.definition).
	Definition_2 *Markdown `json:"definition,omitempty"`

	// A sample value for this element demonstrating the type of information that
	// would typically be found in the element.
	Example []ElementDefinitionExample `json:"example,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedAddress *Address `json:"fixedAddress,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedAge *Age `json:"fixedAge,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedAnnotation *Annotation `json:"fixedAnnotation,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedAttachment *Attachment `json:"fixedAttachment,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedAvailability *Availability `json:"fixedAvailability,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedBase64Binary_2 *string `json:"fixedBase64Binary,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedBoolean_2 *bool `json:"fixedBoolean,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCanonical_2 *string `json:"fixedCanonical,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCode_2 *string `json:"fixedCode,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCodeableConcept *CodeableConcept `json:"fixedCodeableConcept,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCodeableReference *CodeableReference `json:"fixedCodeableReference,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCoding *Coding `json:"fixedCoding,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedContactDetail *ContactDetail `json:"fixedContactDetail,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedContactPoint *ContactPoint `json:"fixedContactPoint,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedCount *Count `json:"fixedCount,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDataRequirement *DataRequirement `json:"fixedDataRequirement,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDate_2 *string `json:"fixedDate,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDateTime_2 *string `json:"fixedDateTime,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDecimal_2 *float64 `json:"fixedDecimal,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDistance *Distance `json:"fixedDistance,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDosage *Dosage `json:"fixedDosage,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedDuration *Duration `json:"fixedDuration,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedExpression *Expression `json:"fixedExpression,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedExtendedContactDetail *ExtendedContactDetail `json:"fixedExtendedContactDetail,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedHumanName *HumanName `json:"fixedHumanName,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedID_2 *string `json:"fixedId,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedIdentifier *Identifier `json:"fixedIdentifier,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedInstant_2 *string `json:"fixedInstant,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedInteger_2 *float64 `json:"fixedInteger,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedInteger64_2 *string `json:"fixedInteger64,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedMarkdown_2 *string `json:"fixedMarkdown,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedMeta *Meta `json:"fixedMeta,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedMoney *Money `json:"fixedMoney,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedOid_2 *string `json:"fixedOid,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedParameterDefinition *ParameterDefinition `json:"fixedParameterDefinition,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedPeriod *Period `json:"fixedPeriod,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedPositiveInt_2 *float64 `json:"fixedPositiveInt,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedQuantity *Quantity `json:"fixedQuantity,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedRange *Range `json:"fixedRange,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedRatio *Ratio `json:"fixedRatio,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedRatioRange *RatioRange `json:"fixedRatioRange,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedReference *Reference `json:"fixedReference,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedRelatedArtifact *RelatedArtifact `json:"fixedRelatedArtifact,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedSampledData *SampledData `json:"fixedSampledData,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedSignature *Signature `json:"fixedSignature,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedString_2 *string `json:"fixedString,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedTime_2 *string `json:"fixedTime,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedTiming *Timing `json:"fixedTiming,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedTriggerDefinition *TriggerDefinition `json:"fixedTriggerDefinition,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedUnsignedInt_2 *float64 `json:"fixedUnsignedInt,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedUri_2 *string `json:"fixedUri,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedUrl_2 *string `json:"fixedUrl,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedUsageContext *UsageContext `json:"fixedUsageContext,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedUuid_2 *string `json:"fixedUuid,omitempty"`

	// Specifies a value that SHALL be exactly the value  for this element in the
	// instance, if present. For purposes of comparison, non-significant whitespace is
	// ignored, and all values must be an exact match (case and accent sensitive).
	// Missing elements/attributes must also be missing.
	FixedVirtualServiceDetail *VirtualServiceDetail `json:"fixedVirtualServiceDetail,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If true, the value of this element affects the interpretation of the element or
	// resource that contains it, and the value of the element cannot be ignored.
	// Typically, this is used for status, negation and qualification codes. The
	// effect of this is that the element cannot be ignored by systems: they SHALL
	// either recognize the element and process it, and/or a pre-determination has
	// been made that it is not relevant to their particular system. When used on the
	// root element in an extension definition, this indicates whether or not the
	// extension is a modifier extension.
	IsModifier_2 *Boolean `json:"isModifier,omitempty"`

	// Explains how that element affects the interpretation of the resource or element
	// that contains it.
	IsModifierReason_2 *String `json:"isModifierReason,omitempty"`

	// Whether the element should be included if a client requests a search with the
	// parameter _summary=true.
	IsSummary_2 *Boolean `json:"isSummary,omitempty"`

	// A single preferred label which is the text to display beside the element
	// indicating its meaning or to use to prompt for the element in a user display or
	// form.
	Label_2 *String `json:"label,omitempty"`

	// Identifies a concept from an external specification that roughly corresponds to
	// this element.
	Mapping []ElementDefinitionMapping `json:"mapping,omitempty"`

	// The maximum number of times this element is permitted to appear in the
	// instance.
	Max_2 *String `json:"max,omitempty"`

	// Indicates the maximum length in characters that is permitted to be present in
	// conformant instances and which is expected to be supported by conformant
	// consumers that support the element. ```maxLength``` SHOULD only be used on
	// primitive data types that have a have a length (see [Tupe
	// Characteristics](datatypes.html#other) and
	// [[[http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics]]]).
	MaxLength_2 *Integer `json:"maxLength,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueDate_2 *string `json:"maxValueDate,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueDateTime_2 *string `json:"maxValueDateTime,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueDecimal_2 *float64 `json:"maxValueDecimal,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueInstant_2 *string `json:"maxValueInstant,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueInteger_2 *float64 `json:"maxValueInteger,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueInteger64_2 *string `json:"maxValueInteger64,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValuePositiveInt_2 *float64 `json:"maxValuePositiveInt,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueQuantity *Quantity `json:"maxValueQuantity,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueTime_2 *string `json:"maxValueTime,omitempty"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValueUnsignedInt_2 *float64 `json:"maxValueUnsignedInt,omitempty"`

	// The Implicit meaning that is to be understood when this element is missing
	// (e.g. 'when this element is missing, the period is ongoing').
	MeaningWhenMissing_2 *Markdown `json:"meaningWhenMissing,omitempty"`

	// The minimum number of times this element SHALL appear in the instance.
	Min_2 *UnsignedInt `json:"min,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueDate_2 *string `json:"minValueDate,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueDateTime_2 *string `json:"minValueDateTime,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueDecimal_2 *float64 `json:"minValueDecimal,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueInstant_2 *string `json:"minValueInstant,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueInteger_2 *float64 `json:"minValueInteger,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueInteger64_2 *string `json:"minValueInteger64,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValuePositiveInt_2 *float64 `json:"minValuePositiveInt,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueQuantity *Quantity `json:"minValueQuantity,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueTime_2 *string `json:"minValueTime,omitempty"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValueUnsignedInt_2 *float64 `json:"minValueUnsignedInt,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Specifies for a primitive data type that the value of the data type cannot be
	// replaced by an extension.
	MustHaveValue_2 *Boolean `json:"mustHaveValue,omitempty"`

	// If true, implementations that produce or consume resources SHALL provide
	// "support" for the element in some meaningful way. Note that this is being
	// phased out and replaced by obligations (see below).  If false, the element may
	// be ignored and not supported. If false, whether to populate or use the data
	// element in any way is at the discretion of the implementation.
	MustSupport_2 *Boolean `json:"mustSupport,omitempty"`

	// If present, indicates that the order of the repeating element has meaning and
	// describes what that meaning is.  If absent, it means that the order of the
	// element has no meaning.
	OrderMeaning_2 *String `json:"orderMeaning,omitempty"`

	// The path identifies the element and is expressed as a "."-separated list of
	// ancestor elements, beginning with the name of the resource or extension.
	Path_2 *String `json:"path,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternAddress *Address `json:"patternAddress,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternAge *Age `json:"patternAge,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternAnnotation *Annotation `json:"patternAnnotation,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternAttachment *Attachment `json:"patternAttachment,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternAvailability *Availability `json:"patternAvailability,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternBase64Binary_2 *string `json:"patternBase64Binary,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternBoolean_2 *bool `json:"patternBoolean,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCanonical_2 *string `json:"patternCanonical,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCode_2 *string `json:"patternCode,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCodeableConcept *CodeableConcept `json:"patternCodeableConcept,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCodeableReference *CodeableReference `json:"patternCodeableReference,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCoding *Coding `json:"patternCoding,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternContactDetail *ContactDetail `json:"patternContactDetail,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternContactPoint *ContactPoint `json:"patternContactPoint,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternCount *Count `json:"patternCount,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDataRequirement *DataRequirement `json:"patternDataRequirement,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDate_2 *string `json:"patternDate,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDateTime_2 *string `json:"patternDateTime,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDecimal_2 *float64 `json:"patternDecimal,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDistance *Distance `json:"patternDistance,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDosage *Dosage `json:"patternDosage,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternDuration *Duration `json:"patternDuration,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternExpression *Expression `json:"patternExpression,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternExtendedContactDetail *ExtendedContactDetail `json:"patternExtendedContactDetail,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternHumanName *HumanName `json:"patternHumanName,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternID_2 *string `json:"patternId,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternIdentifier *Identifier `json:"patternIdentifier,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternInstant_2 *string `json:"patternInstant,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternInteger_2 *float64 `json:"patternInteger,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternInteger64_2 *string `json:"patternInteger64,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternMarkdown_2 *string `json:"patternMarkdown,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternMeta *Meta `json:"patternMeta,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternMoney *Money `json:"patternMoney,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternOid_2 *string `json:"patternOid,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternParameterDefinition *ParameterDefinition `json:"patternParameterDefinition,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternPeriod *Period `json:"patternPeriod,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternPositiveInt_2 *float64 `json:"patternPositiveInt,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternQuantity *Quantity `json:"patternQuantity,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternRange *Range `json:"patternRange,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternRatio *Ratio `json:"patternRatio,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternRatioRange *RatioRange `json:"patternRatioRange,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternReference *Reference `json:"patternReference,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternRelatedArtifact *RelatedArtifact `json:"patternRelatedArtifact,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternSampledData *SampledData `json:"patternSampledData,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternSignature *Signature `json:"patternSignature,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternString_2 *string `json:"patternString,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternTime_2 *string `json:"patternTime,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternTiming *Timing `json:"patternTiming,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternTriggerDefinition *TriggerDefinition `json:"patternTriggerDefinition,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternUnsignedInt_2 *float64 `json:"patternUnsignedInt,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternUri_2 *string `json:"patternUri,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternUrl_2 *string `json:"patternUrl,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternUsageContext *UsageContext `json:"patternUsageContext,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternUuid_2 *string `json:"patternUuid,omitempty"`

	// Specifies a value that each occurrence of the element in the instance SHALL
	// follow - that is, any value in the pattern must be found in the instance, if
	// the element has a value. Other additional values may be found too. This is
	// effectively constraint by example.
	//
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	//
	// When an element within a pattern[x] is used to constrain an array, it means
	// that each element provided in the pattern[x] must (recursively) match at least
	// one element from the instance array.
	//
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	//
	// 1. If primitive: it must match exactly the pattern value
	// 2. If a complex object: it must match (recursively) the pattern value
	// 3. If an array: it must match (recursively) the pattern value
	//
	// If a pattern[x] is declared on a repeating element, the pattern applies to all
	// repetitions.  If the desire is for a pattern to apply to only one element or a
	// subset of elements, slicing must be used. See [Examples of
	// Patterns](elementdefinition-examples.html#pattern-examples) for examples of
	// pattern usage and the effect it will have.
	PatternVirtualServiceDetail *VirtualServiceDetail `json:"patternVirtualServiceDetail,omitempty"`

	// Codes that define how this element is represented in instances, when the
	// deviation varies from the normal case. No extensions are allowed on elements
	// with a representation of 'xmlAttr', no matter what FHIR serialization format is
	// used.
	Representation_2 []ElementDefinitionRepresentation_2Elem `json:"representation,omitempty"`

	// This element is for traceability of why the element was created and why the
	// constraints exist as they do. This may be used to point to source materials or
	// specifications that drove the structure of this element.
	Requirements_2 *Markdown `json:"requirements,omitempty"`

	// A concise description of what this element means (e.g. for use in autogenerated
	// summaries).
	Short_2 *String `json:"short,omitempty"`

	// If true, indicates that this slice definition is constraining a slice
	// definition with the same name in an inherited profile. If false, the slice is
	// not overriding any slice in an inherited profile. If missing, the slice might
	// or might not be overriding a slice in an inherited profile, depending on the
	// sliceName.
	SliceIsConstraining_2 *Boolean `json:"sliceIsConstraining,omitempty"`

	// The name of this element definition slice, when slicing is working. The name
	// must be a token with no dots or spaces. This is a unique name referring to a
	// specific set of constraints applied to this element, used to provide a name to
	// different slices of the same element.
	SliceName_2 *String `json:"sliceName,omitempty"`

	// Indicates that the element is sliced into a set of alternative definitions
	// (i.e. in a structure definition, there are multiple different constraints on a
	// single element in the base resource). Slicing can be used in any resource that
	// has cardinality ..* on the base resource, or any resource with a choice of
	// types. The set of slices is any elements that come after this in the element
	// sequence that have the same path, until a shorter path occurs (the shorter path
	// terminates the set).
	Slicing *ElementDefinitionSlicing `json:"slicing,omitempty"`

	// The data type or resource that the value of this element is permitted to be.
	Type []ElementDefinitionType `json:"type,omitempty"`

	// Specifies a list of extensions that can appear in place of a primitive value.
	ValueAlternatives []Canonical `json:"valueAlternatives,omitempty"`
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionAdditional struct {
	// Extensions for any
	Any *Element `json:"_any,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for shortDoco
	ShortDoco *Element `json:"_shortDoco,omitempty"`

	// Whether the binding applies to all repeats, or just to any one of them. This is
	// only relevant for elements that can repeat.
	Any_2 *Boolean `json:"any,omitempty"`

	// Documentation of the purpose of use of the binding, providing additional
	// information about how it is intended to be used.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A unique identifier for the additional binding within the element that allows
	// additional bindings to be matched across profiles.
	Key_2 *ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The use of this additional binding.
	Purpose_2 *Code `json:"purpose,omitempty"`

	// Concise documentation - for summary tables.
	ShortDoco_2 *String `json:"shortDoco,omitempty"`

	// Qualifies the usage of the binding. Typically bindings are qualified by
	// jurisdiction, but they may also be qualified by gender, workflow status,
	// clinical domain etc. The information to decide whether a usage context applies
	// is usually outside the resource, determined by context, and this might present
	// challenges for validation tooling.
	Usage []UsageContext `json:"usage,omitempty"`

	// The valueSet that is being bound for the purpose.
	ValueSet Canonical `json:"valueSet"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionAdditional) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["valueSet"]; raw != nil && !ok {
		return fmt.Errorf("field valueSet in ElementDefinitionAdditional: required")
	}
	type Plain ElementDefinitionAdditional
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElementDefinitionAdditional(plain)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionBase struct {
	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Maximum cardinality of the base element identified by the path.
	Max_2 *String `json:"max,omitempty"`

	// Minimum cardinality of the base element identified by the path.
	Min_2 *UnsignedInt `json:"min,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The Path that identifies the base element - this matches the
	// ElementDefinition.path for that element. Across FHIR, there is only one base
	// definition of any element - that is, an element definition on a
	// [[[StructureDefinition]]] without a StructureDefinition.base.
	Path_2 *String `json:"path,omitempty"`
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionBinding struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for strength
	Strength *Element `json:"_strength,omitempty"`

	// Additional bindings that help applications implementing this element.
	// Additional bindings do not replace the main binding but provide more
	// information and/or context.
	Additional []ElementDefinitionAdditional `json:"additional,omitempty"`

	// Free-text guidance on the codes that are appropriate for this element.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the degree of conformance expectations associated with this binding -
	// that is, the degree to which the provided value set must be adhered to in the
	// instances.
	Strength_2 *ElementDefinitionBindingStrength_2 `json:"strength,omitempty"`

	// Refers to the value set that identifies the set of codes the binding refers to.
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

type ElementDefinitionBindingStrength_2 string

const ElementDefinitionBindingStrength_2_Descriptive ElementDefinitionBindingStrength_2 = "descriptive"
const ElementDefinitionBindingStrength_2_Example ElementDefinitionBindingStrength_2 = "example"
const ElementDefinitionBindingStrength_2_Extensible ElementDefinitionBindingStrength_2 = "extensible"
const ElementDefinitionBindingStrength_2_Preferred ElementDefinitionBindingStrength_2 = "preferred"
const ElementDefinitionBindingStrength_2_Required ElementDefinitionBindingStrength_2 = "required"

var enumValues_ElementDefinitionBindingStrength_2 = []interface{}{
	"required",
	"extensible",
	"preferred",
	"example",
	"descriptive",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionBindingStrength_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionBindingStrength_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionBindingStrength_2, v)
	}
	*j = ElementDefinitionBindingStrength_2(v)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionConstraint struct {
	// Extensions for expression
	Expression *Element `json:"_expression,omitempty"`

	// Extensions for human
	Human *Element `json:"_human,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for requirements
	Requirements *Element `json:"_requirements,omitempty"`

	// Extensions for severity
	Severity *Element `json:"_severity,omitempty"`

	// Extensions for suppress
	Suppress *Element `json:"_suppress,omitempty"`

	// A [FHIRPath](fhirpath.html) expression of constraint that can be executed to
	// see if this constraint is met.
	Expression_2 *String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Text that can be used to describe the constraint in messages identifying that
	// the constraint has been violated.
	Human_2 *String `json:"human,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Allows identification of which elements have their cardinalities impacted by
	// the constraint.  Will not be referenced for constraints that do not affect
	// cardinality.
	Key_2 *ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Description of why this constraint is necessary or appropriate.
	Requirements_2 *Markdown `json:"requirements,omitempty"`

	// Identifies the impact constraint violation has on the conformance of the
	// instance.
	Severity_2 *ElementDefinitionConstraintSeverity_2 `json:"severity,omitempty"`

	// A reference to the original source of the constraint, for traceability
	// purposes.
	Source *Canonical `json:"source,omitempty"`

	// If true, indicates that the warning or best practice guideline should be
	// suppressed.
	Suppress_2 *Boolean `json:"suppress,omitempty"`
}

type ElementDefinitionConstraintSeverity_2 string

const ElementDefinitionConstraintSeverity_2_Error ElementDefinitionConstraintSeverity_2 = "error"
const ElementDefinitionConstraintSeverity_2_Warning ElementDefinitionConstraintSeverity_2 = "warning"

var enumValues_ElementDefinitionConstraintSeverity_2 = []interface{}{
	"error",
	"warning",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionConstraintSeverity_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionConstraintSeverity_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionConstraintSeverity_2, v)
	}
	*j = ElementDefinitionConstraintSeverity_2(v)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionDiscriminator struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A FHIRPath expression, using [the simple subset of
	// FHIRPath](fhirpath.html#simple), that is used to identify the element on which
	// discrimination is based.
	Path_2 *String `json:"path,omitempty"`

	// How the element value is interpreted when discrimination is evaluated.
	Type_2 *ElementDefinitionDiscriminatorType_2 `json:"type,omitempty"`
}

type ElementDefinitionDiscriminatorType_2 string

const ElementDefinitionDiscriminatorType_2_Exists ElementDefinitionDiscriminatorType_2 = "exists"
const ElementDefinitionDiscriminatorType_2_Pattern ElementDefinitionDiscriminatorType_2 = "pattern"
const ElementDefinitionDiscriminatorType_2_Position ElementDefinitionDiscriminatorType_2 = "position"
const ElementDefinitionDiscriminatorType_2_Profile ElementDefinitionDiscriminatorType_2 = "profile"
const ElementDefinitionDiscriminatorType_2_Type ElementDefinitionDiscriminatorType_2 = "type"
const ElementDefinitionDiscriminatorType_2_Value ElementDefinitionDiscriminatorType_2 = "value"

var enumValues_ElementDefinitionDiscriminatorType_2 = []interface{}{
	"value",
	"exists",
	"pattern",
	"type",
	"profile",
	"position",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionDiscriminatorType_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionDiscriminatorType_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionDiscriminatorType_2, v)
	}
	*j = ElementDefinitionDiscriminatorType_2(v)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionExample struct {
	// Extensions for label
	Label *Element `json:"_label,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Describes the purpose of this example among the set of examples.
	Label_2 *String `json:"label,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueAge *Age `json:"valueAge,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueCount *Count `json:"valueCount,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueID_2 *string `json:"valueId,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionExample) UnmarshalJSON(value []byte) error {
	type Plain ElementDefinitionExample
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ElementDefinitionExample(plain)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionMapping struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for identity
	Identity *Element `json:"_identity,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for map
	Map *Element `json:"_map,omitempty"`

	// Comments that provide information about the mapping or its use.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An internal reference to the definition of a mapping.
	Identity_2 *ID `json:"identity,omitempty"`

	// Identifies the computable language in which mapping.map is expressed.
	Language_2 *Code `json:"language,omitempty"`

	// Expresses what part of the target specification corresponds to this element.
	Map_2 *String `json:"map,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type ElementDefinitionRepresentation_2Elem string

const ElementDefinitionRepresentation_2ElemCdaText ElementDefinitionRepresentation_2Elem = "cdaText"
const ElementDefinitionRepresentation_2ElemTypeAttr ElementDefinitionRepresentation_2Elem = "typeAttr"
const ElementDefinitionRepresentation_2ElemXhtml ElementDefinitionRepresentation_2Elem = "xhtml"
const ElementDefinitionRepresentation_2ElemXmlAttr ElementDefinitionRepresentation_2Elem = "xmlAttr"
const ElementDefinitionRepresentation_2ElemXmlText ElementDefinitionRepresentation_2Elem = "xmlText"

var enumValues_ElementDefinitionRepresentation_2Elem = []interface{}{
	"xmlAttr",
	"xmlText",
	"typeAttr",
	"cdaText",
	"xhtml",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionRepresentation_2Elem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionRepresentation_2Elem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionRepresentation_2Elem, v)
	}
	*j = ElementDefinitionRepresentation_2Elem(v)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionSlicing struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for ordered
	Ordered *Element `json:"_ordered,omitempty"`

	// Extensions for rules
	Rules *Element `json:"_rules,omitempty"`

	// A human-readable text description of how the slicing works. If there is no
	// discriminator, this is required to be present to provide whatever information
	// is possible about how the slices can be differentiated.
	Description_2 *String `json:"description,omitempty"`

	// Designates which child elements are used to discriminate between the slices
	// when processing an instance. If one or more discriminators are provided, the
	// values of the child elements in the instance data SHALL completely distinguish
	// which slice the element in the resource matches based on the allowed values for
	// those elements in each of the slices.
	Discriminator []ElementDefinitionDiscriminator `json:"discriminator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// If the matching elements have to occur in the same order as defined in the
	// profile.
	Ordered_2 *Boolean `json:"ordered,omitempty"`

	// Whether additional slices are allowed or not. When the slices are ordered,
	// profile authors can also say that additional slices are only allowed at the
	// end.
	Rules_2 *ElementDefinitionSlicingRules_2 `json:"rules,omitempty"`
}

type ElementDefinitionSlicingRules_2 string

const ElementDefinitionSlicingRules_2_Closed ElementDefinitionSlicingRules_2 = "closed"
const ElementDefinitionSlicingRules_2_Open ElementDefinitionSlicingRules_2 = "open"
const ElementDefinitionSlicingRules_2_OpenAtEnd ElementDefinitionSlicingRules_2 = "openAtEnd"

var enumValues_ElementDefinitionSlicingRules_2 = []interface{}{
	"closed",
	"open",
	"openAtEnd",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionSlicingRules_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionSlicingRules_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionSlicingRules_2, v)
	}
	*j = ElementDefinitionSlicingRules_2(v)
	return nil
}

// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinitionType struct {
	// Extensions for aggregation
	Aggregation []Element `json:"_aggregation,omitempty"`

	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for versioning
	Versioning *Element `json:"_versioning,omitempty"`

	// If the type is a reference to another resource, how the resource is or can be
	// aggregated - is it a contained resource, or a reference, and if the context is
	// a bundle, is it included in the bundle.
	Aggregation_2 []ElementDefinitionTypeAggregation_2Elem `json:"aggregation,omitempty"`

	// URL of Data type or Resource that is a(or the) type used for this element.
	// References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
	// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed
	// in logical models.
	Code_2 *Uri `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies a profile structure or implementation Guide that applies to the
	// datatype this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local reference
	// - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the type SHALL conform to at least one
	// profile defined in the implementation guide.
	Profile []Canonical `json:"profile,omitempty"`

	// Used when the type is "Reference" or "canonical", and identifies a profile
	// structure or implementation Guide that applies to the target of the reference
	// this element refers to. If any profiles are specified, then the content must
	// conform to at least one of them. The URL can be a local reference - to a
	// contained StructureDefinition, or a reference to another StructureDefinition or
	// Implementation Guide by a canonical URL. When an implementation guide is
	// specified, the target resource SHALL conform to at least one profile defined in
	// the implementation guide.
	TargetProfile []Canonical `json:"targetProfile,omitempty"`

	// Whether this reference needs to be version specific or version independent, or
	// whether either can be used.
	Versioning_2 *ElementDefinitionTypeVersioning_2 `json:"versioning,omitempty"`
}

type ElementDefinitionTypeAggregation_2Elem string

const ElementDefinitionTypeAggregation_2ElemBundled ElementDefinitionTypeAggregation_2Elem = "bundled"
const ElementDefinitionTypeAggregation_2ElemContained ElementDefinitionTypeAggregation_2Elem = "contained"
const ElementDefinitionTypeAggregation_2ElemReferenced ElementDefinitionTypeAggregation_2Elem = "referenced"

var enumValues_ElementDefinitionTypeAggregation_2Elem = []interface{}{
	"contained",
	"referenced",
	"bundled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionTypeAggregation_2Elem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionTypeAggregation_2Elem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionTypeAggregation_2Elem, v)
	}
	*j = ElementDefinitionTypeAggregation_2Elem(v)
	return nil
}

type ElementDefinitionTypeVersioning_2 string

const ElementDefinitionTypeVersioning_2_Either ElementDefinitionTypeVersioning_2 = "either"
const ElementDefinitionTypeVersioning_2_Independent ElementDefinitionTypeVersioning_2 = "independent"
const ElementDefinitionTypeVersioning_2_Specific ElementDefinitionTypeVersioning_2 = "specific"

var enumValues_ElementDefinitionTypeVersioning_2 = []interface{}{
	"either",
	"independent",
	"specific",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinitionTypeVersioning_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElementDefinitionTypeVersioning_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElementDefinitionTypeVersioning_2, v)
	}
	*j = ElementDefinitionTypeVersioning_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElementDefinition) UnmarshalJSON(value []byte) error {
	type Plain ElementDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DefaultValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.DefaultValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.DefaultValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefaultValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueCanonical_2", `^\S*$`)
		}
	}
	if plain.DefaultValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.DefaultValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.DefaultValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.DefaultValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.DefaultValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.DefaultValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.DefaultValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.DefaultValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.DefaultValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.DefaultValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.DefaultValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.DefaultValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.DefaultValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DefaultValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.DefaultValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.DefaultValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.DefaultValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DefaultValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.DefaultValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.DefaultValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.DefaultValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefaultValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueUri_2", `^\S*$`)
		}
	}
	if plain.DefaultValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefaultValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueUrl_2", `^\S*$`)
		}
	}
	if plain.DefaultValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.DefaultValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefaultValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	if plain.FixedBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.FixedBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.FixedCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.FixedCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedCanonical_2", `^\S*$`)
		}
	}
	if plain.FixedCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.FixedCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.FixedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.FixedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.FixedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.FixedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.FixedID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.FixedID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.FixedInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.FixedInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.FixedInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.FixedInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.FixedMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.FixedMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.FixedOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.FixedOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.FixedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.FixedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.FixedTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.FixedTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.FixedUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.FixedUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedUri_2", `^\S*$`)
		}
	}
	if plain.FixedUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.FixedUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedUrl_2", `^\S*$`)
		}
	}
	if plain.FixedUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.FixedUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FixedUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	if plain.MaxValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.MaxValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.MaxValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.MaxValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.MaxValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.MaxValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.MaxValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.MaxValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.MaxValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.MaxValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.MinValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.MinValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.MinValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.MinValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.MinValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.MinValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.MinValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.MinValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.MinValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.MinValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.PatternBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.PatternBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.PatternCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.PatternCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternCanonical_2", `^\S*$`)
		}
	}
	if plain.PatternCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.PatternCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.PatternDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.PatternDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.PatternDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.PatternDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.PatternID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.PatternID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.PatternInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.PatternInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.PatternInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.PatternInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.PatternMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.PatternMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.PatternOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.PatternOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.PatternString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.PatternString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.PatternTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.PatternTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.PatternUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.PatternUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternUri_2", `^\S*$`)
		}
	}
	if plain.PatternUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.PatternUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternUrl_2", `^\S*$`)
		}
	}
	if plain.PatternUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.PatternUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PatternUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ElementDefinition(plain)
	return nil
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type Encounter struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for plannedEndDate
	PlannedEndDate *Element `json:"_plannedEndDate,omitempty"`

	// Extensions for plannedStartDate
	PlannedStartDate *Element `json:"_plannedStartDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The set of accounts that may be used for billing for this Encounter.
	Account []Reference `json:"account,omitempty"`

	// The actual start and end time of the encounter.
	ActualPeriod *Period `json:"actualPeriod,omitempty"`

	// Details about the stay during which a healthcare service is provided.This
	// does not describe the event of admitting the patient, but rather any
	// information that is relevant from the time of admittance until the time of
	// discharge.
	Admission *EncounterAdmission `json:"admission,omitempty"`

	// The appointment that scheduled this encounter.
	Appointment []Reference `json:"appointment,omitempty"`

	// The request this encounter satisfies (e.g. incoming referral or procedure
	// request).
	BasedOn []Reference `json:"basedOn,omitempty"`

	// A granular, workflows specific set of statuses that apply to the encounter.
	BusinessStatus []EncounterBusinessStatus `json:"businessStatus,omitempty"`

	// The group(s) of individuals, organizations that are allocated to participate in
	// this encounter. The participants backbone will record the actuals of when these
	// individuals participated during the encounter.
	CareTeam []Reference `json:"careTeam,omitempty"`

	// Concepts representing classification of patient encounter such as ambulatory
	// (outpatient), inpatient, emergency, home health or others due to local
	// variations.
	Class []CodeableConcept `json:"class,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EncounterContainedElem `json:"contained,omitempty"`

	// The list of diagnosis relevant to this encounter.
	Diagnosis []EncounterDiagnosis `json:"diagnosis,omitempty"`

	// Diet preferences reported by the patient.
	DietPreference []CodeableConcept `json:"dietPreference,omitempty"`

	// Where a specific encounter should be classified as a part of a specific
	// episode(s) of care this field should be used. This association can facilitate
	// grouping of related encounters together for a specific purpose, such as
	// government reporting, issue tracking, association via a common problem.  The
	// association is recorded on the encounter as these are typically created after
	// the episode of care and grouped on entry rather than editing the episode of
	// care to append another encounter to it (the episode of care could span years).
	EpisodeOfCare []Reference `json:"episodeOfCare,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier(s) by which this encounter is known.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Actual quantity of time the encounter lasted. This excludes the time during
	// leaves of absence.When missing it is the time in between the start and end
	// values.
	Length *Duration `json:"length,omitempty"`

	// List of locations where  the patient has been during this encounter.
	Location []EncounterLocation `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Another Encounter of which this encounter is a part of (administratively or in
	// time).
	PartOf *Reference `json:"partOf,omitempty"`

	// The list of people responsible for providing the service.
	Participant []EncounterParticipant `json:"participant,omitempty"`

	// The planned end date/time (or discharge date) of the encounter.
	PlannedEndDate_2 *DateTime `json:"plannedEndDate,omitempty"`

	// The planned start date/time (or admission date) of the encounter.
	PlannedStartDate_2 *DateTime `json:"plannedStartDate,omitempty"`

	// Indicates the urgency of the encounter.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// The list of medical reasons that are expected to be addressed during the
	// episode of care.
	Reason []EncounterReason `json:"reason,omitempty"`

	// This is a Encounter resource
	ResourceType interface{} `json:"resourceType"`

	// The organization that is primarily responsible for this Encounter's services.
	// This MAY be the same as the organization on the Patient record, however it
	// could be different, such as if the actor performing the services was from an
	// external organization (which may be billed seperately) for an external
	// consultation.  Refer to the colonoscopy example on the Encounter examples tab.
	ServiceProvider *Reference `json:"serviceProvider,omitempty"`

	// Broad categorization of the service that is to be provided (e.g. cardiology).
	ServiceType []CodeableReference `json:"serviceType,omitempty"`

	// Any special requests that have been made for this encounter, such as the
	// provision of specific equipment or other things.
	SpecialArrangement []CodeableConcept `json:"specialArrangement,omitempty"`

	// Special courtesies that may be provided to the patient during the encounter
	// (VIP, board member, professional courtesy).
	SpecialCourtesy []CodeableConcept `json:"specialCourtesy,omitempty"`

	// The current state of the encounter (not the state of the patient within the
	// encounter - that is subjectState).
	Status_2 *Code `json:"status,omitempty"`

	// The patient or group related to this encounter. In some use-cases the patient
	// MAY not be present, such as a case meeting about a patient between several
	// practitioners or a careteam.
	Subject *Reference `json:"subject,omitempty"`

	// The subjectStatus value can be used to track the patient's status within the
	// encounter. It details whether the patient has arrived or departed, has been
	// triaged or is currently in a waiting status.
	SubjectStatus *CodeableConcept `json:"subjectStatus,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Specific type of encounter (e.g. e-mail consultation, surgical day-care,
	// skilled nursing, rehabilitation).
	Type []CodeableConcept `json:"type,omitempty"`

	// Connection details of a virtual service (e.g. conference call).
	VirtualService []VirtualServiceDetail `json:"virtualService,omitempty"`
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterAdmission struct {
	// From where patient was admitted (physician referral, transfer).
	AdmitSource *CodeableConcept `json:"admitSource,omitempty"`

	// Location/organization to which the patient is discharged.
	Destination *Reference `json:"destination,omitempty"`

	// Category or kind of location after discharge.
	DischargeDisposition *CodeableConcept `json:"dischargeDisposition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The location/organization from which the patient came before admission.
	Origin *Reference `json:"origin,omitempty"`

	// Pre-admission identifier.
	PreAdmissionIdentifier *Identifier `json:"preAdmissionIdentifier,omitempty"`

	// Indicates that this encounter is directly related to a prior admission, often
	// because the conditions addressed in the prior admission were not fully
	// addressed.
	ReAdmission *CodeableConcept `json:"reAdmission,omitempty"`
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterBusinessStatus struct {
	// Extensions for effectiveDate
	EffectiveDate *Element `json:"_effectiveDate,omitempty"`

	// The current business status.
	Code CodeableConcept `json:"code"`

	// The date/time when the encounter entered this business status.
	EffectiveDate_2 *DateTime `json:"effectiveDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The kind of workflow the status is tracking.
	Type *Coding `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EncounterBusinessStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in EncounterBusinessStatus: required")
	}
	type Plain EncounterBusinessStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EncounterBusinessStatus(plain)
	return nil
}

type EncounterContainedElem interface{}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterDiagnosis struct {
	// The coded diagnosis or a reference to a Condition (with other resources
	// referenced in the evidence.detail), the use property will indicate the purpose
	// of this specific diagnosis.
	Condition []CodeableReference `json:"condition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Role that this diagnosis has within the encounter (e.g. admission, billing,
	// discharge â€¦).
	Use []CodeableConcept `json:"use,omitempty"`
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterLocation struct {
	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// This will be used to specify the required levels (bed/ward/room/etc.) desired
	// to be recorded to simplify either messaging or query.
	Form *CodeableConcept `json:"form,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The location where the encounter takes place.
	Location Reference `json:"location"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Time period during which the patient was present at the location.
	Period *Period `json:"period,omitempty"`

	// The status of the participants' presence at the specified location during the
	// period specified. If the participant is no longer at the location, then the
	// period will have an end date/time.
	Status_2 *Code `json:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EncounterLocation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in EncounterLocation: required")
	}
	type Plain EncounterLocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EncounterLocation(plain)
	return nil
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterParticipant struct {
	// Person involved in the encounter, the patient/group is also included here to
	// indicate that the patient was actually participating in the encounter. Not
	// including the patient here covers use cases such as a case meeting between
	// practitioners about a patient - non contact times.
	Actor *Reference `json:"actor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period of time that the specified participant participated in the
	// encounter. These can overlap or be sub-sets of the overall encounter's period.
	Period *Period `json:"period,omitempty"`

	// Role of participant in encounter.
	Type []CodeableConcept `json:"type,omitempty"`
}

// An interaction between a patient and healthcare provider(s) for the purpose of
// providing healthcare service(s) or assessing the health status of a patient.
// Encounter is primarily used to record information about the actual activities
// that occurred, where Appointment is used to record planned activities.
type EncounterReason struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// What the reason value should be used as e.g. Chief Complaint, Health Concern,
	// Health Maintenance (including screening).
	Use []CodeableConcept `json:"use,omitempty"`

	// Reason the encounter takes place, expressed as a code or a reference to another
	// resource. For admissions, this can be used for a coded admission diagnosis.
	Value []CodeableReference `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Encounter) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Encounter: required")
	}
	type Plain Encounter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Encounter(plain)
	return nil
}

// The technical details of an endpoint that can be used for electronic services,
// such as for web services providing XDS.b, a REST endpoint for another FHIR
// server, or a s/Mime email address. This may include any security context
// information.
type Endpoint struct {
	// Extensions for address
	Address *Element `json:"_address,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for header
	Header []Element `json:"_header,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The uri that describes the actual end-point to connect to.
	Address_2 *Url `json:"address,omitempty"`

	// The times the endpoint is expected to be available, including transient
	// downtimes and any exceptions.
	Availability *Availability `json:"availability,omitempty"`

	// A coded value that represents the technical details of the usage of this
	// endpoint, such as what WSDLs should be used in what way. (e.g.
	// XDS.b/DICOM/cds-hook).
	ConnectionType []CodeableConcept `json:"connectionType"`

	// Contact details for a human to contact about the endpoint. The primary use of
	// this for system administrator troubleshooting.
	Contact []ContactPoint `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EndpointContainedElem `json:"contained,omitempty"`

	// The description of the endpoint and what it is for (typically used as
	// supplemental information in an endpoint directory describing its
	// usage/purpose).
	Description_2 *String `json:"description,omitempty"`

	// The type of environment(s) exposed at this endpoint (dev, prod, test, etc.).
	EnvironmentType []CodeableConcept `json:"environmentType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Additional headers / information to send as part of the notification.
	Header_2 []String `json:"header,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for the organization that is used to identify the endpoint across
	// multiple disparate systems.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organization that provides technical management services for this endpoint.
	// This would be the organization that acts as the public help desk for when the
	// endpoint is not functioning.  It does NOT necessarily represent the
	// organization who is the steward of data being provided/accepted by the
	// endpoint.
	ManagingOrganization *Reference `json:"managingOrganization,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A friendly name that this endpoint can be referred to with.
	Name_2 *String `json:"name,omitempty"`

	// The set of payloads that are provided/available at this endpoint.
	Payload []EndpointPayload `json:"payload,omitempty"`

	// The interval during which the endpoint is expected to be operational.
	Period *Period `json:"period,omitempty"`

	// This is a Endpoint resource
	ResourceType interface{} `json:"resourceType"`

	// The endpoint status represents whether the endpoint can currently be used for
	// connections or why it can't be used.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type EndpointContainedElem interface{}

// The technical details of an endpoint that can be used for electronic services,
// such as for web services providing XDS.b, a REST endpoint for another FHIR
// server, or a s/Mime email address. This may include any security context
// information.
type EndpointPayload struct {
	// Extensions for mimeType
	MimeType []Element `json:"_mimeType,omitempty"`

	// Extensions for profileCanonical
	ProfileCanonical []Element `json:"_profileCanonical,omitempty"`

	// Extensions for profileUri
	ProfileUri []Element `json:"_profileUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The mime type to send the payload in - e.g. application/fhir+xml,
	// application/fhir+json. If the mime type is not specified, then the sender could
	// send any content (including no content depending on the connectionType).
	MimeType_2 []Code `json:"mimeType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The FHIR profile that is expected at this endpoint. It describes the resources
	// that are handled, or even simply which resource types -e.g. Vital Sign
	// Observations or QuestionnaireResponse.The `profileUri` may be used when a FHIR
	// Structure Definition is not available/appropriate.
	ProfileCanonical_2 []Canonical `json:"profileCanonical,omitempty"`

	// The profile (as a uri) that is expected at this endpoint when not represented
	// using a FHIR profile.e.g. CDA Template ID expressed as an OID (in the Uri).
	ProfileUri_2 []Uri `json:"profileUri,omitempty"`

	// The payload type describes the acceptable content that can be communicated on
	// the endpoint.
	Type []CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Endpoint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["connectionType"]; raw != nil && !ok {
		return fmt.Errorf("field connectionType in Endpoint: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Endpoint: required")
	}
	type Plain Endpoint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Endpoint(plain)
	return nil
}

// This resource provides the insurance enrollment details to the insurer regarding
// a specified coverage.
type EnrollmentRequest struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The subject or group of subjects to be enrolled.
	Candidate *Reference `json:"candidate,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EnrollmentRequestContainedElem `json:"contained,omitempty"`

	// Reference to the program or plan identification, underwriter or payor.
	Coverage *Reference `json:"coverage,omitempty"`

	// The date when this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The Response business identifier.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The Insurer who is target  of the request.
	Insurer *Reference `json:"insurer,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The practitioner who is responsible for the services rendered to the patient.
	Provider *Reference `json:"provider,omitempty"`

	// This is a EnrollmentRequest resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type EnrollmentRequestContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnrollmentRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in EnrollmentRequest: required")
	}
	type Plain EnrollmentRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EnrollmentRequest(plain)
	return nil
}

// This resource provides enrollment and plan details from the processing of an
// EnrollmentRequest resource.
type EnrollmentResponse struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outcome
	Outcome *Element `json:"_outcome,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The subject or group of subjects to be enrolled.
	Candidate *Reference `json:"candidate,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EnrollmentResponseContainedElem `json:"contained,omitempty"`

	// The date when the enclosed suite of services were performed or completed.
	Created_2 *DateTime `json:"created,omitempty"`

	// A description of the status of the adjudication.
	Disposition_2 *String `json:"disposition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The Response business identifier.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The Insurer who produced this adjudicated response.
	Organization *Reference `json:"organization,omitempty"`

	// Processing status: error, complete.
	Outcome_2 *Code `json:"outcome,omitempty"`

	// Original request resource reference.
	Request *Reference `json:"request,omitempty"`

	// The practitioner who is responsible for the services rendered to the patient.
	RequestProvider *Reference `json:"requestProvider,omitempty"`

	// This is a EnrollmentResponse resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type EnrollmentResponseContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnrollmentResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in EnrollmentResponse: required")
	}
	type Plain EnrollmentResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EnrollmentResponse(plain)
	return nil
}

// An association between a patient and an organization / healthcare provider(s)
// during which time encounters may occur. The managing organization assumes a
// level of responsibility for the patient during this time.
type EpisodeOfCare struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The set of accounts that may be used for billing for this EpisodeOfCare.
	Account []Reference `json:"account,omitempty"`

	// The practitioner that is the care manager/care coordinator for this patient.
	CareManager *Reference `json:"careManager,omitempty"`

	// The list of practitioners that may be facilitating this episode of care for
	// specific purposes.
	CareTeam []Reference `json:"careTeam,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EpisodeOfCareContainedElem `json:"contained,omitempty"`

	// The list of medical conditions that were addressed during the episode of care.
	Diagnosis []EpisodeOfCareDiagnosis `json:"diagnosis,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The EpisodeOfCare may be known by different identifiers for different contexts
	// of use, such as when an external agency is tracking the Episode for funding
	// purposes.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organization that has assumed the specific responsibilities for care
	// coordination, care delivery, or other services for the specified duration.
	ManagingOrganization *Reference `json:"managingOrganization,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The interval during which the managing organization assumes the defined
	// responsibility.
	Period *Period `json:"period,omitempty"`

	// The list of medical reasons that are expected to be addressed during the
	// episode of care.
	Reason []EpisodeOfCareReason `json:"reason,omitempty"`

	// Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming
	// referrals.
	ReferralRequest []Reference `json:"referralRequest,omitempty"`

	// This is a EpisodeOfCare resource
	ResourceType interface{} `json:"resourceType"`

	// planned | waitlist | active | onhold | finished | cancelled.
	Status_2 *Code `json:"status,omitempty"`

	// The history of statuses that the EpisodeOfCare has been through (without
	// requiring processing the history of the resource).
	StatusHistory []EpisodeOfCareStatusHistory `json:"statusHistory,omitempty"`

	// The patient/group who is the focus of this episode of care.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A classification of the type of episode of care; e.g. specialist referral,
	// disease management, type of funded care.
	Type []CodeableConcept `json:"type,omitempty"`
}

type EpisodeOfCareContainedElem interface{}

// An association between a patient and an organization / healthcare provider(s)
// during which time encounters may occur. The managing organization assumes a
// level of responsibility for the patient during this time.
type EpisodeOfCareDiagnosis struct {
	// The medical condition that was addressed during the episode of care, expressed
	// as a text, code or a reference to another resource.
	Condition []CodeableReference `json:"condition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Role that this diagnosis has within the episode of care (e.g. admission,
	// billing, discharge â€¦).
	Use []CodeableConcept `json:"use,omitempty"`
}

// An association between a patient and an organization / healthcare provider(s)
// during which time encounters may occur. The managing organization assumes a
// level of responsibility for the patient during this time.
type EpisodeOfCareReason struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// What the reason value should be used as e.g. Chief Complaint, Health Concern,
	// Health Maintenance (including screening).
	Use []CodeableConcept `json:"use,omitempty"`

	// The medical reason that is expected to be addressed during the episode of care,
	// expressed as a text, code or a reference to another resource.
	Value []CodeableReference `json:"value,omitempty"`
}

// An association between a patient and an organization / healthcare provider(s)
// during which time encounters may occur. The managing organization assumes a
// level of responsibility for the patient during this time.
type EpisodeOfCareStatusHistory struct {
	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period during this EpisodeOfCare that the specific status applied.
	Period Period `json:"period"`

	// planned | waitlist | active | onhold | finished | cancelled.
	Status_2 *Code `json:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EpisodeOfCareStatusHistory) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["period"]; raw != nil && !ok {
		return fmt.Errorf("field period in EpisodeOfCareStatusHistory: required")
	}
	type Plain EpisodeOfCareStatusHistory
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EpisodeOfCareStatusHistory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EpisodeOfCare) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in EpisodeOfCare: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in EpisodeOfCare: required")
	}
	type Plain EpisodeOfCare
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EpisodeOfCare(plain)
	return nil
}

// The EventDefinition resource provides a reusable description of when a
// particular event can occur.
type EventDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EventDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the event definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the event definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the event definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the event definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the event definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the event definition content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this event definition is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this event definition when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the event definition. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the event definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this event definition is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related resources such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a EventDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this event definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A code or group definition that describes the intended subject of the event
	// definition.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code or group definition that describes the intended subject of the event
	// definition.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// An explanatory or alternate title for the event definition giving additional
	// information about its content.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the event definition.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the module. Topics provide a high-level
	// categorization of the module that can be useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// The trigger element defines when the event occurs. If more than one trigger
	// condition is specified, the event fires whenever any one of the trigger
	// conditions is met.
	Trigger []TriggerDefinition `json:"trigger"`

	// An absolute URI that is used to identify this event definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this event definition is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the event definition is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the event definition is used from a clinical
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate event definition
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the event definition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the event definition author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type EventDefinitionContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in EventDefinition: required")
	}
	if _, ok := raw["trigger"]; raw != nil && !ok {
		return fmt.Errorf("field trigger in EventDefinition: required")
	}
	type Plain EventDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = EventDefinition(plain)
	return nil
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type Evidence struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for assertion
	Assertion *Element `json:"_assertion,omitempty"`

	// Extensions for citeAs
	CiteAs *Element `json:"_citeAs,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// Declarative description of the Evidence, such as conclusion or bottom line
	// statement.
	Assertion_2 *Markdown `json:"assertion,omitempty"`

	// An individiual, organization, or device primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Assessment of certainty, confidence in the estimates, or quality of the
	// evidence.
	Certainty []EvidenceCertainty `json:"certainty,omitempty"`

	// Display of the suggested method of how to cite this Evidence.
	CiteAs_2 *Markdown `json:"citeAs,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EvidenceContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the Evidence and/or its contents. Copyright
	// statements are legal notices of intellectual property ownership and may include
	// restrictions on the use and publishing of the Evidence.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the summary was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the summary changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A natural language summary of the evidence.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individiual, organization, or device primarily responsible for internal
	// coherence of the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the {{title}} content was or is planned to be in active
	// use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individiual, organization, or device responsible for officially endorsing
	// the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this resource is authored for testing purposes
	// (or education/evaluation/marketing) and no version of this resource will ever
	// be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this summary when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the evidence. This name should be usable as
	// an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// Footnotes and/or explanatory notes.
	Note []Annotation `json:"note,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the evidence.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this Evidence is needed and why it has been designed as it
	// has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Who entered the data for the evidence.
	Recorder []ContactDetail `json:"recorder,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// Relationships that this Evidence has with other FHIR or non-FHIR resources that
	// already exist.
	RelatesTo []EvidenceRelatesTo `json:"relatesTo,omitempty"`

	// This is a Evidence resource
	ResourceType interface{} `json:"resourceType"`

	// An individiual, organization, or device primarily responsible for review of
	// some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// Values and parameters for a single statistic.
	Statistic []EvidenceStatistic `json:"statistic,omitempty"`

	// The status of this summary. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// The design of the study that produced this evidence. The design is described
	// with any number of study design characteristics.
	StudyDesign []CodeableConcept `json:"studyDesign,omitempty"`

	// The design of the synthesis (combination of studies) that produced this
	// evidence. The design is described with any number of synthesis characteristics,
	// such as type of meta-analysis.
	SynthesisType []CodeableConcept `json:"synthesisType,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the summary.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the {{title}}. Topics provide a
	// high-level categorization as well as keywords for the {{title}} that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this evidence when it is referenced in
	// a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this summary is (or will be) published. This
	// URL can be the target of a canonical reference. It SHALL remain the same when
	// the summary is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate evidence
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// Description, classification, and definition of a single variable. The
	// collection of variables defines what the evidence is about.
	VariableDefinition []EvidenceVariableDefinition `json:"variableDefinition,omitempty"`

	// The identifier that is used to identify this version of the summary when it is
	// referenced in a specification, model, design or instance. This is an arbitrary
	// value managed by the summary author and is not expected to be globally unique.
	// For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
	// not available. There is also no expectation that versions can be placed in a
	// lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceAttributeEstimate struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for level
	Level *Element `json:"_level,omitempty"`

	// A nested attribute estimate; which is the attribute estimate of an attribute
	// estimate.
	AttributeEstimate []EvidenceAttributeEstimate `json:"attributeEstimate,omitempty"`

	// Human-readable summary of the estimate.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Use 0.95 for a 95% confidence interval.
	Level_2 *Decimal `json:"level,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Footnote or explanatory note about the estimate.
	Note []Annotation `json:"note,omitempty"`

	// The singular quantity of the attribute estimate, for attribute estimates
	// represented as single values, which may include a unit of measure.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Lower and upper bound values of the attribute estimate.
	Range *Range `json:"range,omitempty"`

	// The type of attribute estimate, e.g., confidence interval or p value.
	Type *CodeableConcept `json:"type,omitempty"`
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceCertainty struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for rater
	Rater []Element `json:"_rater,omitempty"`

	// Textual description of certainty.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Footnotes and/or explanatory notes.
	Note []Annotation `json:"note,omitempty"`

	// Individual or group who did the rating.
	Rater_2 []String `json:"rater,omitempty"`

	// Assessment or judgement of the aspect.
	Rating *CodeableConcept `json:"rating,omitempty"`

	// A domain or subdomain of certainty.
	Subcomponent []EvidenceCertainty `json:"subcomponent,omitempty"`

	// Aspect of certainty being rated.
	Type *CodeableConcept `json:"type,omitempty"`
}

type EvidenceContainedElem interface{}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceModelCharacteristic struct {
	// Extensions for applied
	Applied *Element `json:"_applied,omitempty"`

	// Extensions for intended
	Intended *Element `json:"_intended,omitempty"`

	// This model characteristic is part of the analysis that was applied, whether or
	// not the analysis followed the plan.
	Applied_2 *Boolean `json:"applied,omitempty"`

	// An attribute of the model characteristic.
	Attribute []EvidenceAttributeEstimate `json:"attribute,omitempty"`

	// Description of a component of the method to generate the statistic.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The plan for analysis.
	Intended_2 *Boolean `json:"intended,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Further specification of the value of the component of the method to generate
	// the statistic.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Further specification of the value of the component of the method to generate
	// the statistic.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Further specification of the value of the component of the method to generate
	// the statistic.
	ValueRange *Range `json:"valueRange,omitempty"`

	// A variable adjusted for in the adjusted analysis.
	Variable []EvidenceVariable `json:"variable,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceModelCharacteristic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in EvidenceModelCharacteristic: required")
	}
	type Plain EvidenceModelCharacteristic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EvidenceModelCharacteristic(plain)
	return nil
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceRelatesTo struct {
	// Extensions for targetCanonical
	TargetCanonical *Element `json:"_targetCanonical,omitempty"`

	// Extensions for targetMarkdown
	TargetMarkdown *Element `json:"_targetMarkdown,omitempty"`

	// Extensions for targetUri
	TargetUri *Element `json:"_targetUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The artifact that is related to this Evidence Resource.
	TargetAttachment *Attachment `json:"targetAttachment,omitempty"`

	// The artifact that is related to this Evidence Resource.
	TargetCanonical_2 *string `json:"targetCanonical,omitempty"`

	// The artifact that is related to this Evidence Resource.
	TargetMarkdown_2 *string `json:"targetMarkdown,omitempty"`

	// The artifact that is related to this Evidence Resource.
	TargetReference *Reference `json:"targetReference,omitempty"`

	// The artifact that is related to this Evidence Resource.
	TargetUri_2 *string `json:"targetUri,omitempty"`

	// The type of relationship to the related artifact.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EvidenceRelatesTo: required")
	}
	type Plain EvidenceRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.TargetUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetUri_2", `^\S*$`)
		}
	}
	*j = EvidenceRelatesTo(plain)
	return nil
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceSampleSize struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for knownDataCount
	KnownDataCount *Element `json:"_knownDataCount,omitempty"`

	// Extensions for numberAnalyzed
	NumberAnalyzed *Element `json:"_numberAnalyzed,omitempty"`

	// Extensions for numberOfParticipants
	NumberOfParticipants *Element `json:"_numberOfParticipants,omitempty"`

	// Extensions for numberOfStudies
	NumberOfStudies *Element `json:"_numberOfStudies,omitempty"`

	// Human-readable summary of study sample size. A human-readable string to clarify
	// or explain concepts about the sample size.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Number of participants with known results for measured variables.
	KnownDataCount_2 *UnsignedInt `json:"knownDataCount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Footnote or explanatory note about the sample size.
	Note []Annotation `json:"note,omitempty"`

	// Total number of participants who were analayzed.
	NumberAnalyzed_2 *UnsignedInt `json:"numberAnalyzed,omitempty"`

	// Count of members in the total sample for the statistic.
	NumberOfParticipants_2 *UnsignedInt `json:"numberOfParticipants,omitempty"`

	// Count of studies or samples combined to become the total sample for the
	// statistic.
	NumberOfStudies_2 *UnsignedInt `json:"numberOfStudies,omitempty"`
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceStatistic struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for numberAffected
	NumberAffected *Element `json:"_numberAffected,omitempty"`

	// Extensions for numberOfEvents
	NumberOfEvents *Element `json:"_numberOfEvents,omitempty"`

	// A statistical attribute of the statistic such as a measure of heterogeneity.
	AttributeEstimate []EvidenceAttributeEstimate `json:"attributeEstimate,omitempty"`

	// When the measured variable (outcome) is handled categorically, the category
	// element is used to define which category the statistic is reporting.
	Category *CodeableConcept `json:"category,omitempty"`

	// A natural language summary of the statistic.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A component of the method to generate the statistic.
	ModelCharacteristic []EvidenceModelCharacteristic `json:"modelCharacteristic,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Footnotes and/or explanatory notes.
	Note []Annotation `json:"note,omitempty"`

	// The number of participants affected where the unit of analysis is the same as
	// sampleSize.knownDataCount and sampleSize.numberOfParticipants.
	NumberAffected_2 *UnsignedInt `json:"numberAffected,omitempty"`

	// The number of events associated with the statistic, where the unit of analysis
	// is different from numberAffected, sampleSize.knownDataCount and
	// sampleSize.numberOfParticipants.
	NumberOfEvents_2 *UnsignedInt `json:"numberOfEvents,omitempty"`

	// Statistic value.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Count of participants in the study sample.
	SampleSize *EvidenceSampleSize `json:"sampleSize,omitempty"`

	// Type of statistic, e.g., relative risk. The statistic type is a classification
	// that formally defines the relationship between the variables (noted in
	// Evidence.variableDefinition) and the value specification (noted in
	// Evidence.statistic.quantity).
	StatisticType *CodeableConcept `json:"statisticType,omitempty"`
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceVariable struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// How the variable is classified for use in adjusted analysis.
	Handling *CodeableConcept `json:"handling,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Qualitative label used for grouping values of a dichotomous, ordinal, or
	// polychotomous variable.
	ValueCategory []CodeableConcept `json:"valueCategory,omitempty"`

	// Quantitative label used for grouping values of a dichotomous, ordinal, or
	// polychotomous variable.
	ValueQuantity []Quantity `json:"valueQuantity,omitempty"`

	// Range of quantitative labels used for grouping values of a dichotomous,
	// ordinal, or polychotomous variable.
	ValueRange []Range `json:"valueRange,omitempty"`

	// Description and definition of the variable.
	VariableDefinition Reference `json:"variableDefinition"`
}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariableCategory struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Description of the grouping.
	Name_2 *String `json:"name,omitempty"`

	// Definition of the grouping.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Definition of the grouping.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Definition of the grouping.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Definition of the grouping.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariableConstraint struct {
	// Extensions for anyValueAllowed
	AnyValueAllowed *Element `json:"_anyValueAllowed,omitempty"`

	// Extensions for earliestDateTime
	EarliestDateTime *Element `json:"_earliestDateTime,omitempty"`

	// Extensions for latestDateTime
	LatestDateTime *Element `json:"_latestDateTime,omitempty"`

	// Extensions for maximumStringLength
	MaximumStringLength *Element `json:"_maximumStringLength,omitempty"`

	// Extensions for minimumStringLength
	MinimumStringLength *Element `json:"_minimumStringLength,omitempty"`

	// Whether the value expressed for a variable is allowed to not be restricted to
	// the expected value set.
	AnyValueAllowed_2 *Boolean `json:"anyValueAllowed,omitempty"`

	// A rule, such as a format or other expectation, for the data values.
	Code *CodeableConcept `json:"code,omitempty"`

	// The context, situation, or parameters that determine whether this constraint
	// applies.
	Conditional *CodeableConcept `json:"conditional,omitempty"`

	// The earliest permissible value of the variable, used with variables that have a
	// date-based or dateTime-based datatype.
	EarliestDateTime_2 *DateTime `json:"earliestDateTime,omitempty"`

	// List of anticipated values used to express units for the value of the variable,
	// used with variables that have a Quantity-based datatype.
	ExpectedUnitsValueSet *Reference `json:"expectedUnitsValueSet,omitempty"`

	// List of anticipated values used to express value of the variable, used with
	// variables that have a codeable concept-based datatype.
	ExpectedValueSet *Reference `json:"expectedValueSet,omitempty"`

	// A rule, such as a format or other expectation, for the data values, expressed
	// as an Expression.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The latest permissible value of the variable, used with variables that have a
	// date-based or dateTime-based datatype.
	LatestDateTime_2 *DateTime `json:"latestDateTime,omitempty"`

	// The highest permissible value of the variable, used with variables that have a
	// number-based datatype (with or without units).
	MaximumQuantity *Quantity `json:"maximumQuantity,omitempty"`

	// The highest number of characters allowed for a value of the variable, used with
	// variables that have a string-based datatype.
	MaximumStringLength_2 *PositiveInt `json:"maximumStringLength,omitempty"`

	// The lowest permissible value of the variable, used with variables that have a
	// number-based datatype (with or without units).
	MinimumQuantity *Quantity `json:"minimumQuantity,omitempty"`

	// The lowest number of characters allowed for a value of the variable, used with
	// variables that have a string-based datatype.
	MinimumStringLength_2 *UnsignedInt `json:"minimumStringLength,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type EvidenceVariableContainedElem interface{}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariableDataStorage struct {
	// Extensions for delimiter
	Delimiter *Element `json:"_delimiter,omitempty"`

	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// A part of the value for a variable that is stored in 2 or more parts.
	Component []EvidenceVariableDataStorage `json:"component,omitempty"`

	// The type of data used to express values of the variable.
	Datatype *CodeableConcept `json:"datatype,omitempty"`

	// A character or series of characters that is used within a string to signal the
	// separation of discrete values.
	Delimiter_2 *String `json:"delimiter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The mapping (order of elements) to reach the element containing the  data
	// element in the dataset.
	Path_2 *String `json:"path,omitempty"`
}

// The Evidence Resource provides a machine-interpretable expression of an evidence
// concept including the evidence variables (e.g., population,
// exposures/interventions, comparators, outcomes, measured variables, confounding
// variables), the statistics, and the certainty of this evidence.
type EvidenceVariableDefinition struct {
	// Extensions for comparatorCategory
	ComparatorCategory *Element `json:"_comparatorCategory,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for variableRole
	VariableRole *Element `json:"_variableRole,omitempty"`

	// The reference value used for comparison.
	ComparatorCategory_2 *String `json:"comparatorCategory,omitempty"`

	// A text description or summary of the variable.
	Description_2 *Markdown `json:"description,omitempty"`

	// Indication of quality of match between intended variable to actual variable.
	DirectnessMatch *CodeableConcept `json:"directnessMatch,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Definition of the intended variable related to the Evidence, i.e., the
	// population, exposure, or outcome for which the statistical finding is being
	// interpreted.
	Intended *Reference `json:"intended,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Footnotes and/or explanatory notes.
	Note []Annotation `json:"note,omitempty"`

	// Definition of the actual variable related to the statistic(s), i.e., the
	// population being the actual study sample or the measured variable (exposure,
	// outcome, or covariate) being the actual observation that occurred or will occur
	// in the study.
	Observed *Reference `json:"observed,omitempty"`

	// Sub-classification of the role of the variable.
	RoleSubtype *CodeableConcept `json:"roleSubtype,omitempty"`

	// Classification of the role of the variable.
	VariableRole_2 *Code `json:"variableRole,omitempty"`
}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariableDefinitionModifier struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Attribute of the definition.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Specification of the definition attribute.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Specification of the definition attribute.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Specification of the definition attribute.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Specification of the definition attribute.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Specification of the definition attribute.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Specification of the definition attribute.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Specification of the definition attribute.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Specification of the definition attribute.
	ValueRelativeTime *RelativeTime `json:"valueRelativeTime,omitempty"`

	// Specification of the definition attribute.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceVariableDefinitionModifier) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in EvidenceVariableDefinitionModifier: required")
	}
	type Plain EvidenceVariableDefinitionModifier
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = EvidenceVariableDefinitionModifier(plain)
	return nil
}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariableRelatesTo struct {
	// Extensions for targetCanonical
	TargetCanonical *Element `json:"_targetCanonical,omitempty"`

	// Extensions for targetMarkdown
	TargetMarkdown *Element `json:"_targetMarkdown,omitempty"`

	// Extensions for targetUri
	TargetUri *Element `json:"_targetUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The artifact that is related to this EvidenceVariable Resource.
	TargetAttachment *Attachment `json:"targetAttachment,omitempty"`

	// The artifact that is related to this EvidenceVariable Resource.
	TargetCanonical_2 *string `json:"targetCanonical,omitempty"`

	// The artifact that is related to this EvidenceVariable Resource.
	TargetMarkdown_2 *string `json:"targetMarkdown,omitempty"`

	// The artifact that is related to this EvidenceVariable Resource.
	TargetReference *Reference `json:"targetReference,omitempty"`

	// The artifact that is related to this EvidenceVariable Resource.
	TargetUri_2 *string `json:"targetUri,omitempty"`

	// The type of relationship to the related artifact.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceVariableRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EvidenceVariableRelatesTo: required")
	}
	type Plain EvidenceVariableRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.TargetUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetUri_2", `^\S*$`)
		}
	}
	*j = EvidenceVariableRelatesTo(plain)
	return nil
}

// The EvidenceVariable resource describes an element that knowledge (Evidence) is
// about.
type EvidenceVariable_1 struct {
	// Extensions for actual
	Actual *Element `json:"_actual,omitempty"`

	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for citeAs
	CiteAs *Element `json:"_citeAs,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for shortTitle
	ShortTitle *Element `json:"_shortTitle,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// True if the actual variable measured, false if a conceptual representation of
	// the intended variable.
	Actual_2 *Boolean `json:"actual,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	//
	// See guidance around (not) making local changes to elements
	// [here](canonicalresource.html#localization).
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// A grouping for dichotomous, ordinal, or polychotomouos variables.
	Category []EvidenceVariableCategory `json:"category,omitempty"`

	// Display of the suggested method of how to cite this EvidenceVariable.
	CiteAs_2 *Markdown `json:"citeAs,omitempty"`

	// Classification of the variable.
	Classifier []CodeableConcept `json:"classifier,omitempty"`

	// The context, situation, or parameters that determine whether the data is
	// obtained to determine the value of the variable.
	Conditional *Expression `json:"conditional,omitempty"`

	// Limit on acceptability of data used to express values of the variable.
	Constraint []EvidenceVariableConstraint `json:"constraint,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []EvidenceVariableContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the EvidenceVariable and/or its contents.
	// Copyright statements are legal notices of intellectual property ownership and
	// may include restrictions on the use and publishing of the EvidenceVariable.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted . (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// How the data element is organized and where the data element (expressing the
	// value of the variable) is found in the dataset.
	DataStorage []EvidenceVariableDataStorage `json:"dataStorage,omitempty"`

	// The date  (and optionally time) when the evidence variable was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the evidence variable changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// The meaning of the evidence variable.
	Definition *CodeableReference `json:"definition,omitempty"`

	// Further specification of the definition.
	DefinitionModifier []EvidenceVariableDefinitionModifier `json:"definitionModifier,omitempty"`

	// A natural language summary of the evidence variable.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the resource content was or is planned to be in active
	// use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this resource is authored for testing purposes
	// (or education/evaluation/marketing) and no version of this resource will ever
	// be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The method of handling in statistical analysis.
	Handling *CodeableConcept `json:"handling,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this evidence variable when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// A method or transformation applied for missing data.
	MissingDataMeaning []CodeableConcept `json:"missingDataMeaning,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the evidence variable. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// A human-readable string to clarify or explain concepts about the resource.
	Note []Annotation `json:"note,omitempty"`

	// When the variable is observed in relation to calendar dates and times.
	Period *Period `json:"period,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the evidence variable.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this EvidenceVariable is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// The person or entity that entered the data into the EvidenceVariable Resource
	// instance, if different than the author or creator of the intellectual property
	// contained within the EvidenceVariable Resource instance.
	Recorder []ContactDetail `json:"recorder,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// Relationships that this EvidenceVariable has with other FHIR or non-FHIR
	// resources that already exist.
	RelatesTo []EvidenceVariableRelatesTo `json:"relatesTo,omitempty"`

	// This is a EvidenceVariable resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The short title provides an alternate title for use in informal descriptive
	// contexts where the full, formal title is not necessary.
	ShortTitle_2 *String `json:"shortTitle,omitempty"`

	// The status of this EvidenceVariable. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// When the variable is observed in relation to a reference point in time defined
	// by context or event.
	Timing *RelativeTime `json:"timing,omitempty"`

	// A short, descriptive, user-friendly title for the evidence variable.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the {{title}}. Topics provide a
	// high-level categorization as well as keywords for the {{title}} that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// A method or transformation applied for data that does not match required
	// patterns.
	UnacceptableDataHandling []CodeableConcept `json:"unacceptableDataHandling,omitempty"`

	// An absolute URI that is used to identify this evidence variable when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this evidence variable is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the evidence variable is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate evidence variable
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the evidence variable
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the evidence variable author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence. To provide a version consistent
	// with the Decision Support Service specification, use the format
	// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge
	// assets, refer to the Decision Support Service specification. Note that a
	// version is required for non-experimental active artifacts.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceVariable_1) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in EvidenceVariable_1: required")
	}
	type Plain EvidenceVariable_1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = EvidenceVariable_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EvidenceVariable) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["variableDefinition"]; raw != nil && !ok {
		return fmt.Errorf("field variableDefinition in EvidenceVariable: required")
	}
	type Plain EvidenceVariable
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EvidenceVariable(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Evidence) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Evidence: required")
	}
	type Plain Evidence
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Evidence(plain)
	return nil
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenario struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// A system or person who shares or receives an instance within the scenario.
	Actor []ExampleScenarioActor `json:"actor,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ExampleScenarioContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the example scenario and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the example scenario.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the example scenario was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the example scenario changes. (e.g. the
	// 'content logical definition').
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the ExampleScenario from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this example scenario is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this example scenario when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A single data collection that is shared as part of the scenario.
	Instance []ExampleScenarioInstance `json:"instance,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the ExampleScenario. This name should be
	// usable as an identifier for the resource by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// A group of operations that represents a significant step within a scenario.
	Process []ExampleScenarioProcess `json:"process,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the example scenario.
	Publisher_2 *String `json:"publisher,omitempty"`

	// What the example scenario resource is created for. This should not be used to
	// show the business purpose of the scenario itself, but the purpose of
	// documenting a scenario.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a ExampleScenario resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this example scenario. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the ExampleScenario.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this example scenario when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this example scenario is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the example scenario is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate example scenario
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the example scenario
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the example scenario author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioActor struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// The formal definition of the actor in the scenario.
	Definition *Canonical `json:"definition,omitempty"`

	// An explanation of who/what the actor is and its role in the scenario.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A unique string within the scenario that is used to reference the actor.
	Key_2 *String `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The human-readable name for the actor used when rendering the scenario.
	Title_2 *String `json:"title,omitempty"`

	// The category of actor - person or system.
	Type_2 *Code `json:"type,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioAlternative struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// A human-readable description of the alternative explaining when the alternative
	// should occur rather than the base step.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the operation, sub-process or scenario that happens if the
	// alternative option is selected.
	Step []ExampleScenarioStep `json:"step,omitempty"`

	// The label to display for the alternative that gives a sense of the circumstance
	// in which the alternative should be invoked.
	Title_2 *String `json:"title,omitempty"`
}

type ExampleScenarioContainedElem interface{}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioContainedInstance struct {
	// Extensions for instanceReference
	InstanceReference *Element `json:"_instanceReference,omitempty"`

	// Extensions for versionReference
	VersionReference *Element `json:"_versionReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A reference to the key of an instance found within this one.
	InstanceReference_2 *String `json:"instanceReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to the key of a specific version of an instance in this instance.
	VersionReference_2 *String `json:"versionReference,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioInstance struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for structureProfileCanonical
	StructureProfileCanonical *Element `json:"_structureProfileCanonical,omitempty"`

	// Extensions for structureProfileUri
	StructureProfileUri *Element `json:"_structureProfileUri,omitempty"`

	// Extensions for structureVersion
	StructureVersion *Element `json:"_structureVersion,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// References to other instances that can be found within this instance (e.g. the
	// observations contained in a bundle).
	ContainedInstance []ExampleScenarioContainedInstance `json:"containedInstance,omitempty"`

	// Points to an instance (typically an example) that shows the data that would
	// corespond to this instance.
	Content *Reference `json:"content,omitempty"`

	// An explanation of what the instance contains and what it's for.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A unique string within the scenario that is used to reference the instance.
	Key_2 *String `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Refers to a profile, template or other ruleset the instance adheres to.
	StructureProfileCanonical_2 *string `json:"structureProfileCanonical,omitempty"`

	// Refers to a profile, template or other ruleset the instance adheres to.
	StructureProfileUri_2 *string `json:"structureProfileUri,omitempty"`

	// A code indicating the kind of data structure (FHIR resource or some other
	// standard) this is an instance of.
	StructureType Coding `json:"structureType"`

	// Conveys the version of the data structure instantiated.  I.e. what release of
	// FHIR, X12, OpenEHR, etc. is instance compliant with.
	StructureVersion_2 *String `json:"structureVersion,omitempty"`

	// A short descriptive label the instance to be used in tables or diagrams.
	Title_2 *String `json:"title,omitempty"`

	// Represents the instance as it was at a specific time-point.
	Version []ExampleScenarioVersion `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExampleScenarioInstance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["structureType"]; raw != nil && !ok {
		return fmt.Errorf("field structureType in ExampleScenarioInstance: required")
	}
	type Plain ExampleScenarioInstance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.StructureProfileCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.StructureProfileCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "StructureProfileCanonical_2", `^\S*$`)
		}
	}
	if plain.StructureProfileUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.StructureProfileUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "StructureProfileUri_2", `^\S*$`)
		}
	}
	*j = ExampleScenarioInstance(plain)
	return nil
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioOperation struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for initiator
	Initiator *Element `json:"_initiator,omitempty"`

	// Extensions for initiatorActive
	InitiatorActive *Element `json:"_initiatorActive,omitempty"`

	// Extensions for receiver
	Receiver *Element `json:"_receiver,omitempty"`

	// Extensions for receiverActive
	ReceiverActive *Element `json:"_receiverActive,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// An explanation of what the operation represents and what it does.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The system that invokes the action/transmits the data.
	Initiator_2 *String `json:"initiator,omitempty"`

	// If false, the initiator is deactivated right after the operation.
	InitiatorActive_2 *Boolean `json:"initiatorActive,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The system on which the action is invoked/receives the data.
	Receiver_2 *String `json:"receiver,omitempty"`

	// If false, the receiver is deactivated right after the operation.
	ReceiverActive_2 *Boolean `json:"receiverActive,omitempty"`

	// A reference to the instance that is transmitted from requester to receiver as
	// part of the invocation of the operation.
	Request *ExampleScenarioContainedInstance `json:"request,omitempty"`

	// A reference to the instance that is transmitted from receiver to requester as
	// part of the operation's synchronous response (if any).
	Response *ExampleScenarioContainedInstance `json:"response,omitempty"`

	// A short descriptive label the step to be used in tables or diagrams.
	Title_2 *String `json:"title,omitempty"`

	// The standardized type of action (FHIR or otherwise).
	Type *Coding `json:"type,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioProcess struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for postConditions
	PostConditions *Element `json:"_postConditions,omitempty"`

	// Extensions for preConditions
	PreConditions *Element `json:"_preConditions,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// An explanation of what the process represents and what it does.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Description of the final state of the actors, environment and data after the
	// process has been successfully completed.
	PostConditions_2 *Markdown `json:"postConditions,omitempty"`

	// Description of the initial state of the actors, environment and data before the
	// process starts.
	PreConditions_2 *Markdown `json:"preConditions,omitempty"`

	// A significant action that occurs as part of the process.
	Step []ExampleScenarioStep `json:"step,omitempty"`

	// A short descriptive label the process to be used in tables or diagrams.
	Title_2 *String `json:"title,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioStep struct {
	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for pause
	Pause *Element `json:"_pause,omitempty"`

	// Indicates an alternative step that can be taken instead of the sub-process,
	// scenario or operation.  E.g. to represent non-happy-path/exceptional/atypical
	// circumstances.
	Alternative []ExampleScenarioAlternative `json:"alternative,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The sequence number of the step, e.g. 1.2.5.
	Number_2 *String `json:"number,omitempty"`

	// The step represents a single operation invoked on receiver by sender.
	Operation *ExampleScenarioOperation `json:"operation,omitempty"`

	// If true, indicates that, following this step, there is a pause in the flow and
	// the subsequent step will occur at some later time (triggered by some event).
	Pause_2 *Boolean `json:"pause,omitempty"`

	// Indicates that the step is a complex sub-process with its own steps.
	Process *ExampleScenarioProcess `json:"process,omitempty"`

	// Indicates that the step is defined by a seaparate scenario instance.
	Workflow *Canonical `json:"workflow,omitempty"`
}

// A computable description of the actors, interactions between those actors that
// would occur, and concrete examples of the data that would be exchanged in a
// specific hypothetical exchange, typically used to help demonstrate the
// interoperability expectations of a specification.  This resource is used to
// illustrate a specific time-based exchange, not to define in general terms how
// exchanges can/should occur.
type ExampleScenarioVersion struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Points to an instance (typically an example) that shows the data that would
	// flow at this point in the scenario.
	Content *Reference `json:"content,omitempty"`

	// An explanation of what this specific version of the instance contains and
	// represents.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A unique string within the instance that is used to reference the version of
	// the instance.
	Key_2 *String `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A short descriptive label the version to be used in tables or diagrams.
	Title_2 *String `json:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExampleScenario) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ExampleScenario: required")
	}
	type Plain ExampleScenario
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ExampleScenario(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefit struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outcome
	Outcome *Element `json:"_outcome,omitempty"`

	// Extensions for preAuthRef
	PreAuthRef []Element `json:"_preAuthRef,omitempty"`

	// Extensions for precedence
	Precedence *Element `json:"_precedence,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// Details of a accident which resulted in injuries which required the products
	// and services listed in the claim.
	Accident *ExplanationOfBenefitAccident `json:"accident,omitempty"`

	// The first-tier service adjudications for payer added product or service lines.
	AddItem []ExplanationOfBenefitAddItem `json:"addItem,omitempty"`

	// The adjudication results which are presented at the header level rather than at
	// the line-item or add-item levels.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// Balance by Benefit Category.
	BenefitBalance []ExplanationOfBenefitBenefitBalance `json:"benefitBalance,omitempty"`

	// The term of the benefits documented in this response.
	BenefitPeriod *Period `json:"benefitPeriod,omitempty"`

	// The period for which charges are being submitted.
	BillablePeriod *Period `json:"billablePeriod,omitempty"`

	// The members of the team who provided the products and services.
	CareTeam []ExplanationOfBenefitCareTeam `json:"careTeam,omitempty"`

	// The business identifier for the instance of the adjudication request: claim
	// predetermination or preauthorization.
	Claim *Reference `json:"claim,omitempty"`

	// The business identifier for the instance of the adjudication response: claim,
	// predetermination or preauthorization response.
	ClaimResponse *Reference `json:"claimResponse,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ExplanationOfBenefitContainedElem `json:"contained,omitempty"`

	// The date this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// The result of the claim, predetermination, or preauthorization adjudication.
	Decision *CodeableConcept `json:"decision,omitempty"`

	// Information about diagnoses relevant to the claim items.
	Diagnosis []ExplanationOfBenefitDiagnosis `json:"diagnosis,omitempty"`

	// A package billing code or bundle code used to group products and services to a
	// particular health condition (such as heart attack) which is based on a
	// predetermined grouping code system.
	DiagnosisRelatedGroup *CodeableConcept `json:"diagnosisRelatedGroup,omitempty"`

	// A human readable description of the status of the adjudication.
	Disposition_2 *String `json:"disposition,omitempty"`

	// Healthcare encounters related to this claim.
	Encounter []Reference `json:"encounter,omitempty"`

	// Individual who created the claim, predetermination or preauthorization.
	Enterer *Reference `json:"enterer,omitempty"`

	// Information code for an event with a corresponding date or period.
	Event []ExplanationOfBenefitEvent `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Facility where the services were provided.
	Facility *Reference `json:"facility,omitempty"`

	// The actual form, by reference or inclusion, for printing the content or an EOB.
	Form *Attachment `json:"form,omitempty"`

	// A code for the form to be used for printing the content.
	FormCode *CodeableConcept `json:"formCode,omitempty"`

	// A code, used only on a response to a preauthorization, to indicate whether the
	// benefits payable have been reserved and for whom.
	FundsReserve *CodeableConcept `json:"fundsReserve,omitempty"`

	// A code to indicate whether and for whom funds are to be reserved for future
	// claims.
	FundsReserveRequested *CodeableConcept `json:"fundsReserveRequested,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this explanation of benefit.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Financial instruments for reimbursement for the health care products and
	// services specified on the claim.
	Insurance []ExplanationOfBenefitInsurance `json:"insurance,omitempty"`

	// The party responsible for authorization, adjudication and reimbursement.
	Insurer *Reference `json:"insurer,omitempty"`

	// A claim line. Either a simple (a product or service) or a 'group' of details
	// which can also be a simple items or groups of sub-details.
	Item []ExplanationOfBenefitItem `json:"item,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Original prescription which has been superseded by this prescription to support
	// the dispensing of pharmacy services, medications or products.
	OriginalPrescription *Reference `json:"originalPrescription,omitempty"`

	// The outcome of the claim, predetermination, or preauthorization processing.
	Outcome_2 *Code `json:"outcome,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// The party to be reimbursed for cost of the products and services according to
	// the terms of the policy.
	Payee *ExplanationOfBenefitPayee `json:"payee,omitempty"`

	// Payment details for the adjudication of the claim.
	Payment *ExplanationOfBenefitPayment `json:"payment,omitempty"`

	// Reference from the Insurer which is used in later communications which refers
	// to this adjudication.
	PreAuthRef_2 []String `json:"preAuthRef,omitempty"`

	// The timeframe during which the supplied preauthorization reference may be
	// quoted on claims to obtain the adjudication as provided.
	PreAuthRefPeriod []Period `json:"preAuthRefPeriod,omitempty"`

	// This indicates the relative order of a series of EOBs related to different
	// coverages for the same suite of services.
	Precedence_2 *PositiveInt `json:"precedence,omitempty"`

	// Prescription is the document/authorization given to the claim author for them
	// to provide products and services for which consideration (reimbursement) is
	// sought. Could be a RX for medications, an 'order' for oxygen or wheelchair or
	// physiotherapy treatments.
	Prescription *Reference `json:"prescription,omitempty"`

	// The provider-required urgency of processing the request. Typical values
	// include: stat, normal deferred.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// Procedures performed on the patient relevant to the billing items with the
	// claim.
	Procedure []ExplanationOfBenefitProcedure `json:"procedure,omitempty"`

	// A note that describes or explains adjudication results in a human readable
	// form.
	ProcessNote []ExplanationOfBenefitProcessNote `json:"processNote,omitempty"`

	// The provider which is responsible for the claim, predetermination or
	// preauthorization.
	Provider *Reference `json:"provider,omitempty"`

	// The referral information received by the claim author, it is not to be used
	// when the author generates a referral for a patient. A copy of that referral may
	// be provided as supporting information. Some insurers require proof of referral
	// to pay for services or to pay specialist rates for services.
	Referral *Reference `json:"referral,omitempty"`

	// Other claims which are related to this claim such as prior submissions or
	// claims for related services or for the same event.
	Related []ExplanationOfBenefitRelated `json:"related,omitempty"`

	// This is a ExplanationOfBenefit resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// A finer grained suite of claim type codes which may convey additional
	// information such as Inpatient vs Outpatient and/or a specialty service.
	SubType *CodeableConcept `json:"subType,omitempty"`

	// The party/group to whom the professional services and/or products have been
	// supplied or are being considered and for whom actual for forecast reimbursement
	// is sought.
	Subject Reference `json:"subject"`

	// Additional information codes regarding exceptions, special considerations, the
	// condition, situation, prior or concurrent issues.
	SupportingInfo []ExplanationOfBenefitSupportingInfo `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Categorized monetary totals for the adjudication.
	Total []ExplanationOfBenefitTotal `json:"total,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// The category of claim, e.g. oral, pharmacy, vision, institutional,
	// professional.
	Type CodeableConcept `json:"type"`

	// A code to indicate whether the nature of the request is: Claim - A request to
	// an Insurer to adjudicate the supplied charges for health care goods and
	// services under the identified policy and to pay the determined Benefit amount,
	// if any; Preauthorization - A request to an Insurer to adjudicate the supplied
	// proposed future charges for health care goods and services under the identified
	// policy and to approve the services and provide the expected benefit amounts and
	// potentially to reserve funds to pay the benefits when Claims for the indicated
	// services are later submitted; or, Pre-determination - A request to an Insurer
	// to adjudicate the supplied 'what if' charges for health care goods and services
	// under the identified policy and report back what the Benefit payable would be
	// had the services actually been provided.
	Use_2 *Code `json:"use,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitAccident struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Date of an accident event  related to the products and services contained in
	// the claim.
	Date_2 *Date `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The physical location of the accident event.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// The physical location of the accident event.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type or context of the accident event for the purposes of selection of
	// potential insurance coverages and determination of coordination between
	// insurers.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitAddItem struct {
	// Extensions for detailSequence
	DetailSequence []Element `json:"_detailSequence,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for informationSequence
	InformationSequence []Element `json:"_informationSequence,omitempty"`

	// Extensions for itemSequence
	ItemSequence []Element `json:"_itemSequence,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// Extensions for subDetailSequence
	SubDetailSequence []Element `json:"_subDetailSequence,omitempty"`

	// The adjudication results.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// Physical location where the service is performed or applies.
	BodySite []ExplanationOfBenefitBodySite1 `json:"bodySite,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// The second-tier service adjudications for payer added services.
	Detail []ExplanationOfBenefitDetail1 `json:"detail,omitempty"`

	// The sequence number of the details within the claim item which this line is
	// intended to replace.
	DetailSequence_2 []PositiveInt `json:"detailSequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product.
	InformationSequence_2 []PositiveInt `json:"informationSequence,omitempty"`

	// Claim items which this service line is intended to replace.
	ItemSequence_2 []PositiveInt `json:"itemSequence,omitempty"`

	// Where the product or service was provided.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// Where the product or service was provided.
	LocationCodeableConcept *CodeableConcept `json:"locationCodeableConcept,omitempty"`

	// Where the product or service was provided.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the addItem. Net =
	// unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The providers who are authorized for the services rendered to the patient.
	Provider []Reference `json:"provider,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Request or Referral for Goods or Service to be rendered.
	Request []Reference `json:"request,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The sequence number of the sub-details woithin the details within the claim
	// item which this line is intended to replace.
	SubDetailSequence_2 []PositiveInt `json:"subDetailSequence,omitempty"`

	// The party to whom the professional services and/or products have been supplied
	// or are being considered and for whom actual for facast reimbursement is sought.
	Subject *Reference `json:"subject,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitAddItem) UnmarshalJSON(value []byte) error {
	type Plain ExplanationOfBenefitAddItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = ExplanationOfBenefitAddItem(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitAdjudication struct {
	// Extensions for decisionDate
	DecisionDate *Element `json:"_decisionDate,omitempty"`

	// Monetary amount associated with the category.
	Amount *Money `json:"amount,omitempty"`

	// A code to indicate the information type of this adjudication record.
	// Information types may include: the value submitted, maximum values or
	// percentages allowed or payable under the plan, amounts that the patient is
	// responsible for in-aggregate or pertaining to this item, amounts paid by other
	// coverages, and the benefit payable for this item.
	Category CodeableConcept `json:"category"`

	// The date and time the adjudication decision occured.
	DecisionDate_2 *DateTime `json:"decisionDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A non-monetary value associated with the category. Mutually exclusive to the
	// amount element above.
	Quantity *Quantity `json:"quantity,omitempty"`

	// A code supporting the understanding of the adjudication result and explaining
	// variance from expected amount.
	Reason *CodeableConcept `json:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitAdjudication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ExplanationOfBenefitAdjudication: required")
	}
	type Plain ExplanationOfBenefitAdjudication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitAdjudication(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitBenefitBalance struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for excluded
	Excluded *Element `json:"_excluded,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category CodeableConcept `json:"category"`

	// A richer description of the benefit or services covered.
	Description_2 *String `json:"description,omitempty"`

	// True if the indicated class of service is excluded from the plan, missing or
	// False indicates the product or service is included in the coverage.
	Excluded_2 *Boolean `json:"excluded,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Benefits Used to date.
	Financial []ExplanationOfBenefitFinancial `json:"financial,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A short name or tag for the benefit.
	Name_2 *String `json:"name,omitempty"`

	// Is a flag to indicate whether the benefits refer to in-network providers or
	// out-of-network providers.
	Network *CodeableConcept `json:"network,omitempty"`

	// The term or period of the values such as 'maximum lifetime benefit' or 'maximum
	// annual visits'.
	Term *CodeableConcept `json:"term,omitempty"`

	// Indicates if the benefits apply to an individual or to the family.
	Unit *CodeableConcept `json:"unit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitBenefitBalance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ExplanationOfBenefitBenefitBalance: required")
	}
	type Plain ExplanationOfBenefitBenefitBalance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitBenefitBalance(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitBodySite struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Physical service site on the patient (limb, tooth, etc.).
	Site []CodeableReference `json:"site"`

	// A region or surface of the bodySite, e.g. limb region or tooth surface(s).
	SubSite []CodeableConcept `json:"subSite,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitBodySite1 struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Physical service site on the patient (limb, tooth, etc.).
	Site []CodeableReference `json:"site"`

	// A region or surface of the bodySite, e.g. limb region or tooth surface(s).
	SubSite []CodeableConcept `json:"subSite,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitBodySite1) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["site"]; raw != nil && !ok {
		return fmt.Errorf("field site in ExplanationOfBenefitBodySite1: required")
	}
	type Plain ExplanationOfBenefitBodySite1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitBodySite1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitBodySite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["site"]; raw != nil && !ok {
		return fmt.Errorf("field site in ExplanationOfBenefitBodySite: required")
	}
	type Plain ExplanationOfBenefitBodySite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitBodySite(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitCareTeam struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Member of the team who provided the product or service.
	Provider Reference `json:"provider"`

	// The lead, assisting or supervising practitioner and their discipline if a
	// multidisciplinary team.
	Role *CodeableConcept `json:"role,omitempty"`

	// A number to uniquely identify care team entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The specialization of the practitioner or provider which is applicable for this
	// service.
	Specialty *CodeableConcept `json:"specialty,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitCareTeam) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["provider"]; raw != nil && !ok {
		return fmt.Errorf("field provider in ExplanationOfBenefitCareTeam: required")
	}
	type Plain ExplanationOfBenefitCareTeam
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitCareTeam(plain)
	return nil
}

type ExplanationOfBenefitContainedElem interface{}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitDetail struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The adjudication results.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the line item.detail.
	// Net = unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// A claim detail line. Either a simple (a product or service) or a 'group' of
	// sub-details which are simple items.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// Third-tier of goods and services.
	SubDetail []ExplanationOfBenefitSubDetail `json:"subDetail,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitDetail1 struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// The adjudication results.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the addItem.detail.
	// Net = unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// The third-tier service adjudications for payer added services.
	SubDetail []ExplanationOfBenefitSubDetail1 `json:"subDetail,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitDiagnosis struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisCodeableConcept *CodeableConcept `json:"diagnosisCodeableConcept,omitempty"`

	// The nature of illness or problem in a coded form or as a reference to an
	// external defined Condition.
	DiagnosisReference *Reference `json:"diagnosisReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indication of whether the diagnosis was present on admission to a facility.
	OnAdmission *CodeableConcept `json:"onAdmission,omitempty"`

	// A number to uniquely identify diagnosis entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// When the condition was observed or the relative ranking.
	Type []CodeableConcept `json:"type,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitEvent struct {
	// Extensions for whenDateTime
	WhenDateTime *Element `json:"_whenDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A coded event such as when a service is expected or a card printed.
	Type CodeableConcept `json:"type"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenDateTime_2 *string `json:"whenDateTime,omitempty"`

	// A date or period in the past or future indicating when the event occurred or is
	// expectd to occur.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ExplanationOfBenefitEvent: required")
	}
	type Plain ExplanationOfBenefitEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.WhenDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.WhenDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WhenDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = ExplanationOfBenefitEvent(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitFinancial struct {
	// Extensions for allowedString
	AllowedString *Element `json:"_allowedString,omitempty"`

	// Extensions for allowedUnsignedInt
	AllowedUnsignedInt *Element `json:"_allowedUnsignedInt,omitempty"`

	// Extensions for usedUnsignedInt
	UsedUnsignedInt *Element `json:"_usedUnsignedInt,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedMoney *Money `json:"allowedMoney,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedString_2 *string `json:"allowedString,omitempty"`

	// The quantity of the benefit which is permitted under the coverage.
	AllowedUnsignedInt_2 *float64 `json:"allowedUnsignedInt,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Classification of benefit being provided.
	Type CodeableConcept `json:"type"`

	// The quantity of the benefit which have been consumed to date.
	UsedMoney *Money `json:"usedMoney,omitempty"`

	// The quantity of the benefit which have been consumed to date.
	UsedUnsignedInt_2 *float64 `json:"usedUnsignedInt,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitFinancial) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ExplanationOfBenefitFinancial: required")
	}
	type Plain ExplanationOfBenefitFinancial
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AllowedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AllowedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AllowedString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ExplanationOfBenefitFinancial(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitInsurance struct {
	// Extensions for focal
	Focal *Element `json:"_focal,omitempty"`

	// Extensions for preAuthRef
	PreAuthRef []Element `json:"_preAuthRef,omitempty"`

	// Reference to the insurance card level information contained in the Coverage
	// resource. The coverage issuing insurer will use these details to locate the
	// patient's actual coverage within the insurer's information system.
	Coverage Reference `json:"coverage"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A flag to indicate that this Coverage is to be used for adjudication of this
	// claim when set to true.
	Focal_2 *Boolean `json:"focal,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference numbers previously provided by the insurer to the provider to be
	// quoted on subsequent claims containing services or products related to the
	// prior authorization.
	PreAuthRef_2 []String `json:"preAuthRef,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitInsurance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coverage"]; raw != nil && !ok {
		return fmt.Errorf("field coverage in ExplanationOfBenefitInsurance: required")
	}
	type Plain ExplanationOfBenefitInsurance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitInsurance(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitItem struct {
	// Extensions for careTeamSequence
	CareTeamSequence []Element `json:"_careTeamSequence,omitempty"`

	// Extensions for diagnosisSequence
	DiagnosisSequence []Element `json:"_diagnosisSequence,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for informationSequence
	InformationSequence []Element `json:"_informationSequence,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for procedureSequence
	ProcedureSequence []Element `json:"_procedureSequence,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// If this item is a group then the values here are a summary of the adjudication
	// of the detail items. If this item is a simple product or service then this is
	// the result of the adjudication of this item.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// Physical location where the service is performed or applies.
	BodySite []ExplanationOfBenefitBodySite `json:"bodySite,omitempty"`

	// Care team members related to this service or product.
	CareTeamSequence_2 []PositiveInt `json:"careTeamSequence,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// Second-tier of goods and services.
	Detail []ExplanationOfBenefitDetail `json:"detail,omitempty"`

	// Diagnoses applicable for this service or product.
	DiagnosisSequence_2 []PositiveInt `json:"diagnosisSequence,omitempty"`

	// Healthcare encounters related to this claim.
	Encounter []Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Exceptions, special conditions and supporting information applicable for this
	// service or product.
	InformationSequence_2 []PositiveInt `json:"informationSequence,omitempty"`

	// Where the product or service was provided.
	LocationAddress *Address `json:"locationAddress,omitempty"`

	// Where the product or service was provided.
	LocationCodeableConcept *CodeableConcept `json:"locationCodeableConcept,omitempty"`

	// Where the product or service was provided.
	LocationReference *Reference `json:"locationReference,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the group (if a grouper) or the line item. Net =
	// unit price * quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// Procedures applicable for this service or product.
	ProcedureSequence_2 []PositiveInt `json:"procedureSequence,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Request or Referral for Goods or Service to be rendered.
	Request []Reference `json:"request,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// A number to uniquely identify item entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// The date or dates when the service or product was supplied, performed or
	// completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`

	// The party to whom the professional services and/or products have been supplied
	// or are being considered and for whom actual for facast reimbursement is sought.
	Subject *Reference `json:"subject,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitItem) UnmarshalJSON(value []byte) error {
	type Plain ExplanationOfBenefitItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = ExplanationOfBenefitItem(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitPayee struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the individual or organization to whom any payment will be made.
	Party *Reference `json:"party,omitempty"`

	// Type of Party to be reimbursed: Subscriber, billing provider, other.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitPayment struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Total amount of all adjustments to this payment included in this transaction
	// which are not related to this claim's adjudication.
	Adjustment *Money `json:"adjustment,omitempty"`

	// Reason for the payment adjustment.
	AdjustmentReason *CodeableConcept `json:"adjustmentReason,omitempty"`

	// Benefits payable less any payment adjustment.
	Amount *Money `json:"amount,omitempty"`

	// Estimated date the payment will be issued or the actual issue date of payment.
	Date_2 *Date `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Issuer's unique identifier for the payment instrument.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether this represents partial or complete payment of the benefits payable.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitProcedure struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Date and optionally time the procedure was performed.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The code or reference to a Procedure resource which identifies the clinical
	// intervention performed.
	ProcedureCodeableConcept *CodeableConcept `json:"procedureCodeableConcept,omitempty"`

	// The code or reference to a Procedure resource which identifies the clinical
	// intervention performed.
	ProcedureReference *Reference `json:"procedureReference,omitempty"`

	// A number to uniquely identify procedure entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// When the condition was observed or the relative ranking.
	Type []CodeableConcept `json:"type,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitProcessNote struct {
	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// A code to indicate the business purpose of the note.
	Class *CodeableConcept `json:"class,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A code to define the language used in the text of the note.
	Language *CodeableConcept `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A number to uniquely identify a note entry.
	Number_2 *PositiveInt `json:"number,omitempty"`

	// The explanation or description associated with the processing.
	Text_2 *Markdown `json:"text,omitempty"`

	// The business purpose of the note text.
	Type *CodeableConcept `json:"type,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitRelated struct {
	// Reference to a related Claim or ExplanationOfBenefit as a representation of a
	// claim.
	Claim *Reference `json:"claim,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An alternate organizational reference to the case or file to which this
	// particular claim pertains.
	Reference *Identifier `json:"reference,omitempty"`

	// A code to convey how the claims are related.
	Relationship *CodeableConcept `json:"relationship,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitReviewOutcome struct {
	// Extensions for preAuthRef
	PreAuthRef *Element `json:"_preAuthRef,omitempty"`

	// The result of the claim, predetermination, or preauthorization adjudication.
	Decision *CodeableConcept `json:"decision,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time frame during which this authorization is effective.
	PreAuthPeriod *Period `json:"preAuthPeriod,omitempty"`

	// Reference from the Insurer which is used in later communications which refers
	// to this adjudication.
	PreAuthRef_2 *String `json:"preAuthRef,omitempty"`

	// The reasons for the result of the claim, predetermination, or preauthorization
	// adjudication.
	Reason []CodeableConcept `json:"reason,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitSubDetail struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// The adjudication results.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// Code to identify the general type of benefits under which products and services
	// are provided.
	Category *CodeableConcept `json:"category,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the line item.detail.subDetail. Net = unit price *
	// quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// Identifies the program under which this may be recovered.
	ProgramCode []CodeableConcept `json:"programCode,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// A claim detail line. Either a simple (a product or service) or a 'group' of
	// sub-details which are simple items.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// Unique Device Identifiers associated with this line item.
	Udi []Reference `json:"udi,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitSubDetail1 struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// The adjudication results.
	Adjudication []ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A real number that represents a multiplier used in determining the overall
	// value of services delivered and/or goods received. The concept of a Factor
	// allows for a discount or surcharge multiplier to be applied to a monetary
	// amount.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Item typification or modifiers codes to convey additional context for the
	// product or service.
	Modifier []CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The total amount claimed for the addItem.detail.subDetail. Net = unit price *
	// quantity * factor.
	Net *Money `json:"net,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The amount paid by the patient, in total at the claim claim level or
	// specifically for the item and detail level, to the provider for goods and
	// services.
	PatientPaid *Money `json:"patientPaid,omitempty"`

	// When the value is a group code then this item collects a set of related item
	// details, otherwise this contains the product, service, drug or other billing
	// code for the item. This element may be the start of a range of
	// .productOrService codes used in conjunction with .productOrServiceEnd or it may
	// be a solo element where .productOrServiceEnd is not used.
	ProductOrService *CodeableConcept `json:"productOrService,omitempty"`

	// This contains the end of a range of product, service, drug or other billing
	// codes for the item. This element is not used when the .productOrService is a
	// group code. This value may only be present when a .productOfService code has
	// been provided to convey the start of the range. Typically this value may be
	// used only with preauthorizations and not with claims.
	ProductOrServiceEnd *CodeableConcept `json:"productOrServiceEnd,omitempty"`

	// The number of repetitions of a service or product.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The type of revenue or cost center providing the product and/or service.
	Revenue *CodeableConcept `json:"revenue,omitempty"`

	// The high-level results of the adjudication if adjudication has been performed.
	ReviewOutcome *ExplanationOfBenefitReviewOutcome `json:"reviewOutcome,omitempty"`

	// The total of taxes applicable for this product or service.
	Tax *Money `json:"tax,omitempty"`

	// Trace number for tracking purposes. May be defined at the jurisdiction level or
	// between trading partners.
	TraceNumber []Identifier `json:"traceNumber,omitempty"`

	// If the item is not a group then this is the fee for the product or service,
	// otherwise this is the total of the fees for the details of the group.
	UnitPrice *Money `json:"unitPrice,omitempty"`
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitSupportingInfo struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for timingDateTime
	TimingDateTime *Element `json:"_timingDateTime,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// The general class of the information supplied: information; exception;
	// accident, employment; onset, etc.
	Category CodeableConcept `json:"category"`

	// System and code pertaining to the specific information regarding special
	// conditions relating to the setting, treatment or patient  for which care is
	// sought.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides the reason in the situation where a reason code is required in
	// addition to the content.
	Reason *Coding `json:"reason,omitempty"`

	// A number to uniquely identify supporting information entries.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// The date when or period to which this information refers.
	TimingDateTime_2 *string `json:"timingDateTime,omitempty"`

	// The date when or period to which this information refers.
	TimingPeriod *Period `json:"timingPeriod,omitempty"`

	// The date when or period to which this information refers.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAge *Age `json:"valueAge,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueCount *Count `json:"valueCount,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueID_2 *string `json:"valueId,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// Additional data or information such as resources, documents, images etc.
	// including references to the data or the actual inclusion of the data.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitSupportingInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ExplanationOfBenefitSupportingInfo: required")
	}
	type Plain ExplanationOfBenefitSupportingInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TimingDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimingDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ExplanationOfBenefitSupportingInfo(plain)
	return nil
}

// This resource provides: the claim details; adjudication details from the
// processing of a Claim; and optionally account balance information, for informing
// the subscriber of the benefits provided.
type ExplanationOfBenefitTotal struct {
	// Monetary total amount associated with the category.
	Amount Money `json:"amount"`

	// A code to indicate the information type of this adjudication record.
	// Information types may include: the value submitted, maximum values or
	// percentages allowed or payable under the plan, amounts that the patient is
	// responsible for in aggregate or pertaining to this item, amounts paid by other
	// coverages, and the benefit payable for this item.
	Category CodeableConcept `json:"category"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefitTotal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in ExplanationOfBenefitTotal: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ExplanationOfBenefitTotal: required")
	}
	type Plain ExplanationOfBenefitTotal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefitTotal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplanationOfBenefit) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ExplanationOfBenefit: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ExplanationOfBenefit: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ExplanationOfBenefit: required")
	}
	type Plain ExplanationOfBenefit
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExplanationOfBenefit(plain)
	return nil
}

// A expression that is evaluated in a specified context and returns a value. The
// context of use of the expression must specify the context in which the
// expression is evaluated, and how the result of the expression is used.
type Expression struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for expression
	Expression *Element `json:"_expression,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for reference
	Reference *Element `json:"_reference,omitempty"`

	// A brief, natural language description of the condition that effectively
	// communicates the intended semantics.
	Description_2 *String `json:"description,omitempty"`

	// An expression in the specified language that returns a value.
	Expression_2 *String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The media type of the language for the expression.
	Language_2 *Code `json:"language,omitempty"`

	// A short name assigned to the expression to allow for multiple reuse of the
	// expression in the context where it is defined.
	Name_2 *Code `json:"name,omitempty"`

	// A URI that defines where the expression is found.
	Reference_2 *Uri `json:"reference,omitempty"`
}

// Specifies contact information for a specific purpose over a period of time,
// might be handled/monitored by a specific named person or organization.
type ExtendedContactDetail struct {
	// Address for the contact.
	Address *Address `json:"address,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The name of an individual to contact, some types of contact detail are usually
	// blank.
	Name []HumanName `json:"name,omitempty"`

	// This contact detail is handled/monitored by a specific organization. If the
	// name is provided in the contact, then it is referring to the named individual
	// within this organization.
	Organization *Reference `json:"organization,omitempty"`

	// Period that this contact was valid for usage.
	Period *Period `json:"period,omitempty"`

	// The purpose/type of contact.
	Purpose *CodeableConcept `json:"purpose,omitempty"`

	// The contact details application for the purpose defined.
	Telecom []ContactPoint `json:"telecom,omitempty"`
}

// Optional Extension Element - found in all resources.
type Extension struct {
	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Source of the definition for the extension code - a logical name or a URL.
	Url_2 *Uri `json:"url,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueAge *Age `json:"valueAge,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueCount *Count `json:"valueCount,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueID_2 *string `json:"valueId,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueRange *Range `json:"valueRange,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueString_2 *string `json:"valueString,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// Value of extension - must be one of a constrained set of the data types (see
	// [Extensibility](extensibility.html) for a list).
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Extension) UnmarshalJSON(value []byte) error {
	type Plain Extension
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = Extension(plain)
	return nil
}

// Significant health conditions for a person related to the patient relevant in
// the context of care for the patient.
type FamilyMemberHistory struct {
	// Extensions for ageString
	AgeString *Element `json:"_ageString,omitempty"`

	// Extensions for bornDate
	BornDate *Element `json:"_bornDate,omitempty"`

	// Extensions for bornString
	BornString *Element `json:"_bornString,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for deceasedBoolean
	DeceasedBoolean *Element `json:"_deceasedBoolean,omitempty"`

	// Extensions for deceasedDate
	DeceasedDate *Element `json:"_deceasedDate,omitempty"`

	// Extensions for deceasedString
	DeceasedString *Element `json:"_deceasedString,omitempty"`

	// Extensions for estimatedAge
	EstimatedAge *Element `json:"_estimatedAge,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The age of the relative at the time the family member history is recorded.
	AgeAge *Age `json:"ageAge,omitempty"`

	// The age of the relative at the time the family member history is recorded.
	AgeRange *Range `json:"ageRange,omitempty"`

	// The age of the relative at the time the family member history is recorded.
	AgeString_2 *string `json:"ageString,omitempty"`

	// Individual or device that is making the family member history statement.
	Asserter *Reference `json:"asserter,omitempty"`

	// The actual or approximate date of birth of the relative.
	BornDate_2 *string `json:"bornDate,omitempty"`

	// The actual or approximate date of birth of the relative.
	BornPeriod *Period `json:"bornPeriod,omitempty"`

	// The actual or approximate date of birth of the relative.
	BornString_2 *string `json:"bornString,omitempty"`

	// The significant Conditions (or condition) that the family member had. This is a
	// repeating section to allow a system to represent more than one condition per
	// resource, though there is nothing stopping multiple resources - one per
	// condition.
	Condition []FamilyMemberHistoryCondition `json:"condition,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []FamilyMemberHistoryContainedElem `json:"contained,omitempty"`

	// Describes why the family member's history is not available.
	DataAbsentReason *CodeableConcept `json:"dataAbsentReason,omitempty"`

	// The date (and possibly time) when the family member history was recorded or
	// last updated.
	Date_2 *DateTime `json:"date,omitempty"`

	// Deceased flag or the actual or approximate age of the relative at the time of
	// death for the family member history record.
	DeceasedAge *Age `json:"deceasedAge,omitempty"`

	// Deceased flag or the actual or approximate age of the relative at the time of
	// death for the family member history record.
	DeceasedBoolean_2 *bool `json:"deceasedBoolean,omitempty"`

	// Deceased flag or the actual or approximate age of the relative at the time of
	// death for the family member history record.
	DeceasedDate_2 *string `json:"deceasedDate,omitempty"`

	// Deceased flag or the actual or approximate age of the relative at the time of
	// death for the family member history record.
	DeceasedRange *Range `json:"deceasedRange,omitempty"`

	// Deceased flag or the actual or approximate age of the relative at the time of
	// death for the family member history record.
	DeceasedString_2 *string `json:"deceasedString,omitempty"`

	// If true, indicates that the age value specified is an estimated value.
	EstimatedAge_2 *Boolean `json:"estimatedAge,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this family member history by the performer or
	// other systems which remain constant as the resource is updated and propagates
	// from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This will either be a name or a description; e.g. "Aunt Susan", "my cousin with
	// the red hair".
	Name_2 *String `json:"name,omitempty"`

	// This property allows a non condition-specific note to the made about the
	// related person. Ideally, the note would be in the condition property, but this
	// is not always possible.
	Note []Annotation `json:"note,omitempty"`

	// The person who this history concerns.
	Patient Reference `json:"patient"`

	// The significant Procedures (or procedure) that the family member had. This is a
	// repeating section to allow a system to represent more than one procedure per
	// resource, though there is nothing stopping multiple resources - one per
	// procedure.
	Procedure []FamilyMemberHistoryProcedure `json:"procedure,omitempty"`

	// Describes why the family member history occurred in coded or textual form, or
	// Indicates a Condition, Observation, AllergyIntolerance, or
	// QuestionnaireResponse that justifies this family member history event.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Individual who recorded the record and takes responsibility for its content.
	Recorder *Reference `json:"recorder,omitempty"`

	// The type of relationship this person has to the patient (father, mother,
	// brother etc.).
	Relationship CodeableConcept `json:"relationship"`

	// This is a FamilyMemberHistory resource
	ResourceType interface{} `json:"resourceType"`

	// The birth sex of the family member.
	Sex *CodeableConcept `json:"sex,omitempty"`

	// A code specifying the status of the record of the family history of a specific
	// family member.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Significant health conditions for a person related to the patient relevant in
// the context of care for the patient.
type FamilyMemberHistoryCondition struct {
	// Extensions for contributedToDeath
	ContributedToDeath *Element `json:"_contributedToDeath,omitempty"`

	// Extensions for onsetString
	OnsetString *Element `json:"_onsetString,omitempty"`

	// The actual condition, allergy, or intolerance specified. Could be a coded
	// condition (like MI or Diabetes) or a less specific string like 'cancer'
	// depending on how much is known about the condition and the capabilities of the
	// creating system.
	Code CodeableConcept `json:"code"`

	// This condition contributed to the cause of death of the related person. If
	// contributedToDeath is not populated, then it is unknown.
	ContributedToDeath_2 *Boolean `json:"contributedToDeath,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An area where general notes can be placed about this specific condition.
	Note []Annotation `json:"note,omitempty"`

	// Either the age of onset, range of approximate age or descriptive string can be
	// recorded.  For conditions with multiple occurrences, this describes the first
	// known occurrence.
	OnsetAge *Age `json:"onsetAge,omitempty"`

	// Either the age of onset, range of approximate age or descriptive string can be
	// recorded.  For conditions with multiple occurrences, this describes the first
	// known occurrence.
	OnsetPeriod *Period `json:"onsetPeriod,omitempty"`

	// Either the age of onset, range of approximate age or descriptive string can be
	// recorded.  For conditions with multiple occurrences, this describes the first
	// known occurrence.
	OnsetRange *Range `json:"onsetRange,omitempty"`

	// Either the age of onset, range of approximate age or descriptive string can be
	// recorded.  For conditions with multiple occurrences, this describes the first
	// known occurrence.
	OnsetString_2 *string `json:"onsetString,omitempty"`

	// Indicates what happened following the condition.  If the condition resulted in
	// death, deceased date is captured on the relation.
	Outcome *CodeableConcept `json:"outcome,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FamilyMemberHistoryCondition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in FamilyMemberHistoryCondition: required")
	}
	type Plain FamilyMemberHistoryCondition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OnsetString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.OnsetString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OnsetString_2", `^^[\s\S]+$$`)
		}
	}
	*j = FamilyMemberHistoryCondition(plain)
	return nil
}

type FamilyMemberHistoryContainedElem interface{}

// Significant health conditions for a person related to the patient relevant in
// the context of care for the patient.
type FamilyMemberHistoryProcedure struct {
	// Extensions for contributedToDeath
	ContributedToDeath *Element `json:"_contributedToDeath,omitempty"`

	// Extensions for performedDateTime
	PerformedDateTime *Element `json:"_performedDateTime,omitempty"`

	// Extensions for performedString
	PerformedString *Element `json:"_performedString,omitempty"`

	// The actual procedure specified. Could be a coded procedure or a less specific
	// string depending on how much is known about the procedure and the capabilities
	// of the creating system.
	Code CodeableConcept `json:"code"`

	// This procedure contributed to the cause of death of the related person. If
	// contributedToDeath is not populated, then it is unknown.
	ContributedToDeath_2 *Boolean `json:"contributedToDeath,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An area where general notes can be placed about this specific procedure.
	Note []Annotation `json:"note,omitempty"`

	// Indicates what happened following the procedure. If the procedure resulted in
	// death, deceased date is captured on the relation.
	Outcome *CodeableConcept `json:"outcome,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	PerformedAge *Age `json:"performedAge,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	PerformedDateTime_2 *string `json:"performedDateTime,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	PerformedPeriod *Period `json:"performedPeriod,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	PerformedRange *Range `json:"performedRange,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	PerformedString_2 *string `json:"performedString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FamilyMemberHistoryProcedure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in FamilyMemberHistoryProcedure: required")
	}
	type Plain FamilyMemberHistoryProcedure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.PerformedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.PerformedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PerformedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.PerformedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.PerformedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PerformedString_2", `^^[\s\S]+$$`)
		}
	}
	*j = FamilyMemberHistoryProcedure(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FamilyMemberHistory) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in FamilyMemberHistory: required")
	}
	if _, ok := raw["relationship"]; raw != nil && !ok {
		return fmt.Errorf("field relationship in FamilyMemberHistory: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in FamilyMemberHistory: required")
	}
	type Plain FamilyMemberHistory
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AgeString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AgeString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AgeString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.BornDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.BornDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "BornDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.BornString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.BornString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "BornString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.DeceasedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.DeceasedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeceasedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.DeceasedString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DeceasedString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeceasedString_2", `^^[\s\S]+$$`)
		}
	}
	*j = FamilyMemberHistory(plain)
	return nil
}

// Prospective warnings of potential issues when providing care to the patient.
type Flag struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The person, organization or device that created the flag.
	Author *Reference `json:"author,omitempty"`

	// Allows a flag to be divided into different categories like clinical,
	// administrative etc. Intended to be used as a means of filtering which flags are
	// displayed to particular user or in a given context.
	Category []CodeableConcept `json:"category,omitempty"`

	// The coded value or textual component of the flag to display to the user.
	Code CodeableConcept `json:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []FlagContainedElem `json:"contained,omitempty"`

	// This alert is only relevant during the encounter.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this flag by the performer or other systems
	// which remain constant as the resource is updated and propagates from server to
	// server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period of time from the activation of the flag to inactivation of the flag.
	// If the flag is active, the end of the period should be unspecified.
	Period *Period `json:"period,omitempty"`

	// This is a Flag resource
	ResourceType interface{} `json:"resourceType"`

	// Supports basic workflow.
	Status_2 *Code `json:"status,omitempty"`

	// The patient, related person, location, group, organization, or practitioner
	// etc. this is about record this flag is associated with.
	Subject Reference `json:"subject"`

	// Additional information that may be relevant to the flag, such as why the flag
	// was created or how to guide management of the flag.
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type FlagContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Flag) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in Flag: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Flag: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in Flag: required")
	}
	type Plain Flag
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Flag(plain)
	return nil
}

// Describes the intended objective(s) for a patient, group, or organizational
// care. Examples include a patient's weight loss, restoration of an activity of
// daily living for a patient, obtaining herd immunity via immunization for a
// group, meeting a process improvement objective for an organization, etc.
type Goal struct {
	// Extensions for continuous
	Continuous *Element `json:"_continuous,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lifecycleStatus
	LifecycleStatus *Element `json:"_lifecycleStatus,omitempty"`

	// Extensions for startDate
	StartDate *Element `json:"_startDate,omitempty"`

	// Extensions for statusDate
	StatusDate *Element `json:"_statusDate,omitempty"`

	// Information about the acceptance and relative priority assigned to the goal by
	// the patient, practitioners and other stakeholders.
	Acceptance []GoalAcceptance `json:"acceptance,omitempty"`

	// Describes the progression, or lack thereof, towards the goal against the
	// target.
	AchievementStatus *CodeableConcept `json:"achievementStatus,omitempty"`

	// The identified conditions and other resources that provide the context for why
	// the goal exists.
	Addresses []Reference `json:"addresses,omitempty"`

	// Indicates a category the goal falls within.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []GoalContainedElem `json:"contained,omitempty"`

	// After meeting the goal, ongoing activity is needed to sustain the goal
	// objective.
	Continuous_2 *Boolean `json:"continuous,omitempty"`

	// Human-readable and/or coded description of a specific desired objective of
	// care, such as "control blood pressure" or "negotiate an obstacle course" or
	// "dance with child at wedding".
	Description CodeableConcept `json:"description"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this goal by the performer or other systems
	// which remain constant as the resource is updated and propagates from server to
	// server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The state of the goal throughout its lifecycle.
	LifecycleStatus_2 *Code `json:"lifecycleStatus,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Any comments related to the goal.
	Note []Annotation `json:"note,omitempty"`

	// Identifies the mutually agreed level of importance associated with
	// reaching/sustaining the goal.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// Individual who recorded the record and takes responsibility for its content.
	Recorder *Reference `json:"recorder,omitempty"`

	// This is a Goal resource
	ResourceType interface{} `json:"resourceType"`

	// Indicates whose goal this is - patient goal, practitioner goal, etc.
	Source *Reference `json:"source,omitempty"`

	// The date or event after which the goal should begin being pursued.
	StartCodeableConcept *CodeableConcept `json:"startCodeableConcept,omitempty"`

	// The date or event after which the goal should begin being pursued.
	StartDate_2 *string `json:"startDate,omitempty"`

	// Identifies when the current achievement status took effect.  I.e. When
	// achieved, when improving, etc.
	StatusDate_2 *Date `json:"statusDate,omitempty"`

	// Captures the reason for the current lifecycle status.
	StatusReason []CodeableConcept `json:"statusReason,omitempty"`

	// Identifies the patient, group or organization for whom the goal is being
	// established.
	Subject Reference `json:"subject"`

	// Indicates what should be done by when.
	Target []GoalTarget `json:"target,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Describes the intended objective(s) for a patient, group, or organizational
// care. Examples include a patient's weight loss, restoration of an activity of
// daily living for a patient, obtaining herd immunity via immunization for a
// group, meeting a process improvement objective for an organization, etc.
type GoalAcceptance struct {
	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The person ororganization whose acceptance/priority is being reflected.
	Participant Reference `json:"participant"`

	// Indicates the relative priority assigned to the goal by the stakeholder.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// Indicates whether the specified individual has accepted the goal or not.
	Status_2 *Code `json:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GoalAcceptance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["participant"]; raw != nil && !ok {
		return fmt.Errorf("field participant in GoalAcceptance: required")
	}
	type Plain GoalAcceptance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GoalAcceptance(plain)
	return nil
}

type GoalContainedElem interface{}

// Describes the intended objective(s) for a patient, group, or organizational
// care. Examples include a patient's weight loss, restoration of an activity of
// daily living for a patient, obtaining herd immunity via immunization for a
// group, meeting a process improvement objective for an organization, etc.
type GoalTarget struct {
	// Extensions for detailBoolean
	DetailBoolean *Element `json:"_detailBoolean,omitempty"`

	// Extensions for detailInteger
	DetailInteger *Element `json:"_detailInteger,omitempty"`

	// Extensions for detailString
	DetailString *Element `json:"_detailString,omitempty"`

	// Extensions for dueDate
	DueDate *Element `json:"_dueDate,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailBoolean_2 *bool `json:"detailBoolean,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailCodeableConcept *CodeableConcept `json:"detailCodeableConcept,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailInteger_2 *float64 `json:"detailInteger,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailQuantity *Quantity `json:"detailQuantity,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailRange *Range `json:"detailRange,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailRatio *Ratio `json:"detailRatio,omitempty"`

	// The target value of the focus to be achieved to signify the fulfillment of the
	// goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any focus value at or below the high value. Similarly, if the high
	// value is missing, it indicates that the goal is achieved at any focus value at
	// or above the low value. A CodeableConcept target value could be Positive,
	// Negative, Abnormal, Normal, Present, Absent, Yes, No.
	DetailString_2 *string `json:"detailString,omitempty"`

	// Indicates either the date or the duration after start by which the goal should
	// be met.
	DueDate_2 *string `json:"dueDate,omitempty"`

	// Indicates either the date or the duration after start by which the goal should
	// be met.
	DueDuration *Duration `json:"dueDuration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The parameter whose value is being tracked, e.g. body weight, blood pressure,
	// or hemoglobin A1c level.
	Measure *CodeableConcept `json:"measure,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GoalTarget) UnmarshalJSON(value []byte) error {
	type Plain GoalTarget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DetailString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DetailString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DetailString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.DueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.DueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = GoalTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Goal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in Goal: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Goal: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in Goal: required")
	}
	type Plain Goal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.StartDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.StartDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "StartDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = Goal(plain)
	return nil
}

// Represents a defined collection of entities that may be discussed or acted upon
// collectively but which are not typically expected to act collectively.  These
// collections are also not typically formally or legally recognized.
//
// NOTE: Group may be used to define families or households, which in some
// circumstances may act collectively or have a degree of legal or formal
// recognition.  This should be considered an exception.  When Group is used for
// types of entities other than Patient or RelatedPerson, the expectation remains
// that the Group will not act collectively or have formal recognition - use
// Organization if these behaviors are needed.
//
// For example, it is possible for a 'family' Group to be a performer of an
// Observation or owner of a Task.  However, this is not permitted for a Group made
// up of Practitioners, PractitionerRoles or Organizations.  Organization or
// CareTeam would need to be used instead.  A Group of Practitioners could,
// however, be a subject of an Observation.
type Group struct {
	// Extensions for combinationMethod
	CombinationMethod *Element `json:"_combinationMethod,omitempty"`

	// Extensions for combinationThreshold
	CombinationThreshold *Element `json:"_combinationThreshold,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for membership
	Membership *Element `json:"_membership,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for quantity
	Quantity *Element `json:"_quantity,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Identifies traits whose presence r absence is shared by members of the group.
	Characteristic []GroupCharacteristic `json:"characteristic,omitempty"`

	// A code that describes the use of the group. The use of the group usually
	// dictates what kind of entities can be members of the group.
	Code *CodeableConcept `json:"code,omitempty"`

	// Used to specify how two or more characteristics are combined.
	CombinationMethod_2 *Code `json:"combinationMethod,omitempty"`

	// Provides the value of "n" when "at-least" or "at-most" codes are used for
	// combinationMethod.
	CombinationThreshold_2 *PositiveInt `json:"combinationThreshold,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []GroupContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the Group and/or its contents. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the Group.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date (and optionally time) when the Group was last significantly changed.
	// The date must change when the business version changes and it must change if
	// the status code changes. In addition, it should change when the substantive
	// content of the Group changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// Explanation of what the group represents and how it is intended to be used.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this Group is authored for testing purposes
	// (or education/evaluation/marketing) and no version of this resource will ever
	// be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this participant by one of the applications
	// involved.  These identifiers remain constant as the resource is updated and
	// propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Entity responsible for defining and maintaining Group characteristics and/or
	// registered members.
	ManagingEntity *Reference `json:"managingEntity,omitempty"`

	// Identifies the resource instances that are members of the group.
	Member []GroupMember `json:"member,omitempty"`

	// Basis for membership in the Group:
	//
	// * 'definitional': The Group.characteristics specified are both necessary and
	// sufficient to determine membership. All entities that meet the criteria are
	// considered to be members of the group, whether referenced by the group or not.
	// If members are present, they are individuals that happen to be known as meeting
	// the Group.characteristics. The list cannot be presumed to be complete.
	// * 'conceptual': The Group.characteristics specified are both necessary and
	// sufficient to determine membership. The 'conceptual' Group is a 'definitional'
	// Group in which the Group.type is not bound to FHIR types.
	// * 'enumerated': The Group.characteristics are necessary but not sufficient to
	// determine membership. Membership is determined by being listed as one of the
	// Group.member.
	Membership_2 *Code `json:"membership,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A label assigned to the group for human identification and communication.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the Group.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this Group is needed and why it has been designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// A count of the number of resource instances that are part of the group.
	Quantity_2 *UnsignedInt `json:"quantity,omitempty"`

	// This is a Group resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of this Group.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the Group.
	Title_2 *String `json:"title,omitempty"`

	// Identifies the broad classification of the kind of resources the group
	// includes.
	Type_2 *Code `json:"type,omitempty"`

	// An absolute URI that is used to identify this Group when it is referenced in a
	// specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this Group is (or will be) published. This
	// URL can be the target of a canonical reference. It SHALL remain the same when
	// the Group is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate Groups.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the Group when it is
	// referenced in a specification, model, design or instance. This is an arbitrary
	// value managed by the Group author and is not expected to be globally unique.
	// For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
	// not available. There is also no expectation that versions can be placed in a
	// lexicographical sequence without additional knowledge.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// Represents a defined collection of entities that may be discussed or acted upon
// collectively but which are not typically expected to act collectively.  These
// collections are also not typically formally or legally recognized.
//
// NOTE: Group may be used to define families or households, which in some
// circumstances may act collectively or have a degree of legal or formal
// recognition.  This should be considered an exception.  When Group is used for
// types of entities other than Patient or RelatedPerson, the expectation remains
// that the Group will not act collectively or have formal recognition - use
// Organization if these behaviors are needed.
//
// For example, it is possible for a 'family' Group to be a performer of an
// Observation or owner of a Task.  However, this is not permitted for a Group made
// up of Practitioners, PractitionerRoles or Organizations.  Organization or
// CareTeam would need to be used instead.  A Group of Practitioners could,
// however, be a subject of an Observation.
type GroupCharacteristic struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for exclude
	Exclude *Element `json:"_exclude,omitempty"`

	// Extensions for instancesUnsignedInt
	InstancesUnsignedInt *Element `json:"_instancesUnsignedInt,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// A code that identifies the kind of trait being asserted.
	Code CodeableConcept `json:"code"`

	// A short, natural language description of the characteristic that could be used
	// to communicate the criteria to an end-user.
	Description_2 *Markdown `json:"description,omitempty"`

	// The entity who is expected to evaluate the characteristic value for candidate
	// group members.
	Determiner *Reference `json:"determiner,omitempty"`

	// Length of time in which the characteristic is met.
	DurationDuration *Duration `json:"durationDuration,omitempty"`

	// Length of time in which the characteristic is met.
	DurationRange *Range `json:"durationRange,omitempty"`

	// If true, indicates the characteristic is one that is NOT held by members of the
	// group.
	Exclude_2 *Boolean `json:"exclude,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A CQL, FHIRPath, or other expression that is used to generate the value for
	// this characteristic.
	Formula *Expression `json:"formula,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Number of occurrences meeting the characteristic.
	InstancesRange *Range `json:"instancesRange,omitempty"`

	// Number of occurrences meeting the characteristic.
	InstancesUnsignedInt_2 *float64 `json:"instancesUnsignedInt,omitempty"`

	// Method for how the characteristic value was determined.
	Method []CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Defines the reference point for comparison when other than 0.
	Offset *CodeableConcept `json:"offset,omitempty"`

	// The period over which the characteristic is tested; e.g. the patient had an
	// operation during the month of June.
	Period *Period `json:"period,omitempty"`

	// Timing in which the characteristic is determined.
	Timing []RelativeTime `json:"timing,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The value of the trait that holds (or does not hold - see 'exclude') for
	// members of the group.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupCharacteristic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in GroupCharacteristic: required")
	}
	type Plain GroupCharacteristic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = GroupCharacteristic(plain)
	return nil
}

type GroupContainedElem interface{}

// Represents a defined collection of entities that may be discussed or acted upon
// collectively but which are not typically expected to act collectively.  These
// collections are also not typically formally or legally recognized.
//
// NOTE: Group may be used to define families or households, which in some
// circumstances may act collectively or have a degree of legal or formal
// recognition.  This should be considered an exception.  When Group is used for
// types of entities other than Patient or RelatedPerson, the expectation remains
// that the Group will not act collectively or have formal recognition - use
// Organization if these behaviors are needed.
//
// For example, it is possible for a 'family' Group to be a performer of an
// Observation or owner of a Task.  However, this is not permitted for a Group made
// up of Practitioners, PractitionerRoles or Organizations.  Organization or
// CareTeam would need to be used instead.  A Group of Practitioners could,
// however, be a subject of an Observation.
type GroupMember struct {
	// Extensions for inactive
	Inactive *Element `json:"_inactive,omitempty"`

	// A reference to the entity that is a member of the group. Must be consistent
	// with Group.type. If the entity is another group, then the type must be the
	// same.
	Entity Reference `json:"entity"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A flag to indicate that the member is no longer in the group, but previously
	// may have been a member.
	Inactive_2 *Boolean `json:"inactive,omitempty"`

	// A code that describes how a user is involved in the group. Some groups (e.g.
	// exposure-group) typically don't have variance between members, or it is not
	// tracked, while for other groups (e.g. family, household) this may be
	// meaningful.
	Involvement []CodeableConcept `json:"involvement,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period that the member was in the group, if known.
	Period *Period `json:"period,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupMember) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["entity"]; raw != nil && !ok {
		return fmt.Errorf("field entity in GroupMember: required")
	}
	type Plain GroupMember
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GroupMember(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Group: required")
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Group(plain)
	return nil
}

// A guidance response is the formal response to a guidance request, including any
// output parameters returned by the evaluation, as well as the description of any
// proposed actions to be taken.
type GuidanceResponse struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for moduleCanonical
	ModuleCanonical *Element `json:"_moduleCanonical,omitempty"`

	// Extensions for moduleUri
	ModuleUri *Element `json:"_moduleUri,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []GuidanceResponseContainedElem `json:"contained,omitempty"`

	// If the evaluation could not be completed due to lack of information, or
	// additional information would potentially result in a more accurate response,
	// this element will a description of the data required in order to proceed with
	// the evaluation. A subsequent request to the service should include this data.
	DataRequirement []DataRequirement `json:"dataRequirement,omitempty"`

	// The Encounter during which this guidance response was created or to which the
	// creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// Messages resulting from the evaluation of the artifact or artifacts. As part of
	// evaluating the request, the engine may produce informational or warning
	// messages. These messages will be provided by this element.
	EvaluationMessage *Reference `json:"evaluationMessage,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this guidance response by the performer and/or
	// other systems.  These identifiers remain constant as the resource is updated
	// and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The principal physical location where the guidance response was performed.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An identifier, CodeableConcept or canonical reference to the guidance that was
	// requested.
	ModuleCanonical_2 *string `json:"moduleCanonical,omitempty"`

	// An identifier, CodeableConcept or canonical reference to the guidance that was
	// requested.
	ModuleCodeableConcept *CodeableConcept `json:"moduleCodeableConcept,omitempty"`

	// An identifier, CodeableConcept or canonical reference to the guidance that was
	// requested.
	ModuleUri_2 *string `json:"moduleUri,omitempty"`

	// Provides a mechanism to communicate additional information about the response.
	Note []Annotation `json:"note,omitempty"`

	// Indicates when the guidance response was processed.
	OccurrenceDateTime_2 *DateTime `json:"occurrenceDateTime,omitempty"`

	// The output parameters of the evaluation, if any. Many modules will result in
	// the return of specific resources such as procedure or communication requests
	// that are returned as part of the operation result. However, modules may define
	// specific outputs that would be returned as the result of the evaluation, and
	// these would be returned in this element.
	OutputParameters *Reference `json:"outputParameters,omitempty"`

	// Provides a reference to the device that performed the guidance.
	Performer *Reference `json:"performer,omitempty"`

	// Describes the reason for the guidance response in coded or textual form, or
	// Indicates the reason the request was initiated. This is typically provided as a
	// parameter to the evaluation and echoed by the service, although for some use
	// cases, such as subscription- or event-based scenarios, it may provide an
	// indication of the cause for the response.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The identifier of the request associated with this response. If an identifier
	// was given as part of the request, it will be reproduced here to enable the
	// requester to more easily identify the response in a multi-request scenario.
	RequestIdentifier *Identifier `json:"requestIdentifier,omitempty"`

	// This is a GuidanceResponse resource
	ResourceType interface{} `json:"resourceType"`

	// The actions, if any, produced by the evaluation of the artifact.
	Result []Reference `json:"result,omitempty"`

	// The status of the response. If the evaluation is completed successfully, the
	// status will indicate success. However, in order to complete the evaluation, the
	// engine may require more information. In this case, the status will be
	// data-required, and the response will contain a description of the additional
	// required information. If the evaluation completed successfully, but the engine
	// determines that a potentially more accurate response could be provided if more
	// data was available, the status will be data-requested, and the response will
	// contain a description of the additional requested information.
	Status_2 *Code `json:"status,omitempty"`

	// The individual or set of individuals the action is being or was performed on.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type GuidanceResponseContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GuidanceResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in GuidanceResponse: required")
	}
	type Plain GuidanceResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ModuleCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ModuleCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ModuleCanonical_2", `^\S*$`)
		}
	}
	if plain.ModuleUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ModuleUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ModuleUri_2", `^\S*$`)
		}
	}
	*j = GuidanceResponse(plain)
	return nil
}

// The details of a healthcare service available at a location.
type HealthcareService struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for appointmentRequired
	AppointmentRequired *Element `json:"_appointmentRequired,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for extraDetails
	ExtraDetails *Element `json:"_extraDetails,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for referralRequired
	ReferralRequired *Element `json:"_referralRequired,omitempty"`

	// This flag is used to mark the record to not be used. This is not used when a
	// center is closed for maintenance, or for holidays, the notAvailable period is
	// to be used for this.
	Active_2 *Boolean `json:"active,omitempty"`

	// Indicates whether or not a prospective consumer will require an appointment for
	// a particular service at a site to be provided by the Organization.
	AppointmentRequired_2 *Boolean `json:"appointmentRequired,omitempty"`

	// A collection of times that the healthcare service is available.
	Availability *Availability `json:"availability,omitempty"`

	// Identifies the broad category of service being performed or delivered.
	Category []CodeableConcept `json:"category,omitempty"`

	// Collection of characteristics (attributes).
	Characteristic []CodeableConcept `json:"characteristic,omitempty"`

	// Any additional description of the service and/or any specific issues not
	// covered by the other attributes, which can be displayed as further detail under
	// the serviceName.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// Some services are specifically made available in multiple languages, this
	// property permits a directory to declare the languages this is offered in.
	// Typically this is only provided where a service operates in communities with
	// mixed languages used.
	Communication []CodeableConcept `json:"communication,omitempty"`

	// The contact details of communication devices available relevant to the specific
	// HealthcareService. This can include addresses, phone numbers, fax numbers,
	// mobile numbers, email addresses and web sites.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []HealthcareServiceContainedElem `json:"contained,omitempty"`

	// The location(s) that this service is available to (not where the service is
	// provided).
	CoverageArea []Reference `json:"coverageArea,omitempty"`

	// Does this service have specific eligibility requirements that need to be met in
	// order to use the service?
	Eligibility []HealthcareServiceEligibility `json:"eligibility,omitempty"`

	// Technical endpoints providing access to services operated for the specific
	// healthcare services defined at this resource.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Extra details about the service that can't be placed in the other fields.
	ExtraDetails_2 *Markdown `json:"extraDetails,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// External identifiers for this item.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The location(s) where this healthcare service may be provided.
	Location []Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Further description of the service as it would be presented to a consumer while
	// searching.
	Name_2 *String `json:"name,omitempty"`

	// When the HealthcareService is representing a specific, schedulable service, the
	// availableIn property can refer to a generic service.
	OfferedIn []Reference `json:"offeredIn,omitempty"`

	// If there is a photo/symbol associated with this HealthcareService, it may be
	// included here to facilitate quick identification of the service in a list.
	Photo *Attachment `json:"photo,omitempty"`

	// Programs that this service is applicable to.
	Program []CodeableConcept `json:"program,omitempty"`

	// The organization that provides this healthcare service.
	ProvidedBy *Reference `json:"providedBy,omitempty"`

	// Ways that the service accepts referrals, if this is not provided then it is
	// implied that no referral is required.
	ReferralMethod []CodeableConcept `json:"referralMethod,omitempty"`

	// Indicates whether or not a prospective consumer will require a referral for a
	// particular service at a site to be provided by the Organization.
	ReferralRequired_2 *Boolean `json:"referralRequired,omitempty"`

	// This is a HealthcareService resource
	ResourceType interface{} `json:"resourceType"`

	// The code(s) that detail the conditions under which the healthcare service is
	// available/offered.
	ServiceProvisionCode []CodeableConcept `json:"serviceProvisionCode,omitempty"`

	// Collection of specialties handled by the Healthcare service. This is more of a
	// medical term.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The specific type of service that may be delivered or performed.
	Type []CodeableConcept `json:"type,omitempty"`
}

type HealthcareServiceContainedElem interface{}

// The details of a healthcare service available at a location.
type HealthcareServiceEligibility struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Coded value for the eligibility.
	Code *CodeableConcept `json:"code,omitempty"`

	// Describes the eligibility conditions for the service.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period that this eligibility rule is a requirement for this service.
	Period *Period `json:"period,omitempty"`

	// Sometimes an eligibility code requires additional data to calculate the
	// eligibility rules.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Sometimes an eligibility code requires additional data to calculate the
	// eligibility rules.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Sometimes an eligibility code requires additional data to calculate the
	// eligibility rules.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Sometimes an eligibility code requires additional data to calculate the
	// eligibility rules.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Sometimes an eligibility code requires additional data to calculate the
	// eligibility rules.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HealthcareService) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in HealthcareService: required")
	}
	type Plain HealthcareService
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = HealthcareService(plain)
	return nil
}

// A name, normally of a human, that can be used for other living entities (e.g.
// animals but not organizations) that have been assigned names by a human and may
// need the use of name parts or the need for usage information.
type HumanName struct {
	// Extensions for family
	Family *Element `json:"_family,omitempty"`

	// Extensions for given
	Given []Element `json:"_given,omitempty"`

	// Extensions for prefix
	Prefix []Element `json:"_prefix,omitempty"`

	// Extensions for suffix
	Suffix []Element `json:"_suffix,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The part of a name that links to the genealogy. In some cultures (e.g. Eritrea)
	// the family name of a son is the first name of his father.
	Family_2 *String `json:"family,omitempty"`

	// Given name.
	Given_2 []String `json:"given,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Indicates the period of time when this name was valid for the named person.
	Period *Period `json:"period,omitempty"`

	// Part of the name that is acquired as a title due to academic, legal, employment
	// or nobility status, etc. and that appears at the start of the name.
	Prefix_2 []String `json:"prefix,omitempty"`

	// Part of the name that is acquired as a title due to academic, legal, employment
	// or nobility status, etc. and that appears at the end of the name.
	Suffix_2 []String `json:"suffix,omitempty"`

	// Specifies the entire name as it should be displayed e.g. on an application UI.
	// This may be provided instead of or as well as the specific parts.
	Text_2 *String `json:"text,omitempty"`

	// Identifies the purpose for this name.
	Use_2 *HumanNameUse_2 `json:"use,omitempty"`
}

type HumanNameUse_2 string

const HumanNameUse_2_Anonymous HumanNameUse_2 = "anonymous"
const HumanNameUse_2_Maiden HumanNameUse_2 = "maiden"
const HumanNameUse_2_Nickname HumanNameUse_2 = "nickname"
const HumanNameUse_2_Official HumanNameUse_2 = "official"
const HumanNameUse_2_Old HumanNameUse_2 = "old"
const HumanNameUse_2_Temp HumanNameUse_2 = "temp"
const HumanNameUse_2_Usual HumanNameUse_2 = "usual"

var enumValues_HumanNameUse_2 = []interface{}{
	"usual",
	"official",
	"temp",
	"nickname",
	"anonymous",
	"old",
	"maiden",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HumanNameUse_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HumanNameUse_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HumanNameUse_2, v)
	}
	*j = HumanNameUse_2(v)
	return nil
}

// Any combination of letters, numerals, "-" and ".", with a length limit of 64
// characters.  (This might be an integer, an unprefixed OID, UUID or any other
// identifier pattern that meets these constraints.)  Ids are case-insensitive.
type ID string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ID) UnmarshalJSON(value []byte) error {
	type Plain ID
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^[A-Za-z0-9\-\.]{1,64}$`)
	}
	*j = ID(plain)
	return nil
}

// An identifier - identifies some entity uniquely and unambiguously. Typically
// this is used for business identifiers.
type Identifier struct {
	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Organization that issued/manages the identifier.
	Assigner *Reference `json:"assigner,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Time period during which identifier is/was valid for use.
	Period *Period `json:"period,omitempty"`

	// Establishes the namespace for the value - that is, an absolute URL that
	// describes a set values that are unique.
	System_2 *Uri `json:"system,omitempty"`

	// A coded type for the identifier that can be used to determine which identifier
	// to use for a specific purpose.
	Type *CodeableConcept `json:"type,omitempty"`

	// The purpose of this identifier.
	Use_2 *IdentifierUse_2 `json:"use,omitempty"`

	// The portion of the identifier typically relevant to the user and which is
	// unique within the context of the system.
	Value_2 *String `json:"value,omitempty"`
}

type IdentifierUse_2 string

const IdentifierUse_2_Official IdentifierUse_2 = "official"
const IdentifierUse_2_Old IdentifierUse_2 = "old"
const IdentifierUse_2_Secondary IdentifierUse_2 = "secondary"
const IdentifierUse_2_Temp IdentifierUse_2 = "temp"
const IdentifierUse_2_Usual IdentifierUse_2 = "usual"

var enumValues_IdentifierUse_2 = []interface{}{
	"usual",
	"official",
	"temp",
	"secondary",
	"old",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentifierUse_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdentifierUse_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdentifierUse_2, v)
	}
	*j = IdentifierUse_2(v)
	return nil
}

// A selection of DICOM SOP instances within a single Study and Series. This might
// include additional specifics such as a set of frames or an image region,
// allowing linkage to an Observation Resource.
type ImagingSelection struct {
	// Extensions for frameOfReferenceUid
	FrameOfReferenceUid *Element `json:"_frameOfReferenceUid,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for issued
	Issued *Element `json:"_issued,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for seriesNumber
	SeriesNumber *Element `json:"_seriesNumber,omitempty"`

	// Extensions for seriesUid
	SeriesUid *Element `json:"_seriesUid,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for studyUid
	StudyUid *Element `json:"_studyUid,omitempty"`

	// A plan or order that is fulfilled in whole or in part by this imaging
	// selection.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The anatomic structures selected. See [DICOM Part 16 Annex
	// L](http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html)
	// for DICOM to SNOMED-CT mappings. The bodySite MAY include the laterality of
	// body part imaged.
	BodySite []CodeableReference `json:"bodySite,omitempty"`

	// Classifies the general purpose of the imaging selection.
	Category []CodeableConcept `json:"category,omitempty"`

	// Identifies the type of imaging selection.
	Code CodeableConcept `json:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ImagingSelectionContainedElem `json:"contained,omitempty"`

	// The imaging study from which the imaging selection is made.
	DerivedFrom *Reference `json:"derivedFrom,omitempty"`

	// The network services providing access to the selected images, frames, etc. See
	// implementation notes for information about using DICOM endpoints.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual focus of an imaging selection when it is another imaging selection
	// resource and not the patient of record.
	Focus []Reference `json:"focus,omitempty"`

	// Identifier used to group composite instances that have the same coordinate
	// system that conveys spatial and/or temporal information.
	FrameOfReferenceUid_2 *ID `json:"frameOfReferenceUid,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this imaging selection by the performer and/or
	// other systems.  These identifiers remain constant as the resource is updated
	// and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Specifies a 3D image region, defined by a region type and a set of 3D
	// coordinates.
	ImageRegion3D []ImagingSelectionImageRegion3D `json:"imageRegion3D,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Each imaging selection includes one or more selected DICOM SOP instances.
	Instance []ImagingSelectionInstance `json:"instance,omitempty"`

	// Date and time the imaging selection was created.
	Issued_2 *Instant `json:"issued,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The distinct modality for this selected series. This MAY be either an
	// acquisition modality (e.g. CT, MR) or a non-acquisition modality (e.g.
	// segmentation, presentation state).
	Modality *CodeableConcept `json:"modality,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates who or what performed the imaging selection and how they were
	// involved.
	Performer []ImagingSelectionPerformer `json:"performer,omitempty"`

	// This is a ImagingSelection resource
	ResourceType interface{} `json:"resourceType"`

	// The numeric identifier of the selected series in the study.
	SeriesNumber_2 *UnsignedInt `json:"seriesNumber,omitempty"`

	// The DICOM Series Instance UID of the selected series.
	SeriesUid_2 *ID `json:"seriesUid,omitempty"`

	// The current state of the imaging selection. This is distinct from the status of
	// any imaging study, service request, or task associated with the imaging
	// selection.
	Status_2 *Code `json:"status,omitempty"`

	// The Study Instance UID for the DICOM Study from which the images were selected.
	StudyUid_2 *ID `json:"studyUid,omitempty"`

	// The subject, typically a patient, of the imaging selection.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type ImagingSelectionContainedElem interface{}

// A selection of DICOM SOP instances within a single Study and Series. This might
// include additional specifics such as a set of frames or an image region,
// allowing linkage to an Observation Resource.
type ImagingSelectionImageRegion2D struct {
	// Extensions for coordinate
	Coordinate []Element `json:"_coordinate,omitempty"`

	// Extensions for regionType
	RegionType *Element `json:"_regionType,omitempty"`

	// The coordinates defining the image region. Encoded as a set of (column, row)
	// pairs that denote positions in the selected image / frames specified with
	// sub-pixel resolution.
	// The origin at the TLHC of the TLHC pixel is 0.0\0.0, the BRHC of the TLHC pixel
	// is 1.0\1.0, and the BRHC of the BRHC pixel is the number of columns\rows in the
	// image / frames. The values SHALL be within the range 0\0 to the number of
	// columns\rows in the image / frames.
	Coordinate_2 []Decimal `json:"coordinate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The type of image region.
	RegionType_2 *Code `json:"regionType,omitempty"`
}

// A selection of DICOM SOP instances within a single Study and Series. This might
// include additional specifics such as a set of frames or an image region,
// allowing linkage to an Observation Resource.
type ImagingSelectionImageRegion3D struct {
	// Extensions for coordinate
	Coordinate []Element `json:"_coordinate,omitempty"`

	// Extensions for regionType
	RegionType *Element `json:"_regionType,omitempty"`

	// The coordinates defining the image region. Encoded as an ordered set of (x,y,z)
	// triplets (in mm and MAY be negative) that define a region of interest in the
	// patient-relative Reference Coordinate System defined by
	// ImagingSelection.frameOfReferenceUid element.
	Coordinate_2 []Decimal `json:"coordinate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Specifies the type of image region.
	RegionType_2 *Code `json:"regionType,omitempty"`
}

// A selection of DICOM SOP instances within a single Study and Series. This might
// include additional specifics such as a set of frames or an image region,
// allowing linkage to an Observation Resource.
type ImagingSelectionInstance struct {
	// Extensions for frameNumber
	FrameNumber []Element `json:"_frameNumber,omitempty"`

	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for referencedContentItemIdentifier
	ReferencedContentItemIdentifier []Element `json:"_referencedContentItemIdentifier,omitempty"`

	// Extensions for regionOfInterest
	RegionOfInterest []Element `json:"_regionOfInterest,omitempty"`

	// Extensions for segmentNumber
	SegmentNumber []Element `json:"_segmentNumber,omitempty"`

	// Extensions for sopClass
	SopClass *Element `json:"_sopClass,omitempty"`

	// Extensions for uid
	Uid *Element `json:"_uid,omitempty"`

	// Extensions for waveFormChannel
	WaveFormChannel []Element `json:"_waveFormChannel,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A list of frame numbers selected from a multiframe SOP Instance (See [DICOM PS
	// 3.3 Table
	// 10.3](https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_10.3.html#table_10-3)).
	FrameNumber_2 []PositiveInt `json:"frameNumber,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Specifies an image region, defined by a region type and a set of 2D coordinates
	// in pixel space.
	ImageRegion2D []ImagingSelectionImageRegion2D `json:"imageRegion2D,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// TThe number of the instance assigned by the creator of the series. MAY or MAY
	// NOT correspond to intended display order.
	Number_2 *UnsignedInt `json:"number,omitempty"`

	// A list of Referenced Content Item Identifier values selected from a DICOM SR or
	// other structured document SOP Instance (See [DICOM PS 3.3
	// C.17.3.2.5](https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.17.3.2.5.html)).
	ReferencedContentItemIdentifier_2 []PositiveInt `json:"referencedContentItemIdentifier,omitempty"`

	// A list of Region of Interest (ROI) numbers selected from a radiotherapy
	// structure set SOP Instance (See [DICOM PS 3.3
	// C.8.8.5](https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.8.5.html)).
	RegionOfInterest_2 []PositiveInt `json:"regionOfInterest,omitempty"`

	// A list of segment numbers selected from a segmentation SOP Instance (See [DICOM
	// PS 3.3 Table
	// C.8.20-4](https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.4.html#table_C.8.20-4)).
	SegmentNumber_2 []PositiveInt `json:"segmentNumber,omitempty"`

	// DICOM instance type.
	SopClass_2 *Oid `json:"sopClass,omitempty"`

	// The SOP Instance UID for the selected DICOM this image or other DICOM content.
	Uid_2 *ID `json:"uid,omitempty"`

	// A list of channels in a Waveform selected from an instance of a waveform SOP
	// Class.
	// Each channel is specified as a pair of values where the first value is the
	// Multiplex Group Number, and the second value is the Channel Number within the
	// multiplex group (See [DICOM PS 3.3
	// C.18.5.1.1](https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.18.5.html#sect_C.18.5.1.1)).
	WaveFormChannel_2 []PositiveInt `json:"waveFormChannel,omitempty"`
}

// A selection of DICOM SOP instances within a single Study and Series. This might
// include additional specifics such as a set of frames or an image region,
// allowing linkage to an Observation Resource.
type ImagingSelectionPerformer struct {
	// Indicates who or what performed the imaging selection.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of involvement of the performer in the imaging
	// selection.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImagingSelectionPerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in ImagingSelectionPerformer: required")
	}
	type Plain ImagingSelectionPerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImagingSelectionPerformer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImagingSelection) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ImagingSelection: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ImagingSelection: required")
	}
	type Plain ImagingSelection
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImagingSelection(plain)
	return nil
}

// Representation of the content produced in a DICOM imaging study. A study
// comprises a set of series, each of which includes a set of Service-Object Pair
// Instances (SOP Instances - images or other data) acquired or produced in a
// common context.  A series is of only one modality (e.g. X-ray, CT, MR,
// ultrasound), but a study can have multiple series of different modality values.
type ImagingStudy struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for numberOfInstances
	NumberOfInstances *Element `json:"_numberOfInstances,omitempty"`

	// Extensions for numberOfSeries
	NumberOfSeries *Element `json:"_numberOfSeries,omitempty"`

	// Extensions for started
	Started *Element `json:"_started,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A plan or order that is fulfilled in whole or in part by this imaging study.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ImagingStudyContainedElem `json:"contained,omitempty"`

	// Description or classification of the imaging study.
	Description_2 *String `json:"description,omitempty"`

	// The healthcare event (e.g. a patient and healthcare provider interaction)
	// during which the imaging data represented by this imaging study was acquired.
	Encounter *Reference `json:"encounter,omitempty"`

	// The network service providing access (e.g., query, view, or retrieval) for the
	// study. See implementation notes for information about using DICOM endpoints. A
	// study-level endpoint applies to each series in the study, unless overridden by
	// a series-level endpoint with the same Endpoint.connectionType.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this imaging study by the performer and/or
	// other systems.  These identifiers remain constant as the resource is updated
	// and propagates from server to server. Typically this will include the DICOM
	// Study Instance UID.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The principal physical location where the imaging study was performed.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// All the distinct values of series.modality. This MAY be either an acquisition
	// or a non-acquisition modality.
	Modality []CodeableConcept `json:"modality,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the imaging study by the performer, subject or other
	// participants.
	Note []Annotation `json:"note,omitempty"`

	// Number of known SOP Instances in Study. This value might be present even if the
	// ImagingStudy.series.instance elements are empty or only partially populated.
	NumberOfInstances_2 *UnsignedInt `json:"numberOfInstances,omitempty"`

	// Number of known Series in the Study. This value might be present even if the
	// ImagingStudy.series element is empty or only partially populated.
	NumberOfSeries_2 *UnsignedInt `json:"numberOfSeries,omitempty"`

	// The performed procedure(s) during which the data associated with this imaging
	// study was created.
	Procedure []Reference `json:"procedure,omitempty"`

	// Describes why the imaging study occurred in coded or textual form or indicates
	// another resource whose existence justifies this imaging study.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The referring physician.
	Referrer *Reference `json:"referrer,omitempty"`

	// This is a ImagingStudy resource
	ResourceType interface{} `json:"resourceType"`

	// The set of Series belonging to the study. Each Series contains a set of SOP
	// Instances, which could be images, waveforms, or other content.
	Series []ImagingStudySeries `json:"series,omitempty"`

	// Date and time the study started.
	Started_2 *DateTime `json:"started,omitempty"`

	// The current state of the imaging study. This is distinct from the status of any
	// service request or task associated with the imaging study.
	Status_2 *Code `json:"status,omitempty"`

	// The subject, typically a patient, of the imaging study.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type ImagingStudyContainedElem interface{}

// Representation of the content produced in a DICOM imaging study. A study
// comprises a set of series, each of which includes a set of Service-Object Pair
// Instances (SOP Instances - images or other data) acquired or produced in a
// common context.  A series is of only one modality (e.g. X-ray, CT, MR,
// ultrasound), but a study can have multiple series of different modality values.
type ImagingStudyInstance struct {
	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for sopClass
	SopClass *Element `json:"_sopClass,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for uid
	Uid *Element `json:"_uid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The number of the instance assigned by the creator of the series. MAY or MAY
	// NOT correspond to intended display order.
	Number_2 *UnsignedInt `json:"number,omitempty"`

	// DICOM instance  type.
	SopClass_2 *Oid `json:"sopClass,omitempty"`

	// The title of the instance.
	Title_2 *String `json:"title,omitempty"`

	// The DICOM SOP Instance UID for this image or other DICOM content.
	Uid_2 *ID `json:"uid,omitempty"`
}

// Representation of the content produced in a DICOM imaging study. A study
// comprises a set of series, each of which includes a set of Service-Object Pair
// Instances (SOP Instances - images or other data) acquired or produced in a
// common context.  A series is of only one modality (e.g. X-ray, CT, MR,
// ultrasound), but a study can have multiple series of different modality values.
type ImagingStudyPerformer struct {
	// Indicates who or what performed the imaging study.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of involvement of the performer in the imaging study..
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImagingStudyPerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in ImagingStudyPerformer: required")
	}
	type Plain ImagingStudyPerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImagingStudyPerformer(plain)
	return nil
}

// Representation of the content produced in a DICOM imaging study. A study
// comprises a set of series, each of which includes a set of Service-Object Pair
// Instances (SOP Instances - images or other data) acquired or produced in a
// common context.  A series is of only one modality (e.g. X-ray, CT, MR,
// ultrasound), but a study can have multiple series of different modality values.
type ImagingStudySeries struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for numberOfInstances
	NumberOfInstances *Element `json:"_numberOfInstances,omitempty"`

	// Extensions for started
	Started *Element `json:"_started,omitempty"`

	// Extensions for uid
	Uid *Element `json:"_uid,omitempty"`

	// The anatomic structures examined. See [DICOM Part 16 Annex
	// L](http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html)
	// for DICOM to SNOMED-CT mappings. The bodySite MAY include the laterality of
	// body part imaged.
	BodySite *CodeableReference `json:"bodySite,omitempty"`

	// Description or classification of the series.
	Description_2 *String `json:"description,omitempty"`

	// The network service providing access for the study. See implementation notes
	// for information about [using DICOM endpoints](imagingstudy.html#endpoints).
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A single SOP instance within the series, e.g. an image, or presentation state.
	Instance []ImagingStudyInstance `json:"instance,omitempty"`

	// The distinct modality for this series. This MAY be either an acquisition
	// modality (e.g., CT, MR) or a non-acquisition modality (e.g., segmentation,
	// presentation state).
	Modality CodeableConcept `json:"modality"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The numeric identifier of this series in the study.
	Number_2 *UnsignedInt `json:"number,omitempty"`

	// Number of SOP Instances in the Series. The value given MAY be larger than the
	// number of instance elements this series contains due to resource availability,
	// security, or other factors. This element SHOULD be present if any instance
	// elements are present.
	NumberOfInstances_2 *UnsignedInt `json:"numberOfInstances,omitempty"`

	// Indicates who or what performed the series and how they were involved.
	Performer []ImagingStudyPerformer `json:"performer,omitempty"`

	// The specimen imaged, e.g., for whole slide imaging of a biopsy.
	Specimen []Reference `json:"specimen,omitempty"`

	// The date and time the series was started.
	Started_2 *DateTime `json:"started,omitempty"`

	// The DICOM Series Instance UID of the series.
	Uid_2 *ID `json:"uid,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImagingStudySeries) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["modality"]; raw != nil && !ok {
		return fmt.Errorf("field modality in ImagingStudySeries: required")
	}
	type Plain ImagingStudySeries
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImagingStudySeries(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImagingStudy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ImagingStudy: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ImagingStudy: required")
	}
	type Plain ImagingStudy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImagingStudy(plain)
	return nil
}

// Describes the event of a patient being administered a vaccine or a record of an
// immunization as reported by a patient, a clinician or another party.
type Immunization struct {
	// Extensions for expirationDate
	ExpirationDate *Element `json:"_expirationDate,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for isSubpotent
	IsSubpotent *Element `json:"_isSubpotent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lotNumber
	LotNumber *Element `json:"_lotNumber,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for occurrenceString
	OccurrenceString *Element `json:"_occurrenceString,omitempty"`

	// Extensions for primarySource
	PrimarySource *Element `json:"_primarySource,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// An indication of which product was administered to the patient. This is
	// typically a more detailed representation of the concept conveyed by the
	// vaccineCode data element. If a Medication resource is referenced, it may be to
	// a stand-alone resource or a contained resource within the Immunization
	// resource.
	AdministeredProduct *CodeableReference `json:"administeredProduct,omitempty"`

	// A plan, order or recommendation fulfilled in whole or in part by this
	// immunization.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ImmunizationContainedElem `json:"contained,omitempty"`

	// The quantity of vaccine product that was administered.
	DoseQuantity *Quantity `json:"doseQuantity,omitempty"`

	// The visit or admission or other contact between patient and health care
	// provider the immunization was performed as part of.
	Encounter *Reference `json:"encounter,omitempty"`

	// Date vaccine batch expires.
	ExpirationDate_2 *Date `json:"expirationDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates the source of the vaccine actually administered. This may be
	// different than the patient eligibility (e.g. the patient may be eligible for a
	// publicly purchased vaccine but due to inventory issues, vaccine purchased with
	// private funds was actually administered).
	FundingSource *CodeableConcept `json:"fundingSource,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this immunization record.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Typically the source of the data when the report of the immunization event is
	// not based on information from the person who administered the vaccine.
	InformationSource *CodeableReference `json:"informationSource,omitempty"`

	// Indication if a dose is considered to be subpotent. By default, a dose should
	// be considered to be potent.
	IsSubpotent_2 *Boolean `json:"isSubpotent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The service delivery location where the vaccine administration occurred.
	Location *Reference `json:"location,omitempty"`

	// Lot number of the  vaccine product.
	LotNumber_2 *String `json:"lotNumber,omitempty"`

	// Name of vaccine manufacturer.
	Manufacturer *CodeableReference `json:"manufacturer,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Extra information about the immunization that is not conveyed by the other
	// attributes.
	Note []Annotation `json:"note,omitempty"`

	// Date vaccine administered or was to be administered.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// Date vaccine administered or was to be administered.
	OccurrenceString_2 *string `json:"occurrenceString,omitempty"`

	// The patient who either received or did not receive the immunization.
	Patient Reference `json:"patient"`

	// Indicates who performed the immunization event.
	Performer []ImmunizationPerformer `json:"performer,omitempty"`

	// Indicates whether the data contained in the resource was captured by the
	// individual/organization which was responsible for the administration of the
	// vaccine rather than as 'secondary reported' data documented by a third party. A
	// value of 'true' means this data originated with the individual/organization
	// which was responsible for the administration of the vaccine.
	PrimarySource_2 *Boolean `json:"primarySource,omitempty"`

	// Indicates a patient's eligibility for a funding program.
	ProgramEligibility []ImmunizationProgramEligibility `json:"programEligibility,omitempty"`

	// The protocol (set of recommendations) being followed by the provider who
	// administered the dose.
	ProtocolApplied []ImmunizationProtocolApplied `json:"protocolApplied,omitempty"`

	// Categorical data indicating that an adverse event is associated in time to an
	// immunization.
	Reaction []ImmunizationReaction `json:"reaction,omitempty"`

	// Describes why the immunization occurred in coded or textual form, or indicates
	// another resource (Condition, Observation or DiagnosticReport) whose existence
	// justifies this immunization.
	Reason []CodeableReference `json:"reason,omitempty"`

	// This is a Immunization resource
	ResourceType interface{} `json:"resourceType"`

	// The path by which the vaccine product is taken into the body.
	Route *CodeableConcept `json:"route,omitempty"`

	// Body site where vaccine was administered.
	Site *CodeableConcept `json:"site,omitempty"`

	// Indicates the current status of the immunization event.
	Status_2 *Code `json:"status,omitempty"`

	// Indicates the reason the immunization event was not performed.
	StatusReason *CodeableConcept `json:"statusReason,omitempty"`

	// Reason why a dose is considered to be subpotent.
	SubpotentReason []CodeableConcept `json:"subpotentReason,omitempty"`

	// Additional information that is relevant to the immunization (e.g. for a vaccine
	// recipient who is pregnant, the gestational age of the fetus). The reason why a
	// vaccine was given (e.g. occupation, underlying medical condition) should be
	// conveyed in Immunization.reason, not as supporting information. The reason why
	// a vaccine was not given (e.g. contraindication) should be conveyed in
	// Immunization.statusReason, not as supporting information.
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Vaccine that was administered or was to be administered.
	VaccineCode CodeableConcept `json:"vaccineCode"`
}

type ImmunizationContainedElem interface{}

// Describes the event of a patient being administered a vaccine or a record of an
// immunization as reported by a patient, a clinician or another party.
type ImmunizationPerformer struct {
	// The practitioner or organization who performed the action.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Describes the function played by the performer in the immunization event (e.g.
	// ordering provider, administering provider, etc.).
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImmunizationPerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in ImmunizationPerformer: required")
	}
	type Plain ImmunizationPerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImmunizationPerformer(plain)
	return nil
}

// Describes the event of a patient being administered a vaccine or a record of an
// immunization as reported by a patient, a clinician or another party.
type ImmunizationProgramEligibility struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates which program the patient had their eligibility evaluated for.
	Program CodeableConcept `json:"program"`

	// Indicates the patient's eligibility status for a specific payment program.
	ProgramStatus CodeableConcept `json:"programStatus"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImmunizationProgramEligibility) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["program"]; raw != nil && !ok {
		return fmt.Errorf("field program in ImmunizationProgramEligibility: required")
	}
	if _, ok := raw["programStatus"]; raw != nil && !ok {
		return fmt.Errorf("field programStatus in ImmunizationProgramEligibility: required")
	}
	type Plain ImmunizationProgramEligibility
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImmunizationProgramEligibility(plain)
	return nil
}

// Describes the event of a patient being administered a vaccine or a record of an
// immunization as reported by a patient, a clinician or another party.
type ImmunizationProtocolApplied struct {
	// Extensions for series
	Series *Element `json:"_series,omitempty"`

	// Indicates the authority who published the protocol (e.g. ACIP) that is being
	// followed.
	Authority *Reference `json:"authority,omitempty"`

	// Nominal position in a series as intended by the practitioner administering the
	// dose.
	DoseNumber *CodeableConcept `json:"doseNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// One possible path to achieve presumed immunity against a disease - within the
	// context of an authority.
	Series_2 *String `json:"series,omitempty"`

	// The recommended number of doses to achieve immunity as intended by the
	// practitioner administering the dose.
	SeriesDoses *CodeableConcept `json:"seriesDoses,omitempty"`

	// The vaccine preventable disease the dose is being administered against.
	TargetDisease []CodeableConcept `json:"targetDisease,omitempty"`
}

// Describes the event of a patient being administered a vaccine or a record of an
// immunization as reported by a patient, a clinician or another party.
type ImmunizationReaction struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for reported
	Reported *Element `json:"_reported,omitempty"`

	// Date of reaction to the immunization.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Details of the reaction.
	Manifestation *CodeableReference `json:"manifestation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Self-reported indicator.
	Reported_2 *Boolean `json:"reported,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Immunization) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in Immunization: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Immunization: required")
	}
	if _, ok := raw["vaccineCode"]; raw != nil && !ok {
		return fmt.Errorf("field vaccineCode in Immunization: required")
	}
	type Plain Immunization
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.OccurrenceString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.OccurrenceString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Immunization(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuide struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for fhirVersion
	FhirVersion []Element `json:"_fhirVersion,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for license
	License *Element `json:"_license,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for packageId
	PackageID *Element `json:"_packageId,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ImplementationGuideContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the implementation guide and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the implementation guide.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the implementation guide was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the implementation guide changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// The information needed by an IG publisher tool to publish the whole
	// implementation guide.
	Definition *ImplementationGuideDefinition `json:"definition,omitempty"`

	// Another implementation guide that this implementation depends on. Typically, an
	// implementation guide uses value sets, profiles etc.defined in other
	// implementation guides.
	DependsOn []ImplementationGuideDependsOn `json:"dependsOn,omitempty"`

	// A free text natural language description of the implementation guide from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this implementation guide is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The version(s) of the FHIR specification that this ImplementationGuide targets
	// - e.g. describes how to use. The value of this element is the formal version of
	// the specification, without the revision number, e.g.
	// [publication].[major].[minor], which is 4.6.0. for this version.
	FhirVersion_2 []Code `json:"fhirVersion,omitempty"`

	// A set of profiles that all resources covered by this implementation guide must
	// conform to.
	Global []ImplementationGuideGlobal `json:"global,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this implementation guide when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The license that applies to this Implementation Guide, using an SPDX license
	// code, or 'not-open-source'.
	License_2 *Code `json:"license,omitempty"`

	// Information about an assembled implementation guide, created by the publication
	// tooling.
	Manifest *ImplementationGuideManifest `json:"manifest,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the implementation guide. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The NPM package name for this Implementation Guide, used in the NPM package
	// distribution, which is the primary mechanism by which FHIR based tooling
	// manages IG dependencies. This value must be globally unique, and should be
	// assigned with care.
	PackageID_2 *ID `json:"packageId,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the implementation guide.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this implementation guide is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a ImplementationGuide resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this implementation guide. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the implementation guide.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this implementation guide when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this implementation guide is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the implementation guide is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate implementation
	// guide instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the implementation
	// guide when it is referenced in a specification, model, design or instance. This
	// is an arbitrary value managed by the implementation guide author and is not
	// expected to be globally unique. For example, it might be a timestamp (e.g.
	// yyyymmdd) if a managed version is not available. There is also no expectation
	// that versions can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type ImplementationGuideContainedElem interface{}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideDefinition struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A logical group of resources. Logical groups can be used when building pages.
	Grouping []ImplementationGuideGrouping `json:"grouping,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A page / section in the implementation guide. The root page is the
	// implementation guide home page.
	Page *ImplementationGuidePage `json:"page,omitempty"`

	// A set of parameters that defines how the implementation guide is built. The
	// parameters are defined by the relevant tools that build the implementation
	// guides.
	Parameter []ImplementationGuideParameter `json:"parameter,omitempty"`

	// A resource that is part of the implementation guide. Conformance resources
	// (value set, structure definition, capability statements etc.) are obvious
	// candidates for inclusion, but any kind of resource can be included as an
	// example resource.
	Resource []ImplementationGuideResource `json:"resource,omitempty"`

	// A template for building resources.
	Template []ImplementationGuideTemplate `json:"template,omitempty"`
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideDependsOn struct {
	// Extensions for packageId
	PackageID *Element `json:"_packageId,omitempty"`

	// Extensions for reason
	Reason *Element `json:"_reason,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The NPM package name for the Implementation Guide that this IG depends on.
	PackageID_2 *ID `json:"packageId,omitempty"`

	// A description explaining the nature of the dependency on the listed IG.
	Reason_2 *Markdown `json:"reason,omitempty"`

	// A canonical reference to the Implementation guide for the dependency.
	Uri Canonical `json:"uri"`

	// The version of the IG that is depended on, when the correct version is required
	// to understand the IG correctly.
	Version_2 *String `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideDependsOn) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ImplementationGuideDependsOn: required")
	}
	type Plain ImplementationGuideDependsOn
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideDependsOn(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideGlobal struct {
	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to the profile that all instances must conform to.
	Profile Canonical `json:"profile"`

	// The type of resource that all instances must conform to.
	Type_2 *Code `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideGlobal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["profile"]; raw != nil && !ok {
		return fmt.Errorf("field profile in ImplementationGuideGlobal: required")
	}
	type Plain ImplementationGuideGlobal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideGlobal(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideGrouping struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Human readable text describing the package.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The human-readable title to display for the package of resources when rendering
	// the implementation guide.
	Name_2 *String `json:"name,omitempty"`
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideManifest struct {
	// Extensions for image
	Image []Element `json:"_image,omitempty"`

	// Extensions for other
	Other []Element `json:"_other,omitempty"`

	// Extensions for rendering
	Rendering *Element `json:"_rendering,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Indicates a relative path to an image that exists within the IG.
	Image_2 []String `json:"image,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the relative path of an additional non-page, non-image file that is
	// part of the IG - e.g. zip, jar and similar files that could be the target of a
	// hyperlink in a derived IG.
	Other_2 []String `json:"other,omitempty"`

	// Information about a page within the IG.
	Page []ImplementationGuidePage1 `json:"page,omitempty"`

	// A pointer to official web page, PDF or other rendering of the implementation
	// guide.
	Rendering_2 *Url `json:"rendering,omitempty"`

	// A resource that is part of the implementation guide. Conformance resources
	// (value set, structure definition, capability statements etc.) are obvious
	// candidates for inclusion, but any kind of resource can be included as an
	// example resource.
	Resource []ImplementationGuideResource1 `json:"resource"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideManifest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resource"]; raw != nil && !ok {
		return fmt.Errorf("field resource in ImplementationGuideManifest: required")
	}
	type Plain ImplementationGuideManifest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideManifest(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuidePage struct {
	// Extensions for generation
	Generation *Element `json:"_generation,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for sourceMarkdown
	SourceMarkdown *Element `json:"_sourceMarkdown,omitempty"`

	// Extensions for sourceString
	SourceString *Element `json:"_sourceString,omitempty"`

	// Extensions for sourceUrl
	SourceUrl *Element `json:"_sourceUrl,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A code that indicates how the page is generated.
	Generation_2 *Code `json:"generation,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The url by which the page should be known when published.
	Name_2 *Url `json:"name,omitempty"`

	// Nested Pages/Sections under this page.
	Page []ImplementationGuidePage `json:"page,omitempty"`

	// Indicates the URL or the actual content to provide for the page.
	SourceMarkdown_2 *string `json:"sourceMarkdown,omitempty"`

	// Indicates the URL or the actual content to provide for the page.
	SourceString_2 *string `json:"sourceString,omitempty"`

	// Indicates the URL or the actual content to provide for the page.
	SourceUrl_2 *string `json:"sourceUrl,omitempty"`

	// A short title used to represent this page in navigational structures such as
	// table of contents, bread crumbs, etc.
	Title_2 *String `json:"title,omitempty"`
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuidePage1 struct {
	// Extensions for anchor
	Anchor []Element `json:"_anchor,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// The name of an anchor available on the page.
	Anchor_2 []String `json:"anchor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Relative path to the page.
	Name_2 *String `json:"name,omitempty"`

	// Label for the page intended for human display.
	Title_2 *String `json:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuidePage) UnmarshalJSON(value []byte) error {
	type Plain ImplementationGuidePage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SourceMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.SourceMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SourceMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.SourceString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.SourceString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SourceString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.SourceUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SourceUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SourceUrl_2", `^\S*$`)
		}
	}
	*j = ImplementationGuidePage(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideParameter struct {
	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A tool-specific code that defines the parameter.
	Code Coding `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Value for named type.
	Value_2 *String `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideParameter) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ImplementationGuideParameter: required")
	}
	type Plain ImplementationGuideParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideParameter(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideResource struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for fhirVersion
	FhirVersion []Element `json:"_fhirVersion,omitempty"`

	// Extensions for groupingId
	GroupingID *Element `json:"_groupingId,omitempty"`

	// Extensions for isExample
	IsExample *Element `json:"_isExample,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// A description of the reason that a resource has been included in the
	// implementation guide.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates the FHIR Version(s) this artifact is intended to apply to. If no
	// versions are specified, the resource is assumed to apply to all the versions
	// stated in ImplementationGuide.fhirVersion.
	FhirVersion_2 []Code `json:"fhirVersion,omitempty"`

	// Reference to the id of the grouping this resource appears in.
	GroupingID_2 *ID `json:"groupingId,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If true, indicates the resource is an example instance.
	IsExample_2 *Boolean `json:"isExample,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A human assigned name for the resource. All resources SHOULD have a name, but
	// the name may be extracted from the resource (e.g. ValueSet.name).
	Name_2 *String `json:"name,omitempty"`

	// If present, indicates profile(s) the instance is valid against.
	Profile []Canonical `json:"profile,omitempty"`

	// Where this resource is found.
	Reference Reference `json:"reference"`
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideResource1 struct {
	// Extensions for isExample
	IsExample *Element `json:"_isExample,omitempty"`

	// Extensions for relativePath
	RelativePath *Element `json:"_relativePath,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If true, indicates the resource is an example instance.
	IsExample_2 *Boolean `json:"isExample,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// If present, indicates profile(s) the instance is valid against.
	Profile []Canonical `json:"profile,omitempty"`

	// Where this resource is found.
	Reference Reference `json:"reference"`

	// The relative path for primary page for this resource within the IG.
	RelativePath_2 *Url `json:"relativePath,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideResource1) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in ImplementationGuideResource1: required")
	}
	type Plain ImplementationGuideResource1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideResource1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuideResource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in ImplementationGuideResource: required")
	}
	type Plain ImplementationGuideResource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImplementationGuideResource(plain)
	return nil
}

// A set of rules of how a particular interoperability or standards problem is
// solved - typically through the use of FHIR resources. This resource is used to
// gather all the parts of an implementation guide into a logical whole and to
// publish a computable definition of all the parts.
type ImplementationGuideTemplate struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for scope
	Scope *Element `json:"_scope,omitempty"`

	// Extensions for source
	Source *Element `json:"_source,omitempty"`

	// Type of template specified.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The scope in which the template applies.
	Scope_2 *String `json:"scope,omitempty"`

	// The source location for the template.
	Source_2 *String `json:"source,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationGuide) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ImplementationGuide: required")
	}
	type Plain ImplementationGuide
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ImplementationGuide(plain)
	return nil
}

// An ingredient of a manufactured item or pharmaceutical product.
type Ingredient struct {
	// Extensions for allergenicIndicator
	AllergenicIndicator *Element `json:"_allergenicIndicator,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// If the ingredient is a known or suspected allergen. Note that this is a
	// property of the substance, so if a reference to a SubstanceDefinition is used
	// to describe that (rather than just a code), the allergen information should go
	// there, not here.
	AllergenicIndicator_2 *Boolean `json:"allergenicIndicator,omitempty"`

	// A place for providing any notes that are relevant to the component, e.g.
	// removed during process, adjusted for loss on drying.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []IngredientContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The product which this ingredient is a constituent part of.
	For []Reference `json:"for,omitempty"`

	// A classification of the ingredient identifying its precise purpose(s) in the
	// drug product. This extends the Ingredient.role to add more detail. Example:
	// antioxidant, alkalizing agent.
	Function []CodeableConcept `json:"function,omitempty"`

	// A classification of the ingredient according to where in the physical item it
	// tends to be used, such the outer shell of a tablet, inner body or ink.
	Group *CodeableConcept `json:"group,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The identifier(s) of this Ingredient that are assigned by business processes
	// and/or used to refer to it when a direct URL reference to the resource itself
	// is not appropriate.
	Identifier *Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organization(s) that manufacture this ingredient. Can be used to indicate:
	// 1) Organizations we are aware of that manufacture this ingredient         2)
	// Specific Manufacturer(s) currently being used         3) Set of organisations
	// allowed to manufacture this ingredient for this product         Users must be
	// clear on the application of context relevant to their use case.
	Manufacturer []IngredientManufacturer `json:"manufacturer,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This is a Ingredient resource
	ResourceType interface{} `json:"resourceType"`

	// A classification of the ingredient identifying its purpose within the product,
	// e.g. active, inactive.
	Role CodeableConcept `json:"role"`

	// The status of this ingredient. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// The substance that comprises this ingredient.
	Substance IngredientSubstance `json:"substance"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type IngredientContainedElem interface{}

// An ingredient of a manufactured item or pharmaceutical product.
type IngredientManufacturer struct {
	// Extensions for role
	Role *Element `json:"_role,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An organization that manufactures this ingredient.
	Manufacturer Reference `json:"manufacturer"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The way in which this manufacturer is associated with the ingredient. For
	// example whether it is a possible one (others allowed), or an exclusive
	// authorized one for this ingredient. Note that this is not the manufacturing
	// process role.
	Role_2 *Code `json:"role,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IngredientManufacturer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["manufacturer"]; raw != nil && !ok {
		return fmt.Errorf("field manufacturer in IngredientManufacturer: required")
	}
	type Plain IngredientManufacturer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = IngredientManufacturer(plain)
	return nil
}

// An ingredient of a manufactured item or pharmaceutical product.
type IngredientReferenceStrength struct {
	// Extensions for measurementPoint
	MeasurementPoint *Element `json:"_measurementPoint,omitempty"`

	// The country or countries for which the strength range applies.
	Country []CodeableConcept `json:"country,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// For when strength is measured at a particular point or distance.
	MeasurementPoint_2 *String `json:"measurementPoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Strength expressed in terms of a reference substance.
	StrengthQuantity *Quantity `json:"strengthQuantity,omitempty"`

	// Strength expressed in terms of a reference substance.
	StrengthRatio *Ratio `json:"strengthRatio,omitempty"`

	// Strength expressed in terms of a reference substance.
	StrengthRatioRange *RatioRange `json:"strengthRatioRange,omitempty"`

	// Relevant reference substance.
	Substance CodeableReference `json:"substance"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IngredientReferenceStrength) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["substance"]; raw != nil && !ok {
		return fmt.Errorf("field substance in IngredientReferenceStrength: required")
	}
	type Plain IngredientReferenceStrength
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = IngredientReferenceStrength(plain)
	return nil
}

// An ingredient of a manufactured item or pharmaceutical product.
type IngredientStrength struct {
	// Extensions for measurementPoint
	MeasurementPoint *Element `json:"_measurementPoint,omitempty"`

	// Extensions for textConcentration
	TextConcentration *Element `json:"_textConcentration,omitempty"`

	// Extensions for textPresentation
	TextPresentation *Element `json:"_textPresentation,omitempty"`

	// A code that indicates if the strength is, for example, based on the ingredient
	// substance as stated or on the substance base (when the ingredient is a salt).
	Basis *CodeableConcept `json:"basis,omitempty"`

	// The strength per unitary volume (or mass).
	ConcentrationCodeableConcept *CodeableConcept `json:"concentrationCodeableConcept,omitempty"`

	// The strength per unitary volume (or mass).
	ConcentrationQuantity *Quantity `json:"concentrationQuantity,omitempty"`

	// The strength per unitary volume (or mass).
	ConcentrationRatio *Ratio `json:"concentrationRatio,omitempty"`

	// The strength per unitary volume (or mass).
	ConcentrationRatioRange *RatioRange `json:"concentrationRatioRange,omitempty"`

	// The country or countries for which the strength range applies.
	Country []CodeableConcept `json:"country,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// For when strength is measured at a particular point or distance. There are
	// products where strength is measured at a particular point. For example, the
	// strength of the ingredient in some inhalers is measured at a particular
	// position relative to the point of aerosolization.
	MeasurementPoint_2 *String `json:"measurementPoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The quantity of substance in the unit of presentation, or in the volume (or
	// mass) of the single pharmaceutical product or manufactured item. Unit of
	// presentation refers to the quantity that the item occurs in e.g. a strength per
	// tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally
	// normalized as a unitary unit, which would be 'per mg').
	PresentationCodeableConcept *CodeableConcept `json:"presentationCodeableConcept,omitempty"`

	// The quantity of substance in the unit of presentation, or in the volume (or
	// mass) of the single pharmaceutical product or manufactured item. Unit of
	// presentation refers to the quantity that the item occurs in e.g. a strength per
	// tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally
	// normalized as a unitary unit, which would be 'per mg').
	PresentationQuantity *Quantity `json:"presentationQuantity,omitempty"`

	// The quantity of substance in the unit of presentation, or in the volume (or
	// mass) of the single pharmaceutical product or manufactured item. Unit of
	// presentation refers to the quantity that the item occurs in e.g. a strength per
	// tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally
	// normalized as a unitary unit, which would be 'per mg').
	PresentationRatio *Ratio `json:"presentationRatio,omitempty"`

	// The quantity of substance in the unit of presentation, or in the volume (or
	// mass) of the single pharmaceutical product or manufactured item. Unit of
	// presentation refers to the quantity that the item occurs in e.g. a strength per
	// tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally
	// normalized as a unitary unit, which would be 'per mg').
	PresentationRatioRange *RatioRange `json:"presentationRatioRange,omitempty"`

	// Strength expressed in terms of a reference substance. For when the ingredient
	// strength is additionally expressed as equivalent to the strength of some other
	// closely related substance (e.g. salt vs. base). Reference strength represents
	// the strength (quantitative composition) of the active moiety of the active
	// substance. There are situations when the active substance and active moiety are
	// different, therefore both a strength and a reference strength are needed.
	ReferenceStrength []IngredientReferenceStrength `json:"referenceStrength,omitempty"`

	// A textual representation of either the whole of the concentration strength or a
	// part of it - with the rest being in Strength.concentration as a ratio.
	TextConcentration_2 *String `json:"textConcentration,omitempty"`

	// A textual representation of either the whole of the presentation strength or a
	// part of it - with the rest being in Strength.presentation as a ratio.
	TextPresentation_2 *String `json:"textPresentation,omitempty"`
}

// An ingredient of a manufactured item or pharmaceutical product.
type IngredientSubstance struct {
	// A code or full resource that represents the ingredient's substance.
	Code CodeableReference `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The quantity of substance in the unit of presentation, or in the volume (or
	// mass) of the single pharmaceutical product or manufactured item. The allowed
	// repetitions do not represent different strengths, but are different
	// representations - mathematically equivalent - of a single strength.
	Strength []IngredientStrength `json:"strength,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IngredientSubstance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in IngredientSubstance: required")
	}
	type Plain IngredientSubstance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = IngredientSubstance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ingredient) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Ingredient: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in Ingredient: required")
	}
	if _, ok := raw["substance"]; raw != nil && !ok {
		return fmt.Errorf("field substance in Ingredient: required")
	}
	type Plain Ingredient
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Ingredient(plain)
	return nil
}

// An instant in time - known at least to the second
type Instant string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Instant) UnmarshalJSON(value []byte) error {
	type Plain Instant
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
	}
	*j = Instant(plain)
	return nil
}

// InsurancePlan describes the costs to the subscriber or beneficiary associated
// with benefits, as well as additional information about the offering, such as who
// administers the plan, a coverage area, contact information, etc.  The specific
// benefits covered by the plan are described in the `InsuranceProduct` referenced
// in `InsurancePlan.product`.
type InsurancePlan struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []InsurancePlanContainedElem `json:"contained,omitempty"`

	// The geographic region in which a health insurance plan's benefits apply.
	CoverageArea []Reference `json:"coverageArea,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Overall costs associated with the plan.
	GeneralCost []InsurancePlanGeneralCost `json:"generalCost,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers, such as the plan ID and/or group ID associated with the insurance
	// plan.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the network that providing the type of coverage.
	Network []Reference `json:"network,omitempty"`

	// The product that this plan is available under.
	Product *Reference `json:"product,omitempty"`

	// This is a InsurancePlan resource
	ResourceType interface{} `json:"resourceType"`

	// Costs associated with the coverage provided by the product-plan.
	SpecificCost []InsurancePlanSpecificCost `json:"specificCost,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Type of plan. For example, "Platinum" or "High Deductable".
	Type *CodeableConcept `json:"type,omitempty"`
}

// InsurancePlan describes the costs to the subscriber or beneficiary associated
// with benefits, as well as additional information about the offering, such as who
// administers the plan, a coverage area, contact information, etc.  The specific
// benefits covered by the plan are described in the `InsuranceProduct` referenced
// in `InsurancePlan.product`.
type InsurancePlanBenefit struct {
	// List of the costs associated with a specific benefit.
	Cost []InsurancePlanCost `json:"cost,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Type of specific benefit (preventative; primary care office visit; speciality
	// office visit; hospitalization; emergency room; urgent care).
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsurancePlanBenefit) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InsurancePlanBenefit: required")
	}
	type Plain InsurancePlanBenefit
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsurancePlanBenefit(plain)
	return nil
}

type InsurancePlanContainedElem interface{}

// InsurancePlan describes the costs to the subscriber or beneficiary associated
// with benefits, as well as additional information about the offering, such as who
// administers the plan, a coverage area, contact information, etc.  The specific
// benefits covered by the plan are described in the `InsuranceProduct` referenced
// in `InsurancePlan.product`.
type InsurancePlanCost struct {
	// Whether the cost applies to in-network or out-of-network providers (in-network;
	// out-of-network; other).
	Applicability *CodeableConcept `json:"applicability,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional information about the cost, such as information about funding
	// sources (e.g. HSA, HRA, FSA, RRA).
	Qualifier []CodeableConcept `json:"qualifier,omitempty"`

	// Type of cost (copay; individual cap; family cap; coinsurance; deductible).
	Type CodeableConcept `json:"type"`

	// The actual cost value. (some of the costs may be represented as percentages
	// rather than currency, e.g. 10% coinsurance).
	Value *Quantity `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsurancePlanCost) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InsurancePlanCost: required")
	}
	type Plain InsurancePlanCost
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsurancePlanCost(plain)
	return nil
}

// InsurancePlan describes the costs to the subscriber or beneficiary associated
// with benefits, as well as additional information about the offering, such as who
// administers the plan, a coverage area, contact information, etc.  The specific
// benefits covered by the plan are described in the `InsuranceProduct` referenced
// in `InsurancePlan.product`.
type InsurancePlanGeneralCost struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for groupSize
	GroupSize *Element `json:"_groupSize,omitempty"`

	// Additional information about the general costs associated with this plan.
	Comment_2 *String `json:"comment,omitempty"`

	// Value of the cost.
	Cost *Money `json:"cost,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Number of participants enrolled in the plan.
	GroupSize_2 *PositiveInt `json:"groupSize,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Type of cost.
	Type *CodeableConcept `json:"type,omitempty"`
}

// InsurancePlan describes the costs to the subscriber or beneficiary associated
// with benefits, as well as additional information about the offering, such as who
// administers the plan, a coverage area, contact information, etc.  The specific
// benefits covered by the plan are described in the `InsuranceProduct` referenced
// in `InsurancePlan.product`.
type InsurancePlanSpecificCost struct {
	// List of the specific benefits under this category of benefit.
	Benefit []InsurancePlanBenefit `json:"benefit,omitempty"`

	// General category of benefit (Medical; Dental; Vision; Drug; Mental Health;
	// Substance Abuse; Hospice, Home Health).
	Category CodeableConcept `json:"category"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsurancePlanSpecificCost) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in InsurancePlanSpecificCost: required")
	}
	type Plain InsurancePlanSpecificCost
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsurancePlanSpecificCost(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsurancePlan) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in InsurancePlan: required")
	}
	type Plain InsurancePlan
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsurancePlan(plain)
	return nil
}

// A product is a discrete package of health insurance coverage benefits that are
// offered under a particular network, by an organization (payer) and additional
// information about the offering, such as who it is owned and administered by, a
// coverage area, contact information, etc.
type InsuranceProduct struct {
	// Extensions for alias
	Alias []Element `json:"_alias,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// An organization which administer other services such as underwriting, customer
	// service and/or claims processing on behalf of the health insurance product
	// owner.
	AdministeredBy *Reference `json:"administeredBy,omitempty"`

	// A list of alternate names that the product is known as, or was known as in the
	// past.
	Alias_2 []String `json:"alias,omitempty"`

	// The contact details of communication devices available relevant to the specific
	// Insurance Product. This can include addresses, phone numbers, fax numbers,
	// mobile numbers, email addresses and web sites.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []InsuranceProductContainedElem `json:"contained,omitempty"`

	// Details about the coverage offered by the insurance product.
	Coverage []InsuranceProductCoverage `json:"coverage,omitempty"`

	// The geographic region in which a health insurance product's benefits apply.
	CoverageArea []Reference `json:"coverageArea,omitempty"`

	// The technical endpoints providing access to services operated for the health
	// insurance product.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this health insurance product which remain
	// constant as the resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Official name of the health insurance product as designated by the owner.
	Name_2 *String `json:"name,omitempty"`

	// Reference to the network included in the health insurance product.
	Network []Reference `json:"network,omitempty"`

	// The entity that is providing  the health insurance product and underwriting the
	// risk.  This is typically an insurance carriers, other third-party payers, or
	// health plan sponsors comonly referred to as 'payers'.
	OwnedBy *Reference `json:"ownedBy,omitempty"`

	// The period of time that the health insurance product is available.
	Period *Period `json:"period,omitempty"`

	// Another product that is related to this product. Often used to create
	// relationships to parents or families of products.
	Related []InsuranceProductRelated `json:"related,omitempty"`

	// This is a InsuranceProduct resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of the health insurance product.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The kind of health insurance product.
	Type []CodeableConcept `json:"type,omitempty"`
}

// A product is a discrete package of health insurance coverage benefits that are
// offered under a particular network, by an organization (payer) and additional
// information about the offering, such as who it is owned and administered by, a
// coverage area, contact information, etc.
type InsuranceProductBenefit struct {
	// Extensions for requirement
	Requirement *Element `json:"_requirement,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The specific limits on the benefit.
	Limit []InsuranceProductLimit `json:"limit,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The referral requirements to have access/coverage for this benefit.
	Requirement_2 *String `json:"requirement,omitempty"`

	// Type of benefit (primary care; specialty care; inpatient; outpatient).
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsuranceProductBenefit) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InsuranceProductBenefit: required")
	}
	type Plain InsuranceProductBenefit
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsuranceProductBenefit(plain)
	return nil
}

type InsuranceProductContainedElem interface{}

// A product is a discrete package of health insurance coverage benefits that are
// offered under a particular network, by an organization (payer) and additional
// information about the offering, such as who it is owned and administered by, a
// coverage area, contact information, etc.
type InsuranceProductCoverage struct {
	// Specific benefits under this type of coverage.
	Benefit []InsuranceProductBenefit `json:"benefit"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the network that providing the type of coverage.
	Network []Reference `json:"network,omitempty"`

	// Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision;
	// Drug; Short Term; Long Term Care; Hospice; Home Health).
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsuranceProductCoverage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["benefit"]; raw != nil && !ok {
		return fmt.Errorf("field benefit in InsuranceProductCoverage: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InsuranceProductCoverage: required")
	}
	type Plain InsuranceProductCoverage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsuranceProductCoverage(plain)
	return nil
}

// A product is a discrete package of health insurance coverage benefits that are
// offered under a particular network, by an organization (payer) and additional
// information about the offering, such as who it is owned and administered by, a
// coverage area, contact information, etc.
type InsuranceProductLimit struct {
	// The specific limit on the benefit.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The maximum amount of a service item a plan will pay for a covered benefit.
	// For examples. wellness visits, or eyeglasses.
	Value *Quantity `json:"value,omitempty"`
}

// A product is a discrete package of health insurance coverage benefits that are
// offered under a particular network, by an organization (payer) and additional
// information about the offering, such as who it is owned and administered by, a
// coverage area, contact information, etc.
type InsuranceProductRelated struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Period of time that the product relationship is valid. The start and/or end
	// dates can be empty if this is an open ended relationship.
	Period *Period `json:"period,omitempty"`

	// The Related Product reference.
	Product *Reference `json:"product,omitempty"`

	// The relationship of this product to the related product. an example would be
	// 'sub-plan' where this product is a sub-plan of the related.product.
	Relationship *CodeableConcept `json:"relationship,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InsuranceProduct) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in InsuranceProduct: required")
	}
	type Plain InsuranceProduct
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InsuranceProduct(plain)
	return nil
}

// A whole number
type Integer float64

// A very large whole number
type Integer64 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Integer64) UnmarshalJSON(value []byte) error {
	type Plain Integer64
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^[0]|[-+]?[1-9][0-9]*$`)
	}
	*j = Integer64(plain)
	return nil
}

// Invoice containing collected ChargeItems from an Account with calculated
// individual and total price for Billing purpose.
type Invoice struct {
	// Extensions for cancelledReason
	CancelledReason *Element `json:"_cancelledReason,omitempty"`

	// Extensions for creation
	Creation *Element `json:"_creation,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for paymentTerms
	PaymentTerms *Element `json:"_paymentTerms,omitempty"`

	// Extensions for periodDate
	PeriodDate *Element `json:"_periodDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Account which is supposed to be balanced with this Invoice.
	Account *Reference `json:"account,omitempty"`

	// In case of Invoice cancellation a reason must be given (entered in error,
	// superseded by corrected invoice etc.).
	CancelledReason_2 *String `json:"cancelledReason,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []InvoiceContainedElem `json:"contained,omitempty"`

	// Date/time(s) of when this Invoice was posted.
	Creation_2 *DateTime `json:"creation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier of this Invoice, often used for reference in correspondence about
	// this invoice or for tracking of payments.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The organizationissuing the Invoice.
	Issuer *Reference `json:"issuer,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Each line item represents one charge for goods and services rendered. Details
	// such.ofType(date), code and amount are found in the referenced ChargeItem
	// resource.
	LineItem []InvoiceLineItem `json:"lineItem,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the invoice by the issuer, subject, or other participants.
	Note []Annotation `json:"note,omitempty"`

	// Indicates who or what performed or participated in the charged service.
	Participant []InvoiceParticipant `json:"participant,omitempty"`

	// Payment details such as banking details, period of payment, deductibles,
	// methods of payment.
	PaymentTerms_2 *Markdown `json:"paymentTerms,omitempty"`

	// Date/time(s) range of services included in this invoice.
	PeriodDate_2 *string `json:"periodDate,omitempty"`

	// Date/time(s) range of services included in this invoice.
	PeriodPeriod *Period `json:"periodPeriod,omitempty"`

	// The individual or Organization responsible for balancing of this invoice.
	Recipient *Reference `json:"recipient,omitempty"`

	// This is a Invoice resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of the Invoice.
	Status_2 *Code `json:"status,omitempty"`

	// The individual or set of individuals receiving the goods and services billed in
	// this invoice.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Invoice total, tax included.
	TotalGross *Money `json:"totalGross,omitempty"`

	// Invoice total , taxes excluded.
	TotalNet *Money `json:"totalNet,omitempty"`

	// The total amount for the Invoice may be calculated as the sum of the line items
	// with surcharges/deductions that apply in certain conditions.  The
	// priceComponent element can be used to offer transparency to the recipient of
	// the Invoice of how the total price was calculated.
	TotalPriceComponent []MonetaryComponent `json:"totalPriceComponent,omitempty"`

	// Type of Invoice depending on domain, realm an usage (e.g. internal/external,
	// dental, preliminary).
	Type *CodeableConcept `json:"type,omitempty"`
}

type InvoiceContainedElem interface{}

// Invoice containing collected ChargeItems from an Account with calculated
// individual and total price for Billing purpose.
type InvoiceLineItem struct {
	// Extensions for sequence
	Sequence *Element `json:"_sequence,omitempty"`

	// Extensions for servicedDate
	ServicedDate *Element `json:"_servicedDate,omitempty"`

	// The ChargeItem contains information such as the billing code, date, amount etc.
	// If no further details are required for the lineItem, inline billing codes can
	// be added using the CodeableConcept data type instead of the Reference.
	ChargeItemCodeableConcept *CodeableConcept `json:"chargeItemCodeableConcept,omitempty"`

	// The ChargeItem contains information such as the billing code, date, amount etc.
	// If no further details are required for the lineItem, inline billing codes can
	// be added using the CodeableConcept data type instead of the Reference.
	ChargeItemReference *Reference `json:"chargeItemReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The price for a ChargeItem may be calculated as a base price with
	// surcharges/deductions that apply in certain conditions. A ChargeItemDefinition
	// resource that defines the prices, factors and conditions that apply to a
	// billing code is currently under development. The priceComponent element can be
	// used to offer transparency to the recipient of the Invoice as to how the prices
	// have been calculated.
	PriceComponent []MonetaryComponent `json:"priceComponent,omitempty"`

	// Sequence in which the items appear on the invoice.
	Sequence_2 *PositiveInt `json:"sequence,omitempty"`

	// Date/time(s) range when this service was delivered or completed.
	ServicedDate_2 *string `json:"servicedDate,omitempty"`

	// Date/time(s) range when this service was delivered or completed.
	ServicedPeriod *Period `json:"servicedPeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvoiceLineItem) UnmarshalJSON(value []byte) error {
	type Plain InvoiceLineItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ServicedDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ServicedDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ServicedDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = InvoiceLineItem(plain)
	return nil
}

// Invoice containing collected ChargeItems from an Account with calculated
// individual and total price for Billing purpose.
type InvoiceParticipant struct {
	// The device, practitioner, etc. who performed or participated in the service.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Describes the type of involvement (e.g. transcriptionist, creator etc.). If the
	// invoice has been created automatically, the Participant may be a billing engine
	// or another kind of device.
	Role *CodeableConcept `json:"role,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvoiceParticipant) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in InvoiceParticipant: required")
	}
	type Plain InvoiceParticipant
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InvoiceParticipant(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Invoice) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Invoice: required")
	}
	type Plain Invoice
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.PeriodDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.PeriodDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PeriodDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = Invoice(plain)
	return nil
}

// The Library resource is a general-purpose container for knowledge artifact
// definitions. It can be used to describe and expose existing knowledge artifacts
// such as logic libraries and information model descriptions, as well as to
// describe a collection of knowledge artifacts.
type Library struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []LibraryContainedElem `json:"contained,omitempty"`

	// The content of the library as an Attachment. The content may be a reference to
	// a url, or may be directly embedded as a base-64 string. Either way, the
	// contentType of the attachment determines how to interpret the content.
	Content []Attachment `json:"content,omitempty"`

	// A copyright statement relating to the library and/or its contents. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the library.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// Describes a set of data that must be provided in order to be able to
	// successfully perform the computations defined by the library.
	DataRequirement []DataRequirement `json:"dataRequirement,omitempty"`

	// The date  (and optionally time) when the library was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the library changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the library from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the library content was or is planned to be in active
	// use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this library is authored for testing purposes
	// (or education/evaluation/marketing) and no version of this resource will ever
	// be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this library when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance. e.g. CMS or NQF identifiers for a measure artifact. Note that
	// at least one identifier is required for non-experimental active artifacts.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the library. This name should be usable as
	// an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// The parameter element defines parameters used by the library.
	Parameter []ParameterDefinition `json:"parameter,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the library.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this library is needed and why it has been designed as it
	// has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a Library resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this library. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// A code or group definition that describes the intended subject of the contents
	// of the library.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code or group definition that describes the intended subject of the contents
	// of the library.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// An explanatory or alternate title for the library giving additional information
	// about its content.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the library.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the library. Topics provide a
	// high-level categorization of the library that can be useful for filtering and
	// searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// Identifies the type of library such as a Logic Library, Model Definition, Asset
	// Collection, or Module Definition.
	Type CodeableConcept `json:"type"`

	// An absolute URI that is used to identify this library when it is referenced in
	// a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this library is (or will be) published. This
	// URL can be the target of a canonical reference. It SHALL remain the same when
	// the library is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the library is used from a clinical perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate library
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the library when it is
	// referenced in a specification, model, design or instance. This is an arbitrary
	// value managed by the library author and is not expected to be globally unique.
	// For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
	// not available. There is also no expectation that versions can be placed in a
	// lexicographical sequence. To provide a version consistent with the Decision
	// Support Service specification, use the format Major.Minor.Revision (e.g.
	// 1.0.0). For more information on versioning knowledge artifacts, refer to the
	// Decision Support Service specification. Note that a version is required for
	// non-experimental active artifacts.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type LibraryContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Library) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Library: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Library: required")
	}
	type Plain Library
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Library(plain)
	return nil
}

// A List is a curated collection of resources, for things such as problem lists,
// allergy lists, facility list, organization list, etc.
type List struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// This code defines the purpose of the list - why it was created.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ListContainedElem `json:"contained,omitempty"`

	// Date list was last reviewed/revised and determined to be 'current'.
	Date_2 *DateTime `json:"date,omitempty"`

	// If the list is empty, why the list is empty.
	EmptyReason *CodeableConcept `json:"emptyReason,omitempty"`

	// The encounter that is the context in which this list was created.
	Encounter *Reference `json:"encounter,omitempty"`

	// Entries in this list.
	Entry []ListEntry `json:"entry,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for the List assigned for business purposes outside the context of
	// FHIR.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// How this list was prepared - whether it is a working list that is suitable for
	// being maintained on an ongoing basis, or if it represents a snapshot of a list
	// of items from another source, or whether it is a prepared list where items may
	// be marked as added, modified or deleted.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments that apply to the overall list.
	Note []Annotation `json:"note,omitempty"`

	// What order applies to the items in the list.
	OrderedBy *CodeableConcept `json:"orderedBy,omitempty"`

	// This is a List resource
	ResourceType interface{} `json:"resourceType"`

	// The entity responsible for deciding what the contents of the list were. Where
	// the list was created by a human, this is the same as the author of the list.
	Source *Reference `json:"source,omitempty"`

	// Indicates the current state of this list.
	Status_2 *Code `json:"status,omitempty"`

	// The common subject(s) (or patient(s)) of the resources that are in the list if
	// there is one (or a set of subjects).
	Subject []Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A label for the list assigned by the author.
	Title_2 *String `json:"title,omitempty"`
}

type ListContainedElem interface{}

// A List is a curated collection of resources, for things such as problem lists,
// allergy lists, facility list, organization list, etc.
type ListEntry struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for deleted
	Deleted *Element `json:"_deleted,omitempty"`

	// When this item was added to the list.
	Date_2 *DateTime `json:"date,omitempty"`

	// True if this item is marked as deleted in the list.
	Deleted_2 *Boolean `json:"deleted,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The flag allows the system constructing the list to indicate the role and
	// significance of the item in the list.
	Flag *CodeableConcept `json:"flag,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A reference to the actual resource from which data was derived.
	Item Reference `json:"item"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListEntry) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in ListEntry: required")
	}
	type Plain ListEntry
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *List) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in List: required")
	}
	type Plain List
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = List(plain)
	return nil
}

// Details and position information for a place where services are provided and
// resources and participants may be stored, found, contained, or accommodated.
type Location struct {
	// Extensions for alias
	Alias []Element `json:"_alias,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Physical location.
	Address *Address `json:"address,omitempty"`

	// A list of alternate names that the location is known as, or was known as, in
	// the past.
	Alias_2 []String `json:"alias,omitempty"`

	// Collection of characteristics (attributes).
	Characteristic []CodeableConcept `json:"characteristic,omitempty"`

	// A coded representation of this Location, where the codes may be found in a
	// geospatial system.
	Code []CodeableConcept `json:"code,omitempty"`

	// The contact details of communication devices available at the location. This
	// can include addresses, phone numbers, fax numbers, mobile numbers, email
	// addresses and web sites.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []LocationContainedElem `json:"contained,omitempty"`

	// Description of the Location, which helps in finding or referencing the place.
	Description_2 *Markdown `json:"description,omitempty"`

	// Technical endpoints providing access to services operated for the location.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Physical form of the location, e.g. building, room, vehicle, road, virtual.
	Form *CodeableConcept `json:"form,omitempty"`

	// What days/times during a week is this location usually open, and any exceptions
	// where the location is not available.
	HoursOfOperation *Availability `json:"hoursOfOperation,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique code or number identifying the location to its users.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organization responsible for the provisioning and upkeep of the location.
	ManagingOrganization *Reference `json:"managingOrganization,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// Indicates whether a resource instance represents a specific location or a class
	// of locations.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of the location as used by humans. Does not need to be unique.
	Name_2 *String `json:"name,omitempty"`

	// The operational status covers operation values most relevant to beds (but can
	// also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis
	// chair). This typically covers concepts such as contamination, housekeeping, and
	// other activities like maintenance.
	OperationalStatus *Coding `json:"operationalStatus,omitempty"`

	// Another Location of which this Location is physically a part of.
	PartOf *Reference `json:"partOf,omitempty"`

	// The absolute geographic location of the Location, expressed using the WGS84
	// datum (This is the same co-ordinate system used in KML).
	Position *LocationPosition `json:"position,omitempty"`

	// This is a Location resource
	ResourceType interface{} `json:"resourceType"`

	// The status property covers the general availability of the resource, not the
	// current value which may be covered by the operationalStatus, or by a
	// schedule/slots if they are configured for the location.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Indicates the type of services that are available at this location.
	Type []CodeableConcept `json:"type,omitempty"`

	// Connection details of a virtual service (e.g. shared conference call facility
	// with dedicated number/details).
	VirtualService []VirtualServiceDetail `json:"virtualService,omitempty"`
}

type LocationContainedElem interface{}

// Details and position information for a place where services are provided and
// resources and participants may be stored, found, contained, or accommodated.
type LocationPosition struct {
	// Extensions for altitude
	Altitude *Element `json:"_altitude,omitempty"`

	// Extensions for latitude
	Latitude *Element `json:"_latitude,omitempty"`

	// Extensions for longitude
	Longitude *Element `json:"_longitude,omitempty"`

	// Altitude. The value domain and the interpretation are the same as for the text
	// of the altitude element in KML (see notes on Location main page).
	Altitude_2 *Decimal `json:"altitude,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Latitude. The value domain and the interpretation are the same as for the text
	// of the latitude element in KML (see notes on Location main page).
	Latitude_2 *Decimal `json:"latitude,omitempty"`

	// Longitude. The value domain and the interpretation are the same as for the text
	// of the longitude element in KML (see notes on Location main page).
	Longitude_2 *Decimal `json:"longitude,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Location) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Location: required")
	}
	type Plain Location
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Location(plain)
	return nil
}

// The definition and characteristics of a medicinal manufactured item, such as a
// tablet or capsule, as contained in a packaged medicinal product.
type ManufacturedItemDefinition struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Physical parts of the manufactured item, that it is intrinsically made from.
	// This is distinct from the ingredients that are part of its chemical makeup.
	Component []ManufacturedItemDefinitionComponent `json:"component,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ManufacturedItemDefinitionContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique identifier.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The ingredients of this manufactured item. This is only needed if the
	// ingredients are not specified by incoming references from the Ingredient
	// resource.
	Ingredient []CodeableConcept `json:"ingredient,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Dose form as manufactured and before any transformation into the pharmaceutical
	// product.
	ManufacturedDoseForm CodeableConcept `json:"manufacturedDoseForm"`

	// Manufacturer of the item, one of several possible.
	Manufacturer []Reference `json:"manufacturer,omitempty"`

	// Allows specifying that an item is on the market for sale, or that it is not
	// available, and the dates and locations associated.
	MarketingStatus []MarketingStatus `json:"marketingStatus,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A descriptive name applied to this item.
	Name_2 *String `json:"name,omitempty"`

	// General characteristics of this item.
	Property []ManufacturedItemDefinitionProperty `json:"property,omitempty"`

	// This is a ManufacturedItemDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this item. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The â€œreal-worldâ€ units in which the quantity of the manufactured item is
	// described.
	UnitOfPresentation *CodeableConcept `json:"unitOfPresentation,omitempty"`
}

// The definition and characteristics of a medicinal manufactured item, such as a
// tablet or capsule, as contained in a packaged medicinal product.
type ManufacturedItemDefinitionComponent struct {
	// The measurable amount of total quantity of all substances in the component,
	// expressible in different ways (e.g. by mass or volume).
	Amount []Quantity `json:"amount,omitempty"`

	// A component that this component contains or is made from.
	Component []ManufacturedItemDefinitionComponent `json:"component,omitempty"`

	// A reference to a constituent of the manufactured item as a whole, linked here
	// so that its component location within the item can be indicated. This not where
	// the item's ingredient are primarily stated (for which see Ingredient.for or
	// ManufacturedItemDefinition.ingredient).
	Constituent []ManufacturedItemDefinitionConstituent `json:"constituent,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The function of this component within the item e.g. delivers active ingredient,
	// masks taste.
	Function []CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// General characteristics of this component.
	Property []ManufacturedItemDefinitionProperty `json:"property,omitempty"`

	// Defining type of the component e.g. shell, layer, ink.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ManufacturedItemDefinitionComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ManufacturedItemDefinitionComponent: required")
	}
	type Plain ManufacturedItemDefinitionComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ManufacturedItemDefinitionComponent(plain)
	return nil
}

// The definition and characteristics of a medicinal manufactured item, such as a
// tablet or capsule, as contained in a packaged medicinal product.
type ManufacturedItemDefinitionConstituent struct {
	// The measurable amount of the substance, expressible in different ways (e.g. by
	// mass or volume).
	Amount []Quantity `json:"amount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The function of this constituent within the component e.g. binder.
	Function []CodeableConcept `json:"function,omitempty"`

	// The ingredient that is the constituent of the given component.
	HasIngredient []CodeableReference `json:"hasIngredient,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The physical location of the constituent/ingredient within the component.
	// Example â€“ if the component is the bead in the capsule, then the location would
	// be where the ingredient resides within the product part â€“ intragranular,
	// extra-granular, etc.
	Location []CodeableConcept `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type ManufacturedItemDefinitionContainedElem interface{}

// The definition and characteristics of a medicinal manufactured item, such as a
// tablet or capsule, as contained in a packaged medicinal product.
type ManufacturedItemDefinitionProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code expressing the type of characteristic.
	Type CodeableConcept `json:"type"`

	// A value for the characteristic.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// A value for the characteristic.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// A value for the characteristic.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value for the characteristic.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A value for the characteristic.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// A value for the characteristic.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A value for the characteristic.
	ValueRange *Range `json:"valueRange,omitempty"`

	// A value for the characteristic.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ManufacturedItemDefinitionProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ManufacturedItemDefinitionProperty: required")
	}
	type Plain ManufacturedItemDefinitionProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	*j = ManufacturedItemDefinitionProperty(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ManufacturedItemDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["manufacturedDoseForm"]; raw != nil && !ok {
		return fmt.Errorf("field manufacturedDoseForm in ManufacturedItemDefinition: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ManufacturedItemDefinition: required")
	}
	type Plain ManufacturedItemDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ManufacturedItemDefinition(plain)
	return nil
}

// A string that may contain Github Flavored Markdown syntax for optional
// processing by a mark down presentation engine
type Markdown string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Markdown) UnmarshalJSON(value []byte) error {
	type Plain Markdown
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^^[\s\S]+$$`)
	}
	*j = Markdown(plain)
	return nil
}

// The marketing status describes the date when an item is actually put on the
// market or the date as of which it is no longer available.
type MarketingStatus struct {
	// Extensions for restoreDate
	RestoreDate *Element `json:"_restoreDate,omitempty"`

	// The country in which the marketing status applies.
	Country *CodeableConcept `json:"country,omitempty"`

	// The dates that the item is made available on the market by the owner (or where
	// applicable, the manufacturer/distributor) in a country and/or jurisdiction.
	// Note that â€œon the marketâ€ refers to the release of the item into the
	// distribution chain.
	DateRange *Period `json:"dateRange,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The jurisdiction in which the marketing status applies.
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The date when the item is due to be placed back on the market by the owner,
	// manufacturer or distributor, after a suspension.
	RestoreDate_2 *DateTime `json:"restoreDate,omitempty"`

	// This attribute provides information on the status of the marketing of the item.
	Status CodeableConcept `json:"status"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MarketingStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in MarketingStatus: required")
	}
	type Plain MarketingStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MarketingStatus(plain)
	return nil
}

// The Measure resource provides the definition of a quality measure.
type Measure struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for clinicalRecommendationStatement
	ClinicalRecommendationStatement *Element `json:"_clinicalRecommendationStatement,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for disclaimer
	Disclaimer *Element `json:"_disclaimer,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for guidance
	Guidance *Element `json:"_guidance,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for rateAggregation
	RateAggregation *Element `json:"_rateAggregation,omitempty"`

	// Extensions for rationale
	Rationale *Element `json:"_rationale,omitempty"`

	// Extensions for riskAdjustment
	RiskAdjustment *Element `json:"_riskAdjustment,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Provides a summary of relevant clinical guidelines or other clinical
	// recommendations supporting the measure.
	ClinicalRecommendationStatement_2 *Markdown `json:"clinicalRecommendationStatement,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MeasureContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the measure and/or its contents. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the measure.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the measure was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the measure changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the measure from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// Notices and disclaimers regarding the use of the measure or related to
	// intellectual property (such as code systems) referenced by the measure.
	Disclaimer_2 *Markdown `json:"disclaimer,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the measure content was or is planned to be in active
	// use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this measure is authored for testing purposes
	// (or education/evaluation/marketing) and no version of this resource will ever
	// be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A group of population criteria for the measure.
	Group []MeasureGroup `json:"group,omitempty"`

	// Additional guidance for the measure including how it can be used in a clinical
	// context, and the intent of the measure.
	Guidance_2 *Markdown `json:"guidance,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this measure when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// A reference to a Library resource containing the formal logic used by the
	// measure.
	Library []Canonical `json:"library,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the measure. This name should be usable as
	// an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the measure.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this measure is needed and why it has been designed as it
	// has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Describes how to combine the information calculated, based on logic in each of
	// several populations, into one summarized result.
	RateAggregation_2 *Markdown `json:"rateAggregation,omitempty"`

	// Provides a detailed justification of the need for the measure including
	// statements pertaining to importance criterion: impact, gap in care, and
	// evidence.
	Rationale_2 *Markdown `json:"rationale,omitempty"`

	// Related artifacts such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// The frequency that this measure should be reported, usually specified by the
	// program it is being submitted to.
	ReportingFrequency *Quantity `json:"reportingFrequency,omitempty"`

	// This is a Measure resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// A description of the risk adjustment factors that may impact the resulting
	// score for the measure and how they may be accounted for when computing and
	// reporting measure results.
	RiskAdjustment_2 *Markdown `json:"riskAdjustment,omitempty"`

	// The status of this measure. Enables tracking the life-cycle of the content.
	Status_2 *Code `json:"status,omitempty"`

	// The intended subjects for the measure. If this element is not provided, a
	// Patient subject is assumed, but the subject of the measure can be anything.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// The intended subjects for the measure. If this element is not provided, a
	// Patient subject is assumed, but the subject of the measure can be anything.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// An explanatory or alternate title for the measure giving additional information
	// about its content.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// The supplemental data criteria for the measure report, specified as either the
	// name of a valid CQL expression within a referenced library, or a valid FHIR
	// Resource Path.
	SupplementalData []MeasureSupplementalData `json:"supplementalData,omitempty"`

	// Provides a description of an individual term used within the measure.
	Term []MeasureTerm `json:"term,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the measure.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the measure. Topics provide a
	// high-level categorization grouping types of measures that can be useful for
	// filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this measure when it is referenced in
	// a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this measure is (or will be) published. This
	// URL can be the target of a canonical reference. It SHALL remain the same when
	// the measure is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description, from a clinical perspective, of how the measure is
	// used.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate measure
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the measure when it is
	// referenced in a specification, model, design or instance. This is an arbitrary
	// value managed by the measure author and is not expected to be globally unique.
	// For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
	// not available. There is also no expectation that versions can be placed in a
	// lexicographical sequence. To provide a version consistent with the Decision
	// Support Service specification, use the format Major.Minor.Revision (e.g.
	// 1.0.0). For more information on versioning knowledge assets, refer to the
	// Decision Support Service specification. Note that a version is required for
	// non-experimental active artifacts.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// The Measure resource provides the definition of a quality measure.
type MeasureComponent struct {
	// Extensions for groupId
	GroupID *Element `json:"_groupId,omitempty"`

	// Extensions for measure
	Measure *Element `json:"_measure,omitempty"`

	// Extensions for weight
	Weight *Element `json:"_weight,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Specifies the id of a particular group within the measure referenced by the
	// related artifact resource.
	GroupID_2 *String `json:"groupId,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The measure that contains the definition of the component calculation.
	Measure_2 *Canonical `json:"measure,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// What is the weight of the contribution of this measure to the overall score.
	Weight_2 *Decimal `json:"weight,omitempty"`
}

// The Measure resource provides the definition of a quality measure.
type MeasureComponent1 struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Indicates a meaning for the stratifier component. This can be as simple as a
	// unique identifier, or it can establish meaning in a broader context by drawing
	// from a terminology, allowing stratifiers to be correlated across measures.
	Code *CodeableConcept `json:"code,omitempty"`

	// An expression that returns the value of this component of the stratifier for a
	// member of the population. This is typically the name of an expression defined
	// within a referenced library, but it may also be a path to a stratifier element,
	// evaluated from the perspective of the measure subject. If this is a
	// non-subject-based measure, the expression may be a reference to a function that
	// takes an argument of the type of the measure basis, allowing the stratifier
	// value to be determined for each member of the population.
	Criteria *Expression `json:"criteria,omitempty"`

	// The human readable description of this stratifier criteria component.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A Group resource that defines this population as a set of characteristics.
	GroupDefinition *Reference `json:"groupDefinition,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier that is unique within the Measure allowing linkage to the
	// equivalent item in a MeasureReport resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates what units, if any, stratifier values are expected to be expressed
	// in. This element SHOULD be specified in UCUM units or calendar units.
	Unit_2 *String `json:"unit,omitempty"`

	// A value set defining the set of possible values for stratum in this stratifier.
	// If criteria and valueSet are both present, they SHALL be consistent (i.e.
	// criteria expressions SHALL produce stratum values that are codes in the value
	// set referenced by this element). Note that this MAY be strictly at the code
	// level (e.g. an Age Range code that is just the string value `01Y--05Y` with the
	// system ignored).
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

type MeasureContainedElem interface{}

// The Measure resource provides the definition of a quality measure.
type MeasureGroup struct {
	// Extensions for basis
	Basis *Element `json:"_basis,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for improvementNotationGuidance
	ImprovementNotationGuidance *Element `json:"_improvementNotationGuidance,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for rateAggregation
	RateAggregation *Element `json:"_rateAggregation,omitempty"`

	// Extensions for scoringPrecision
	ScoringPrecision *Element `json:"_scoringPrecision,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// The population basis specifies the type of elements in the population. For a
	// subject-based measure, this is boolean (because the subject and the population
	// basis are the same, and the population criteria define yes/no values for each
	// individual in the population). For measures that have a population basis that
	// is different than the subject, this element specifies the type of the
	// population basis. For example, an encounter-based measure has a subject of
	// Patient and a population basis of Encounter, and the population criteria all
	// return lists of Encounters.
	Basis_2 *Code `json:"basis,omitempty"`

	// Specifies population basis requirements (i.e. what constitutes a case, or what
	// is being counted) as a DataRequirement. If multiple basisRequirements are
	// specified, criteria expressions may return data that satisfies ANY
	// basisRequirement. A data element satisfies a basisRequirement if the instance
	// `is` of the type, conforms to ALL the specified profiles, and matches ALL the
	// codeFilters. basisRequirements SHALL specify type, MAY specify profile and
	// codeFilter, and SHALL NOT specify dateFilter, valueFilter, limit, or sort. If
	// basis is specified, any basisRequirement SHALL be consistent with the specified
	// basis (i.e. the type of each basisRequirement SHALL be the same type as, or a
	// subtype of the basis type).
	BasisRequirement []DataRequirement `json:"basisRequirement,omitempty"`

	// Indicates a meaning for the group. This can be as simple as a unique
	// identifier, or it can establish meaning in a broader context by drawing from a
	// terminology, allowing groups to be correlated across measures.
	Code *CodeableConcept `json:"code,omitempty"`

	// If this is a composite measure, a component of the composite.
	Component []MeasureComponent `json:"component,omitempty"`

	// If this is a composite measure, the scoring method used to combine the
	// component measures to determine the composite score.
	CompositeScoring *CodeableConcept `json:"compositeScoring,omitempty"`

	// The human readable description of this population group.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Information on whether an increase or decrease in score is the preferred result
	// (e.g., a higher score indicates better quality OR a lower score indicates
	// better quality OR quality is within a range). Exercise caution when using any
	// values besides increase or decrease for improvementNotation.
	ImprovementNotation *CodeableConcept `json:"improvementNotation,omitempty"`

	// Narrative text to explain the improvement notation and how to interpret it.
	ImprovementNotationGuidance_2 *Markdown `json:"improvementNotationGuidance,omitempty"`

	// A reference to a Library resource containing the formal logic used by the
	// measure group.
	Library []Canonical `json:"library,omitempty"`

	// An identifier that is unique within the Measure allowing linkage to the
	// equivalent item in a MeasureReport resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A population criteria for the measure.
	Population []MeasurePopulation `json:"population,omitempty"`

	// Describes how to combine the information calculated, based on logic in each of
	// several populations, into one summarized result.
	RateAggregation_2 *Markdown `json:"rateAggregation,omitempty"`

	// Indicates how the calculation is performed for the measure, including
	// proportion, ratio, continuous-variable, and cohort. The value set is
	// extensible, allowing additional measure scoring types to be represented.
	Scoring *CodeableConcept `json:"scoring,omitempty"`

	// When the score is a decimal value this should be used to specify the expected
	// minimum number of digits after the decimal point to use for the precision of
	// the value. When a scoringUnit is also specified, this value is the expected
	// minimum number of digits after the decimal point when the score is expressed in
	// the units specified.
	ScoringPrecision_2 *PositiveInt `json:"scoringPrecision,omitempty"`

	// Defines the expected units of measure for the measure score. This element
	// SHOULD be specified as a UCUM unit.
	ScoringUnit *CodeableConcept `json:"scoringUnit,omitempty"`

	// A stratifier for the measure, specified as either a criteria expression, or a
	// set of components that define value-based stratifier expressions.
	Stratifier []MeasureStratifier `json:"stratifier,omitempty"`

	// The intended subjects for the measure. If this element is not provided, there
	// is no subject context (i.e. population criteria are evaluated from the
	// perspective of the entire system, rather than from the perspective of a
	// particular subject).
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// The intended subjects for the measure. If this element is not provided, there
	// is no subject context (i.e. population criteria are evaluated from the
	// perspective of the entire system, rather than from the perspective of a
	// particular subject).
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// Indicates the title for the group.
	Title_2 *String `json:"title,omitempty"`

	// Indicates whether the measure is used to examine a process, an outcome over
	// time, a patient-reported outcome, or a structure measure such as utilization.
	Type []CodeableConcept `json:"type,omitempty"`
}

// The Measure resource provides the definition of a quality measure.
type MeasurePopulation struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for inputPopulationId
	InputPopulationID *Element `json:"_inputPopulationId,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Specifies which method should be used to aggregate measure observation values.
	// For most scoring types, this is implied by scoring (e.g. a proportion measure
	// counts members of the populations). For continuous variables, however, this
	// information must be specified to ensure correct calculation.
	AggregateMethod *CodeableConcept `json:"aggregateMethod,omitempty"`

	// The type of population criteria.
	Code *CodeableConcept `json:"code,omitempty"`

	// An expression that specifies the criteria for the population, typically the
	// name of an expression in a library.
	Criteria *Expression `json:"criteria,omitempty"`

	// The human readable description of this population criteria.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A Group resource that defines this population as a set of characteristics.
	GroupDefinition *Reference `json:"groupDefinition,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The id of a population element in this measure that provides the input for this
	// population criteria. In most cases, the scoring structure of the measure
	// implies specific relationships (e.g. the Numerator uses the Denominator as the
	// source in a proportion scoring). In some cases, however, multiple possible
	// choices exist and must be resolved explicitly. For example in a ratio measure
	// with multiple initial populations, the denominator must specify which
	// population should be used as the starting point.
	InputPopulationID_2 *String `json:"inputPopulationId,omitempty"`

	// An identifier that is unique within the Measure allowing linkage to the
	// equivalent population in a MeasureReport resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the title for the group's population.
	Title_2 *String `json:"title,omitempty"`
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReport struct {
	// Extensions for dataUpdateType
	DataUpdateType *Element `json:"_dataUpdateType,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// The category of measure report instance this is such as Data Exchange for
	// Quality Measures (DEQM), Risk Adjustment, or Value-Based Performance.
	Category *CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MeasureReportContainedElem `json:"contained,omitempty"`

	// Indicates whether the data submitted in a data-exchange report represents a
	// snapshot or incremental update. A snapshot update replaces all previously
	// submitted data for the receiver, whereas an incremental update represents only
	// updated and/or changed data and should be applied as a differential update to
	// the existing submitted data for the receiver.
	DataUpdateType_2 *Code `json:"dataUpdateType,omitempty"`

	// The date this measure report was generated.
	Date_2 *DateTime `json:"date,omitempty"`

	// Evaluated resources are used to capture what data was involved in the
	// calculation of a measure. This usage is only allowed for individual reports to
	// ensure that the size of the MeasureReport resource is bounded.
	EvaluatedResource []Reference `json:"evaluatedResource,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The results of the calculation, one for each population group in the measure. A
	// MeasureReport SHALL have a group element corresponding to each group element
	// defined in the Measure being reported.
	Group []MeasureReportGroup `json:"group,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this MeasureReport when it is
	// represented in other formats or referenced in a specification, model, design or
	// an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A reference to a Parameters resource (typically represented using a contained
	// resource) that represents any input parameters that were provided to the
	// operation that generated the report. If the input parameter includes
	// stratifiers, then the MeasureReport SHALL include the input parameters.
	InputParameters *Reference `json:"inputParameters,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// A reference to the location for which the data is being reported.
	Location []Reference `json:"location,omitempty"`

	// A reference to the Measure that was calculated to produce this report.
	Measure *Canonical `json:"measure,omitempty"`

	// A reference to an OperationOutcome that contains any information, warning,
	// and/or error messages that were generated while processing an operation such as
	// $evaluate.
	Messages *Reference `json:"messages,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The reporting period for which the report was calculated.
	Period Period `json:"period"`

	// The individual or organization that is reporting the data.
	Reporter *Reference `json:"reporter,omitempty"`

	// A reference to the vendor who queried the data, calculated results and/or
	// generated the report. The â€˜reporting vendorâ€™ is intended to represent the
	// submitting entity when it is not the same as the reporting entity. This
	// extension is used when the Receiver is interested in getting vendor information
	// in the report.
	ReportingVendor *Reference `json:"reportingVendor,omitempty"`

	// This is a MeasureReport resource
	ResourceType interface{} `json:"resourceType"`

	// The MeasureReport status. No data will be available until the MeasureReport
	// status is complete.
	Status_2 *Code `json:"status,omitempty"`

	// Optional subject identifying the individual or individuals the report is for.
	Subject *Reference `json:"subject,omitempty"`

	// A reference to a Resource that represents additional information collected for
	// the report. If the value of the supplemental data is not a Resource (i.e.
	// evaluating the supplementalData expression for this case in the measure results
	// in a value that is not a FHIR Resource), it is reported as a reference to a
	// contained Observation resource.
	SupplementalData []Reference `json:"supplementalData,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The type of measure report. This may be an individual report, which provides
	// the score for the measure for an individual member of the population; a
	// subject-listing, which returns the list of members that meet the various
	// criteria in the measure; a summary report, which returns a population count for
	// each of the criteria in the measure; or a data-collection, which enables the
	// MeasureReport to be used to exchange the data-of-interest for a quality
	// measure.
	Type_2 *Code `json:"type,omitempty"`
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportComponent struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// The code for the stratum component value. This element SHALL be populated with
	// at least the codings in the code element of the corresponding component of the
	// stratifier being reported.
	Code CodeableConcept `json:"code"`

	// The human readable description of this stratifier criteria component. This
	// element MAY be populated with the description of the corresponding component of
	// the stratifier being reported.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The stratifier component from the Measure that corresponds to this stratifier
	// component in the MeasureReport resource. This element SHALL be populated based
	// on the corresponding element in the Measure being reported.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The stratum component value.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The stratum component value.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The stratum component value.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The stratum component value.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The stratum component value.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasureReportComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in MeasureReportComponent: required")
	}
	type Plain MeasureReportComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MeasureReportComponent(plain)
	return nil
}

type MeasureReportContainedElem interface{}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportGroup struct {
	// Extensions for calculatedDate
	CalculatedDate *Element `json:"_calculatedDate,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for improvementNotationGuidance
	ImprovementNotationGuidance *Element `json:"_improvementNotationGuidance,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for measureScoreBoolean
	MeasureScoreBoolean *Element `json:"_measureScoreBoolean,omitempty"`

	// Extensions for measureScoreDateTime
	MeasureScoreDateTime *Element `json:"_measureScoreDateTime,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// The date the Measure Report was calculated.
	CalculatedDate_2 *DateTime `json:"calculatedDate,omitempty"`

	// The meaning of the population group as defined in the measure definition. This
	// element SHALL be populated with at least the codings in the code of the
	// corresponding group in the Measure being reported.
	Code *CodeableConcept `json:"code,omitempty"`

	// The human readable description of this population group. This element SHOULD be
	// populated based on the description of the corresponding group in the Measure
	// being reported.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Whether improvement in the measure is noted by an increase or decrease in the
	// measure score. Exercise caution when using any values besides increase or
	// decrease for improvementNotation.
	ImprovementNotation *CodeableConcept `json:"improvementNotation,omitempty"`

	// Narrative text to explain the improvement notation and how to interpret it.
	ImprovementNotationGuidance_2 *Markdown `json:"improvementNotationGuidance,omitempty"`

	// The group from the Measure that corresponds to this group in the MeasureReport
	// resource. This element SHALL be populated based on the corresponding element in
	// the Measure being reported.
	LinkID_2 *String `json:"linkId,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreBoolean_2 *bool `json:"measureScoreBoolean,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreCodeableConcept *CodeableConcept `json:"measureScoreCodeableConcept,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreDateTime_2 *string `json:"measureScoreDateTime,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreDuration *Duration `json:"measureScoreDuration,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScorePeriod *Period `json:"measureScorePeriod,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreQuantity *Quantity `json:"measureScoreQuantity,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreRange *Range `json:"measureScoreRange,omitempty"`

	// The measure score for this population group, calculated as appropriate for the
	// measure type and scoring method, and based on the contents of the populations
	// defined in the group.
	MeasureScoreRatio *Ratio `json:"measureScoreRatio,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The populations that make up the population group, one for each type of
	// population appropriate for the measure. Each group in the MeasureReport SHALL
	// have populations as defined in the corresponding group of the Measure being
	// reported.
	Population []MeasureReportPopulation `json:"population,omitempty"`

	// Indicates how the calculation is performed for the measure, including
	// proportion, ratio, continuous-variable, and cohort. The value set is
	// extensible, allowing additional measure scoring types to be represented. It is
	// expected to be the same as the scoring element on the referenced Measure.
	Scoring *CodeableConcept `json:"scoring,omitempty"`

	// The stratification results for this measure group, calculated as defined by the
	// stratifier element of the measure being reported. Each group in the
	// MeasureReport SHALL have stratifiers as defined in the corresponding group of
	// the Measure being reported.
	Stratifier []MeasureReportStratifier `json:"stratifier,omitempty"`

	// Optional subject identifying the individual or individuals the report is for.
	Subject *Reference `json:"subject,omitempty"`

	// Indicates the title for of the group.
	Title_2 *String `json:"title,omitempty"`

	// Indicates whether the measure is used to examine a process, an outcome over
	// time, a patient-reported outcome, or a structure measure such as utilization.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasureReportGroup) UnmarshalJSON(value []byte) error {
	type Plain MeasureReportGroup
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MeasureScoreDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.MeasureScoreDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MeasureScoreDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = MeasureReportGroup(plain)
	return nil
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportPopulation struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// The type of the population. This element SHALL be populated with at least the
	// codings in the code element of the corresponding population in the Measure
	// group being reported.
	Code *CodeableConcept `json:"code,omitempty"`

	// The number of members of the population.
	Count_2 *Integer `json:"count,omitempty"`

	// The number of members of the population, specified as a quantity to support
	// identifying units, as well as to support some composite measure calculation use
	// cases where the resulting count of the population is a decimal value.
	CountQuantity *Quantity `json:"countQuantity,omitempty"`

	// The human readable description of this population criteria. This element SHOULD
	// be populated based on the description element of the corresponding population
	// in the Measure group being reported.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The population from the Measure that corresponds to this population in the
	// MeasureReport resource. This element SHALL be populated based on the
	// corresponding element in the Measure being reported.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to an individual level MeasureReport resource for a member of the
	// population.
	SubjectReport []Reference `json:"subjectReport,omitempty"`

	// This element refers to a List of individual level MeasureReport resources, one
	// for each subject in this population.
	SubjectResults *Reference `json:"subjectResults,omitempty"`

	// Optional Group identifying the individuals that make up the population.
	Subjects *Reference `json:"subjects,omitempty"`

	// Indicates the title for of the group's population.
	Title_2 *String `json:"title,omitempty"`
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportPopulation1 struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// The type of the population. This element SHALL be populated with at least the
	// codings in the code element of the corresponding population being reported.
	Code *CodeableConcept `json:"code,omitempty"`

	// The number of members of the population in this stratum.
	Count_2 *Integer `json:"count,omitempty"`

	// The number of members of the population in this stratum, specified as a
	// quantity to support identifying units, as well as to support some composite
	// measure calculation use cases where the resulting count of the population is a
	// decimal value.
	CountQuantity *Quantity `json:"countQuantity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The population from the Measure that corresponds to this population in the
	// MeasureReport resource. This element SHALL be populated with the linkId
	// corresponding to the population being reported.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A reference to an individual level MeasureReport resource for a member of the
	// population.
	SubjectReport []Reference `json:"subjectReport,omitempty"`

	// This element refers to a List of individual level MeasureReport resources, one
	// for each subject in this population in this stratum.
	SubjectResults *Reference `json:"subjectResults,omitempty"`

	// Optional Group identifying the individuals that make up the population.
	Subjects *Reference `json:"subjects,omitempty"`
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportStratifier struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// The meaning of this stratifier, as defined in the measure definition. This
	// element SHALL be populated with at least the codings in the code element of the
	// corresponding stratifier in the Measure group being reported.
	Code *CodeableConcept `json:"code,omitempty"`

	// The human readable description of this stratifier criteria. This element SHOULD
	// be populated with the description element of the corresponding stratifier in
	// the Measure group being reported.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The stratifier from the Measure that corresponds to this stratifier in the
	// MeasureReport resource. This element SHALL be populated based on the
	// corresponding element in the Measure being reported.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This element contains the results for a single stratum within the stratifier.
	// For example, when stratifying on administrative gender, there will be four
	// strata, one for each possible gender value.
	Stratum []MeasureReportStratum `json:"stratum,omitempty"`

	// Indicates the title for of the group's stratifier.
	Title_2 *String `json:"title,omitempty"`
}

// The MeasureReport resource contains the results of the calculation of a measure;
// and optionally a reference to the resources involved in that calculation.
type MeasureReportStratum struct {
	// Extensions for measureScoreBoolean
	MeasureScoreBoolean *Element `json:"_measureScoreBoolean,omitempty"`

	// Extensions for measureScoreDateTime
	MeasureScoreDateTime *Element `json:"_measureScoreDateTime,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// A stratifier component value.
	Component []MeasureReportComponent `json:"component,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreBoolean_2 *bool `json:"measureScoreBoolean,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreCodeableConcept *CodeableConcept `json:"measureScoreCodeableConcept,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreDateTime_2 *string `json:"measureScoreDateTime,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreDuration *Duration `json:"measureScoreDuration,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScorePeriod *Period `json:"measureScorePeriod,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreQuantity *Quantity `json:"measureScoreQuantity,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreRange *Range `json:"measureScoreRange,omitempty"`

	// The measure score for this stratum, calculated as appropriate for the measure
	// type and scoring method, and based on only the members of this stratum.
	MeasureScoreRatio *Ratio `json:"measureScoreRatio,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The populations that make up the stratum, one for each type of population
	// appropriate to the measure. For each stratifier, systems MAY provide population
	// breakdowns in addition to the stratified scores.
	Population []MeasureReportPopulation1 `json:"population,omitempty"`

	// The value for this stratum, expressed as a CodeableConcept. When defining
	// stratifiers on complex values, the value must be rendered such that the value
	// for each stratum within the stratifier is unique.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value for this stratum, expressed as a CodeableConcept. When defining
	// stratifiers on complex values, the value must be rendered such that the value
	// for each stratum within the stratifier is unique.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value for this stratum, expressed as a CodeableConcept. When defining
	// stratifiers on complex values, the value must be rendered such that the value
	// for each stratum within the stratifier is unique.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value for this stratum, expressed as a CodeableConcept. When defining
	// stratifiers on complex values, the value must be rendered such that the value
	// for each stratum within the stratifier is unique.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value for this stratum, expressed as a CodeableConcept. When defining
	// stratifiers on complex values, the value must be rendered such that the value
	// for each stratum within the stratifier is unique.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasureReportStratum) UnmarshalJSON(value []byte) error {
	type Plain MeasureReportStratum
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MeasureScoreDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.MeasureScoreDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MeasureScoreDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = MeasureReportStratum(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasureReport) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["period"]; raw != nil && !ok {
		return fmt.Errorf("field period in MeasureReport: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MeasureReport: required")
	}
	type Plain MeasureReport
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MeasureReport(plain)
	return nil
}

// The Measure resource provides the definition of a quality measure.
type MeasureStratifier struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Indicates a meaning for the stratifier. This can be as simple as a unique
	// identifier, or it can establish meaning in a broader context by drawing from a
	// terminology, allowing stratifiers to be correlated across measures.
	Code *CodeableConcept `json:"code,omitempty"`

	// A component of a value-based stratifier for the measure report, specified as
	// either the name of a valid CQL expression defined within a referenced library
	// or a valid FHIR Resource Path.
	Component []MeasureComponent1 `json:"component,omitempty"`

	// An expression that specifies a criteria-based stratifier for the measure. This
	// is typically the name of an expression defined within a referenced library, and
	// SHALL use the same basis as other population criteria for the population group.
	Criteria *Expression `json:"criteria,omitempty"`

	// The human readable description of this stratifier criteria.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A Group resource that defines this population as a set of characteristics.
	GroupDefinition *Reference `json:"groupDefinition,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier that is unique within the Measure allowing linkage to the
	// equivalent item in a MeasureReport resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the title for the stratifier of the group.
	Title_2 *String `json:"title,omitempty"`
}

// The Measure resource provides the definition of a quality measure.
type MeasureSupplementalData struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Indicates a meaning for the supplemental data. This can be as simple as a
	// unique identifier, or it can establish meaning in a broader context by drawing
	// from a terminology, allowing supplemental data to be correlated across
	// measures.
	Code *CodeableConcept `json:"code,omitempty"`

	// The criteria for the supplemental data. This is typically the name of a valid
	// expression defined within a referenced library, but it may also be a path to a
	// specific data element. The criteria defines the data to be returned for this
	// element.
	Criteria Expression `json:"criteria"`

	// The human readable description of this supplemental data.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier that is unique within the Measure allowing linkage to the
	// equivalent item in a MeasureReport resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates what units, if any, supplemental data values are expected to be
	// expressed in. This element SHOULD be specified in UCUM units or calendar units.
	Unit_2 *String `json:"unit,omitempty"`

	// An indicator of the intended usage for the supplemental data element.
	// Supplemental data indicates the data is additional information requested to
	// augment the measure information. Risk adjustment factor indicates the data is
	// additional information used to calculate risk adjustment factors when applying
	// a risk model to the measure calculation.
	Usage []CodeableConcept `json:"usage,omitempty"`

	// A value set defining the set of possible values for supplemental data in this
	// element. If criteria and valueSet are both present, they SHALL be consistent
	// (i.e. criteria expressions SHALL produce supplemental data values that are
	// codes in the value set referenced by this element). Note that this MAY be
	// strictly at the code level (e.g. an Age Range code that is just the string
	// value `01Y--05Y` with the system ignored).
	ValueSet *Canonical `json:"valueSet,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasureSupplementalData) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["criteria"]; raw != nil && !ok {
		return fmt.Errorf("field criteria in MeasureSupplementalData: required")
	}
	type Plain MeasureSupplementalData
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MeasureSupplementalData(plain)
	return nil
}

// The Measure resource provides the definition of a quality measure.
type MeasureTerm struct {
	// Extensions for definition
	Definition *Element `json:"_definition,omitempty"`

	// A codeable representation of the defined term.
	Code *CodeableConcept `json:"code,omitempty"`

	// Provides a definition for the term as used within the measure.
	Definition_2 *Markdown `json:"definition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Measure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Measure: required")
	}
	type Plain Measure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Measure(plain)
	return nil
}

// This resource is primarily used for the identification and definition of a
// medication, including ingredients, for the purposes of prescribing, dispensing,
// and administering a medication as well as for making statements about medication
// use.
type Medication struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A code (or set of codes) that specify this medication, or a textual
	// description. Usage note: This could be a standard medication code such as a
	// code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local
	// formulary code, optionally with translations to other code systems. The name of
	// the medication can be conveyed in the code.text even if it is different from
	// any of the coding displayName values.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicationContainedElem `json:"contained,omitempty"`

	// A reference to a definitional resource that provides more information about
	// this medication.
	Definition *Reference `json:"definition,omitempty"`

	// Describes the form of the item.  Powder; tablets; capsule.
	DoseForm *CodeableConcept `json:"doseForm,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifier for this medication.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Identifies a particular constituent of interest in the product.
	Ingredient []MedicationIngredient `json:"ingredient,omitempty"`

	// Information that only applies to packages (not products).
	Instance *MedicationInstance `json:"instance,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The company or other legal entity that has authorization, from the appropriate
	// drug regulatory authority,  to market a medicine in one or more jurisdictions.
	// Typically abbreviated MAH.Note:  The MAH may manufacture the product and may
	// also contract the manufacturing of the product to one or more companies
	// (organizations).
	MarketingAuthorizationHolder *Reference `json:"marketingAuthorizationHolder,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// When the code does not specify the package size, this backbone element can be
	// used to specify the overall amount of medication in the package.
	PackageSize *MedicationPackageSize `json:"packageSize,omitempty"`

	// This is a Medication resource
	ResourceType interface{} `json:"resourceType"`

	// A code to indicate if the medication is in active use.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Describes the event of a patient consuming or otherwise being administered a
// medication.  This may be as simple as swallowing a tablet or it may be a long
// running infusion.  Related resources tie this event to the authorizing
// prescription, and the specific encounter between patient and health care
// practitioner.
type MedicationAdministration struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for isSubPotent
	IsSubPotent *Element `json:"_isSubPotent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A plan that is fulfilled in whole or in part by this MedicationAdministration.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// The type of medication administration.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicationAdministrationContainedElem `json:"contained,omitempty"`

	// The device that is to be used for the administration of the medication (for
	// example, PCA Pump).
	Device []CodeableReference `json:"device,omitempty"`

	// Describes the medication dosage information details e.g. dose, rate, site,
	// route, etc.
	Dosage *MedicationAdministrationDosage `json:"dosage,omitempty"`

	// The visit, admission, or other contact between patient and health care provider
	// during which the medication administration was performed.
	Encounter *Reference `json:"encounter,omitempty"`

	// A summary of the events of interest that have occurred, such as when the
	// administration was verified.
	EventHistory []Reference `json:"eventHistory,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers associated with this Medication Administration that are defined by
	// business processes and/or used to refer to it when a direct URL reference to
	// the resource itself is not appropriate. They are business identifiers assigned
	// to this resource by the performer or other systems and remain constant as the
	// resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// An indication that the full dose was not administered.
	IsSubPotent_2 *Boolean `json:"isSubPotent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Identifies the medication that was administered. This is either a link to a
	// resource representing the details of the medication or a simple attribute
	// carrying a code that identifies the medication from a known list of
	// medications.
	Medication CodeableReference `json:"medication"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Extra information about the medication administration that is not conveyed by
	// the other attributes.
	Note []Annotation `json:"note,omitempty"`

	// A specific date/time or interval of time during which the administration took
	// place (or did not take place). For many administrations, such as swallowing a
	// tablet the use of dateTime is more appropriate.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// A specific date/time or interval of time during which the administration took
	// place (or did not take place). For many administrations, such as swallowing a
	// tablet the use of dateTime is more appropriate.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// A specific date/time or interval of time during which the administration took
	// place (or did not take place). For many administrations, such as swallowing a
	// tablet the use of dateTime is more appropriate.
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`

	// A larger event of which this particular event is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// The performer of the medication treatment.  For devices this is the device that
	// performed the administration of the medication.  An IV Pump would be an example
	// of a device that is performing the administration. Both the IV Pump and the
	// practitioner that set the rate or bolus on the pump can be listed as
	// performers.
	Performer []MedicationAdministrationPerformer `json:"performer,omitempty"`

	// A code, Condition or observation that supports why the medication was
	// administered.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The date the occurrence of the  MedicationAdministration was first captured in
	// the record - potentially significantly after the occurrence of the event.
	Recorded_2 *DateTime `json:"recorded,omitempty"`

	// The original request, instruction or authority to perform the administration.
	Request *Reference `json:"request,omitempty"`

	// This is a MedicationAdministration resource
	ResourceType interface{} `json:"resourceType"`

	// Will generally be set to show that the administration has been completed.  For
	// some long running administrations such as infusions, it is possible for an
	// administration to be started but not completed or it may be paused while some
	// other process is under way.
	Status_2 *Code `json:"status,omitempty"`

	// A code indicating why the status of the administration changed.
	StatusReason []CodeableConcept `json:"statusReason,omitempty"`

	// The reason or reasons why the full dose was not administered.
	SubPotentReason []CodeableConcept `json:"subPotentReason,omitempty"`

	// The person or animal or group receiving the medication.
	Subject Reference `json:"subject"`

	// Additional information (for example, patient height and weight) that supports
	// the administration of the medication.  This attribute can be used to provide
	// documentation of specific characteristics of the patient present at the time of
	// administration.  For example, if the dose says "give "x" if the heartrate
	// exceeds "y"", then the heart rate can be included using this attribute.
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type MedicationAdministrationContainedElem interface{}

// Describes the event of a patient consuming or otherwise being administered a
// medication.  This may be as simple as swallowing a tablet or it may be a long
// running infusion.  Related resources tie this event to the authorizing
// prescription, and the specific encounter between patient and health care
// practitioner.
type MedicationAdministrationDosage struct {
	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// The amount of the medication given at one administration event.   Use this
	// value when the administration is essentially an instantaneous event such as a
	// swallowing a tablet or giving an injection.
	Dose *Quantity `json:"dose,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A coded value indicating the method by which the medication is intended to be
	// or was introduced into or on the body.  This attribute will most often NOT be
	// populated.  It is most commonly used for injections.  For example, Slow Push,
	// Deep IV.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies the speed with which the medication was or will be introduced into
	// the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100
	// ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2
	// hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
	RateQuantity *Quantity `json:"rateQuantity,omitempty"`

	// Identifies the speed with which the medication was or will be introduced into
	// the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100
	// ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2
	// hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
	RateRatio *Ratio `json:"rateRatio,omitempty"`

	// A code specifying the route or physiological path of administration of a
	// therapeutic agent into or onto the patient.  For example, topical, intravenous,
	// etc.
	Route *CodeableConcept `json:"route,omitempty"`

	// A coded specification of the anatomic site where the medication first entered
	// the body.  For example, "left arm".
	Site *CodeableConcept `json:"site,omitempty"`

	// Free text dosage can be used for cases where the dosage administered is too
	// complex to code. When coded dosage is present, the free text dosage may still
	// be present for display to humans.The dosage instructions should reflect the
	// dosage of the medication that was administered.
	Text_2 *String `json:"text,omitempty"`
}

// Describes the event of a patient consuming or otherwise being administered a
// medication.  This may be as simple as swallowing a tablet or it may be a long
// running infusion.  Related resources tie this event to the authorizing
// prescription, and the specific encounter between patient and health care
// practitioner.
type MedicationAdministrationPerformer struct {
	// Indicates who or what performed the medication administration.
	Actor CodeableReference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of involvement of the performer in the medication
	// administration.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationAdministrationPerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in MedicationAdministrationPerformer: required")
	}
	type Plain MedicationAdministrationPerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationAdministrationPerformer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationAdministration) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["medication"]; raw != nil && !ok {
		return fmt.Errorf("field medication in MedicationAdministration: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MedicationAdministration: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in MedicationAdministration: required")
	}
	type Plain MedicationAdministration
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = MedicationAdministration(plain)
	return nil
}

type MedicationContainedElem interface{}

// Indicates that a medication product is to be or has been dispensed for a named
// person/patient.  This includes a description of the medication product (supply)
// provided and the instructions for administering the medication.  The medication
// dispense is the result of a pharmacy system responding to a medication order.
type MedicationDispense struct {
	// Extensions for fillNumber
	FillNumber *Element `json:"_fillNumber,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusChanged
	StatusChanged *Element `json:"_statusChanged,omitempty"`

	// Extensions for whenHandedOver
	WhenHandedOver *Element `json:"_whenHandedOver,omitempty"`

	// Extensions for whenPrepared
	WhenPrepared *Element `json:"_whenPrepared,omitempty"`

	// Indicates the medication order that is being dispensed against.
	AuthorizingPrescription []Reference `json:"authorizingPrescription,omitempty"`

	// A plan that is fulfilled in whole or in part by this MedicationDispense.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Indicates the type of medication dispense (for example, drug classification
	// like ATC, where meds would be administered, legal category of the medication.).
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicationDispenseContainedElem `json:"contained,omitempty"`

	// The amount of medication expressed as a timing amount.
	DaysSupply *Quantity `json:"daysSupply,omitempty"`

	// Identification of the facility/location where the medication was/will be
	// shipped to, as part of the dispense event.
	Destination *Reference `json:"destination,omitempty"`

	// Indicates how the medication is to be used by the patient.
	DosageInstruction *DosageDetails `json:"dosageInstruction,omitempty"`

	// Provides information about the type of adherence packaging supplied for the
	// medication dispense.
	DoseAdministrationAid *CodeableConcept `json:"doseAdministrationAid,omitempty"`

	// The encounter that establishes the context for this event.
	Encounter *Reference `json:"encounter,omitempty"`

	// A summary of the events of interest that have occurred, such as when the
	// dispense was verified.
	EventHistory []Reference `json:"eventHistory,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Represents the known number of the fill over the entire lifetime of the
	// prescription, i.e. if this is the first dispense by this pharmacy but the third
	// fill overall, then the fillNumber will be 3.  Each fill number represents one
	// dispensation, even if that dispensation is not for the full quantity.  Partial
	// fills are not represented by decimal quantities, i.e., a partial fill of 40
	// tablets (full quantity is 100 tablets) adds 1 to the prior fill number, not
	// 0.4. This means that the 'fillNumber' may sometimes be higher than the
	// MedicationRequest.numberOfRepeatsAllowed, as the latter assumes full fills,
	// while fillNumber does not.
	FillNumber_2 *PositiveInt `json:"fillNumber,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers associated with this Medication Dispense that are defined by
	// business processes and/or used to refer to it when a direct URL reference to
	// the resource itself is not appropriate. They are business identifiers assigned
	// to this resource by the performer or other systems and remain constant as the
	// resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The principal physical location where the dispense was performed.
	Location *Reference `json:"location,omitempty"`

	// Identifies the medication supplied (or intended to be supplied). This is either
	// a link to a resource representing the details of the medication or a simple
	// attribute carrying a code that identifies the medication from a known list of
	// medications.
	Medication CodeableReference `json:"medication"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the reason why a dispense was not performed.
	NotPerformedReason *CodeableReference `json:"notPerformedReason,omitempty"`

	// Extra information about the dispense that could not be conveyed in the other
	// attributes.
	Note []Annotation `json:"note,omitempty"`

	// The procedure or medication administration that triggered the dispense.
	PartOf []Reference `json:"partOf,omitempty"`

	// Indicates who or what performed the event.
	Performer []MedicationDispensePerformer `json:"performer,omitempty"`

	// The amount of medication that has been (or was intended to be) dispensed.
	// Includes unit of measure.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Identifies the person who picked up the medication or the location or
	// organization where the medication was delivered. This will usually be a patient
	// or their caregiver, but some cases exist where it can be a healthcare
	// professional or a location, or organization.
	Receiver []Reference `json:"receiver,omitempty"`

	// The date the occurrence of the MedicationDispense was first captured in the
	// system.
	Recorded_2 *DateTime `json:"recorded,omitempty"`

	// This is a MedicationDispense resource
	ResourceType interface{} `json:"resourceType"`

	// A code specifying the state of the set of dispense events.
	Status_2 *Code `json:"status,omitempty"`

	// The date (and maybe time) when the status of the dispense record changed.
	StatusChanged_2 *DateTime `json:"statusChanged,omitempty"`

	// A link to a resource representing the person or the group to whom the
	// medication will be given.
	Subject Reference `json:"subject"`

	// Indicates whether or not substitution was made as part of the dispense.  In
	// some cases, substitution will be expected but does not happen, in other cases
	// substitution is not expected but does happen.  This block explains what
	// substitution did or did not happen and why.  If nothing is specified,
	// substitution was not done.
	Substitution *MedicationDispenseSubstitution `json:"substitution,omitempty"`

	// Additional information that supports the medication being dispensed.  For
	// example, there may be requirements that a specific lab test has been completed
	// prior to dispensing or the patient's weight at the time of dispensing is
	// documented.
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Indicates the type of dispensing event that is performed. For example, Trial
	// Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
	Type *CodeableConcept `json:"type,omitempty"`

	// The time the dispensed product was provided to the patient or their
	// representative.
	WhenHandedOver_2 *DateTime `json:"whenHandedOver,omitempty"`

	// The time when the dispensed product was packaged and reviewed.
	WhenPrepared_2 *DateTime `json:"whenPrepared,omitempty"`
}

type MedicationDispenseContainedElem interface{}

// Indicates that a medication product is to be or has been dispensed for a named
// person/patient.  This includes a description of the medication product (supply)
// provided and the instructions for administering the medication.  The medication
// dispense is the result of a pharmacy system responding to a medication order.
type MedicationDispensePerformer struct {
	// The device, practitioner, etc. who performed the action.  It should be assumed
	// that the actor is the dispenser of the medication.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of performer in the dispense.  For example, date
	// enterer, packager, final checker.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationDispensePerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in MedicationDispensePerformer: required")
	}
	type Plain MedicationDispensePerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationDispensePerformer(plain)
	return nil
}

// Indicates that a medication product is to be or has been dispensed for a named
// person/patient.  This includes a description of the medication product (supply)
// provided and the instructions for administering the medication.  The medication
// dispense is the result of a pharmacy system responding to a medication order.
type MedicationDispenseSubstitution struct {
	// Extensions for wasSubstituted
	WasSubstituted *Element `json:"_wasSubstituted,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the reason for the substitution (or lack of substitution) from what
	// was prescribed.
	Reason []CodeableConcept `json:"reason,omitempty"`

	// The person or organization that has primary responsibility for the
	// substitution.
	ResponsibleParty *Reference `json:"responsibleParty,omitempty"`

	// A code signifying whether a different drug was dispensed from what was
	// prescribed.
	Type *CodeableConcept `json:"type,omitempty"`

	// True if the dispenser dispensed a different drug or product from what was
	// prescribed.
	WasSubstituted_2 *Boolean `json:"wasSubstituted,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationDispense) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["medication"]; raw != nil && !ok {
		return fmt.Errorf("field medication in MedicationDispense: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MedicationDispense: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in MedicationDispense: required")
	}
	type Plain MedicationDispense
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationDispense(plain)
	return nil
}

// This resource is primarily used for the identification and definition of a
// medication, including ingredients, for the purposes of prescribing, dispensing,
// and administering a medication as well as for making statements about medication
// use.
type MedicationIngredient struct {
	// Extensions for isActive
	IsActive *Element `json:"_isActive,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Indication of whether this ingredient affects the therapeutic action of the
	// drug.
	IsActive_2 *Boolean `json:"isActive,omitempty"`

	// The ingredient (substance or medication) that the ingredient.strength relates
	// to.  This is represented as a concept from a code system or described in
	// another resource (Substance or Medication).
	Item CodeableReference `json:"item"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indication of whether this ingredient affects the therapeutic action of the
	// drug.
	Role *CodeableConcept `json:"role,omitempty"`

	// Specifies how many (or how much) of the items there are in this Medication.
	// For example, 250 mg per tablet.  This is expressed as a ratio where the
	// numerator is 250mg and the denominator is 1 tablet but can also be expressed a
	// quantity when the denominator is assumed to be 1 tablet.
	StrengthCodeableConcept *CodeableConcept `json:"strengthCodeableConcept,omitempty"`

	// Specifies how many (or how much) of the items there are in this Medication.
	// For example, 250 mg per tablet.  This is expressed as a ratio where the
	// numerator is 250mg and the denominator is 1 tablet but can also be expressed a
	// quantity when the denominator is assumed to be 1 tablet.
	StrengthQuantity *Quantity `json:"strengthQuantity,omitempty"`

	// Specifies how many (or how much) of the items there are in this Medication.
	// For example, 250 mg per tablet.  This is expressed as a ratio where the
	// numerator is 250mg and the denominator is 1 tablet but can also be expressed a
	// quantity when the denominator is assumed to be 1 tablet.
	StrengthRatio *Ratio `json:"strengthRatio,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationIngredient) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in MedicationIngredient: required")
	}
	type Plain MedicationIngredient
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationIngredient(plain)
	return nil
}

// This resource is primarily used for the identification and definition of a
// medication, including ingredients, for the purposes of prescribing, dispensing,
// and administering a medication as well as for making statements about medication
// use.
type MedicationInstance struct {
	// Extensions for expirationDate
	ExpirationDate *Element `json:"_expirationDate,omitempty"`

	// Extensions for lotNumber
	LotNumber *Element `json:"_lotNumber,omitempty"`

	// When this specific instance of product will expire.
	ExpirationDate_2 *DateTime `json:"expirationDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifier for the physical instance, typically a serial number.
	Identifier []Identifier `json:"identifier,omitempty"`

	// The assigned lot number of a batch of the specified product.
	LotNumber_2 *String `json:"lotNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// This resource is primarily used for the identification and definition of a
// medication, including ingredients, for the purposes of prescribing, dispensing,
// and administering a medication as well as for making statements about medication
// use.
type MedicationPackageSize struct {
	// The amount per each item, e.g. 10 ml / vial.
	AmountPerItem *Ratio `json:"amountPerItem,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The number of items in the package that are represented by the code, e.g. 5
	// vials or 100 tablets.
	NumberOfItems *Quantity `json:"numberOfItems,omitempty"`
}

// An order or request for both supply of the medication and the instructions for
// administration of the medication to a patient. The resource is called
// "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to
// generalize the use across inpatient and outpatient settings, including care
// plans, etc., and to harmonize with workflow patterns.
type MedicationRequest struct {
	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for isRecordOfRequest
	IsRecordOfRequest *Element `json:"_isRecordOfRequest,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusChanged
	StatusChanged *Element `json:"_statusChanged,omitempty"`

	// The date (and perhaps time) when the prescription was initially written or
	// authored on.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// Whenever the medication request is being issued because of another request, eg.
	// a procedure that is being planned (ServiceRequest) and MedicationRequests are
	// known to be needed, this element documents those requests.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// An arbitrary categorization or grouping of the medication request.  It could be
	// used for indicating where meds are intended to be administered, eg. in an
	// inpatient setting or in a patient's home, or a legal category of the
	// medication.
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicationRequestContainedElem `json:"contained,omitempty"`

	// The description of the overall pattern of the administration of the medication
	// to the patient.
	CourseOfTherapyType *CodeableConcept `json:"courseOfTherapyType,omitempty"`

	// The intended type of device that is to be used for the administration of the
	// medication (for example, PCA Pump).
	Device []CodeableReference `json:"device,omitempty"`

	// Indicates the specific details for the dispense or medication supply part of a
	// medication request (also known as a Medication Prescription or Medication
	// Order).  Note that this information is not always sent with the order.  There
	// may be in some settings (e.g. hospitals) institutional or system support for
	// completing the dispense details in the pharmacy department.
	DispenseRequest *MedicationRequestDispenseRequest `json:"dispenseRequest,omitempty"`

	// If true, indicates the provider is ordering a patient should not take the
	// specified medication. The reason for this order can be provided in the .reason
	// element. A MedicationRequest with .doNotPerform = true will not result in any
	// dispense or administration.  A request not to take or administer medication is
	// a standalone request, and does not update any other medication request.   When
	// true, active orders that may exist for the same medication are expected to be
	// canceled/ended, and new orders for the same medication are not expected.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// Specific instructions for how the medication is to be used by the patient.
	DosageInstruction *DosageDetails `json:"dosageInstruction,omitempty"`

	// The period over which the medication is to be taken. Can be specified as a
	// duration or a range. Where there are multiple dosageInstruction lines (for
	// example, tapering doses), this is the earliest date and the latest end date of
	// the dosageInstructions.
	EffectiveTimingDuration *Duration `json:"effectiveTimingDuration,omitempty"`

	// The period over which the medication is to be taken. Can be specified as a
	// duration or a range. Where there are multiple dosageInstruction lines (for
	// example, tapering doses), this is the earliest date and the latest end date of
	// the dosageInstructions.
	EffectiveTimingPeriod *Period `json:"effectiveTimingPeriod,omitempty"`

	// The period over which the medication is to be taken. Can be specified as a
	// duration or a range. Where there are multiple dosageInstruction lines (for
	// example, tapering doses), this is the earliest date and the latest end date of
	// the dosageInstructions.
	EffectiveTimingRange *Range `json:"effectiveTimingRange,omitempty"`

	// The Encounter during which this [x] was created or to which the creation of
	// this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// Links to Provenance records for past versions of this resource or fulfilling
	// request or event resources that identify key state transitions or updates that
	// are likely to be relevant to a user looking at the current version of the
	// resource.
	EventHistory []Reference `json:"eventHistory,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A shared identifier common to multiple independent Request instances that were
	// activated/authorized more or less simultaneously by a single author.  The
	// presence of the same identifier on each request ties those requests together
	// and may have business ramifications in terms of reporting of results, billing,
	// etc.  E.g. a requisition number shared by a set of lab tests ordered together,
	// or a prescription number shared by all meds ordered at one time.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers associated with this medication request that are defined by
	// business processes and/or used to refer to it when a direct URL reference to
	// the resource itself is not appropriate. They are business identifiers assigned
	// to this resource by the performer or other systems and remain constant as the
	// resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The person or organization who provided the information about this request, if
	// the source is someone other than the requestor. The informationSource element
	// is generally used when details of a prescription are being reported by someone
	// who is not the requestor, e.g., I indicate that I received a prescription for a
	// med out of my jurisdiction and the details are recorded in the system as a
	// MedicationRequest. Normally when this element is populated, the
	// .isRecordOfRequest element would be set to "true".
	InformationSource []Reference `json:"informationSource,omitempty"`

	// Insurance plans, coverage extensions, pre-authorizations and/or
	// pre-determinations that may be required for delivering the requested service.
	Insurance []Reference `json:"insurance,omitempty"`

	// Whether the request is a proposal, plan, or an original order.
	Intent_2 *Code `json:"intent,omitempty"`

	// The information in this instance is a record of the Medication Request and is
	// not request or order itself and should not be considered as such, i.e. the
	// information should not be used for medication dispense | supply and
	// administration.
	IsRecordOfRequest_2 *Boolean `json:"isRecordOfRequest,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Identifies the medication being requested. This is a link to a resource that
	// represents the medication which may be the details of the medication or simply
	// an attribute carrying a code that identifies the medication from a known list
	// of medications.
	Medication CodeableReference `json:"medication"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Extra information about the prescription that could not be conveyed by the
	// other attributes.
	Note []Annotation `json:"note,omitempty"`

	// The specified desired performer of the medication treatment (e.g. the performer
	// of the medication administration).  For devices, this is the device that is
	// intended to perform the administration of the medication.  An IV Pump would be
	// an example of a device that is performing the administration.  Both the IV Pump
	// and the practitioner that set the rate or bolus on the pump can be listed as
	// performers.
	Performer []Reference `json:"performer,omitempty"`

	// Indicates the type of performer of the administration of the medication.
	PerformerType *CodeableConcept `json:"performerType,omitempty"`

	// Reference to an order/prescription that is being replaced by this
	// MedicationRequest.
	PriorPrescription *Reference `json:"priorPrescription,omitempty"`

	// Indicates how quickly the Medication Request should be addressed with respect
	// to other requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// When the medication request was issued as a result of something that occurred,
	// i.e. a lab test or a performed procedure, this documents those reasons.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The person who entered the order on behalf of another individual for example in
	// the case of a verbal or a telephone order.
	Recorder *Reference `json:"recorder,omitempty"`

	// The individual, organization, or device that initiated the request and has
	// responsibility for its activation.
	Requester *Reference `json:"requester,omitempty"`

	// This is a MedicationRequest resource
	ResourceType interface{} `json:"resourceType"`

	// A code specifying the current state of the order.  Generally, this will be
	// active or completed state.
	Status_2 *Code `json:"status,omitempty"`

	// The date (and perhaps time) when the status was changed.
	StatusChanged_2 *DateTime `json:"statusChanged,omitempty"`

	// Captures the reason for the current state of the MedicationRequest.
	StatusReason *CodeableConcept `json:"statusReason,omitempty"`

	// The individual or group for whom the medication has been requested.
	Subject Reference `json:"subject"`

	// Indicates whether or not substitution can or should be part of the dispense. In
	// some cases, substitution must happen, in other cases substitution must not
	// happen. This block explains the prescriber's intent. If nothing is specified
	// substitution may be done.
	Substitution *MedicationRequestSubstitution `json:"substitution,omitempty"`

	// Information to support fulfilling (i.e. dispensing or administering) of the
	// medication, for example, patient height and weight, a MedicationStatement for
	// the patient).
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type MedicationRequestContainedElem interface{}

// An order or request for both supply of the medication and the instructions for
// administration of the medication to a patient. The resource is called
// "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to
// generalize the use across inpatient and outpatient settings, including care
// plans, etc., and to harmonize with workflow patterns.
type MedicationRequestDispenseRequest struct {
	// Extensions for numberOfRepeatsAllowed
	NumberOfRepeatsAllowed *Element `json:"_numberOfRepeatsAllowed,omitempty"`

	// Identification of the facility/location where the medication is expected to be
	// delivered.
	Destination *Reference `json:"destination,omitempty"`

	// The minimum period of time that must occur between dispenses of the medication.
	DispenseInterval *Duration `json:"dispenseInterval,omitempty"`

	// Indicates the intended performing Organization that will dispense the
	// medication as specified by the prescriber.
	Dispenser *Reference `json:"dispenser,omitempty"`

	// Provides additional information to the dispenser, for example, counselling to
	// be provided to the patient.
	DispenserInstruction []CodeableConcept `json:"dispenserInstruction,omitempty"`

	// Provides information about the type of adherence packaging to be supplied for
	// the medication dispense.
	DoseAdministrationAid *CodeableConcept `json:"doseAdministrationAid,omitempty"`

	// Identifies the period time over which the supplied product is expected to be
	// used, or the length of time the dispense is expected to last.
	ExpectedSupplyDuration *Duration `json:"expectedSupplyDuration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Indicates the quantity or duration for the first dispense of the medication.
	InitialFill *MedicationRequestInitialFill `json:"initialFill,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An integer indicating the number of times, in addition to the original
	// dispense, (aka refills or repeats) that the patient can receive the prescribed
	// medication. Usage Notes: This integer does not include the original order
	// dispense. This means that if an order indicates dispense 30 tablets plus "3
	// repeats", then the order can be dispensed a total of 4 times and the patient
	// can receive a total of 120 tablets.  A prescriber may explicitly say that zero
	// refills are permitted after the initial dispense.
	NumberOfRepeatsAllowed_2 *UnsignedInt `json:"numberOfRepeatsAllowed,omitempty"`

	// The amount that is to be dispensed for one fill.
	Quantity *Quantity `json:"quantity,omitempty"`

	// This indicates the validity period of a prescription (stale dating the
	// Prescription).
	ValidityPeriod *Period `json:"validityPeriod,omitempty"`
}

// An order or request for both supply of the medication and the instructions for
// administration of the medication to a patient. The resource is called
// "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to
// generalize the use across inpatient and outpatient settings, including care
// plans, etc., and to harmonize with workflow patterns.
type MedicationRequestInitialFill struct {
	// The length of time that the first dispense is expected to last.
	Duration *Duration `json:"duration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The amount or quantity to provide as part of the first dispense.
	Quantity *Quantity `json:"quantity,omitempty"`
}

// An order or request for both supply of the medication and the instructions for
// administration of the medication to a patient. The resource is called
// "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to
// generalize the use across inpatient and outpatient settings, including care
// plans, etc., and to harmonize with workflow patterns.
type MedicationRequestSubstitution struct {
	// Extensions for allowedBoolean
	AllowedBoolean *Element `json:"_allowedBoolean,omitempty"`

	// True if the prescriber allows a different drug to be dispensed from what was
	// prescribed.
	AllowedBoolean_2 *bool `json:"allowedBoolean,omitempty"`

	// True if the prescriber allows a different drug to be dispensed from what was
	// prescribed.
	AllowedCodeableConcept *CodeableConcept `json:"allowedCodeableConcept,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the reason for the substitution, or why substitution must or must not
	// be performed.
	Reason *CodeableConcept `json:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["medication"]; raw != nil && !ok {
		return fmt.Errorf("field medication in MedicationRequest: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MedicationRequest: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in MedicationRequest: required")
	}
	type Plain MedicationRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationRequest(plain)
	return nil
}

// A record of a medication that is being consumed by a patient.   A
// MedicationStatement may indicate that the patient may be taking the medication
// now or has taken the medication in the past or will be taking the medication in
// the future.  The source of this information can be the patient, significant
// other (such as a family member or spouse), or a clinician.  A common scenario
// where this information is captured is during the history taking process during a
// patient visit or stay.   The medication information may come from sources such
// as the patient's memory, from a prescription bottle,  or from a list of
// medications the patient, clinician or other party maintains.
//
// The primary difference between a medicationstatement and a
// medicationadministration is that the medication administration has complete
// administration information and is based on actual administration information
// from the person who administered the medication.  A medicationstatement is
// often, if not always, less specific.  There is no required date/time when the
// medication was administered, in fact we only know that a source has reported the
// patient is taking this medication, where details such as time, quantity, or rate
// or even medication product may be incomplete or missing or less precise.  As
// stated earlier, the Medication Statement information may come from the patient's
// memory, from a prescription bottle or from a list of medications the patient,
// clinician or other party maintains.  Medication administration is more formal
// and is not missing detailed information.
type MedicationStatement struct {
	// Extensions for dateAsserted
	DateAsserted *Element `json:"_dateAsserted,omitempty"`

	// Extensions for effectiveDateTime
	EffectiveDateTime *Element `json:"_effectiveDateTime,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Indicates whether the medication is or is not being consumed or administered.
	Adherence *MedicationStatementAdherence `json:"adherence,omitempty"`

	// The individual, organization, or device that created the statement and has
	// responsibility for its content.
	Author *Reference `json:"author,omitempty"`

	// Type of medication statement.
	//
	// The committee will revisit these codes, expecting to use a codesystem from
	// [terminology.hl7.org](http://terminology.hl7.org).
	Category []CodeableConcept `json:"category,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicationStatementContainedElem `json:"contained,omitempty"`

	// The date when the Medication Statement was asserted by the information source.
	DateAsserted_2 *DateTime `json:"dateAsserted,omitempty"`

	// Allows linking the MedicationStatement to the underlying MedicationRequest, or
	// to other information that supports or is used to derive the
	// MedicationStatement.
	DerivedFrom []Reference `json:"derivedFrom,omitempty"`

	// Indicates how the medication is/was or should be taken by the patient.
	Dosage *DosageDetails `json:"dosage,omitempty"`

	// The interval of time during which it is being asserted that the patient
	// is/was/will be taking the medication (or was not taking, when the
	// MedicationStatement.adherence element is Not Taking).
	EffectiveDateTime_2 *string `json:"effectiveDateTime,omitempty"`

	// The interval of time during which it is being asserted that the patient
	// is/was/will be taking the medication (or was not taking, when the
	// MedicationStatement.adherence element is Not Taking).
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// The interval of time during which it is being asserted that the patient
	// is/was/will be taking the medication (or was not taking, when the
	// MedicationStatement.adherence element is Not Taking).
	EffectiveTiming *Timing `json:"effectiveTiming,omitempty"`

	// The encounter that establishes the context for this MedicationStatement.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers associated with this Medication Statement that are defined by
	// business processes and/or used to refer to it when a direct URL reference to
	// the resource itself is not appropriate. They are business identifiers assigned
	// to this resource by the performer or other systems and remain constant as the
	// resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The person or organization that provided the information about the taking of
	// this medication. Note: Use derivedFrom when a MedicationStatement is derived
	// from other resources, e.g. Claim or MedicationRequest.
	InformationSource []Reference `json:"informationSource,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Identifies the medication taken (or not taken). This is either a link to a
	// resource representing the details of the medication or a simple attribute
	// carrying a code that identifies the medication from a known list of
	// medications.
	Medication CodeableReference `json:"medication"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides extra information about the Medication Statement that is not conveyed
	// by the other attributes.
	Note []Annotation `json:"note,omitempty"`

	// A larger event of which this particular MedicationStatement is a component or
	// step.
	PartOf []Reference `json:"partOf,omitempty"`

	// A concept, Condition or observation that supports why the medication is
	// being/was taken.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Link to information that is relevant to a medication statement, for example,
	// illicit drug use, gestational age, etc.
	RelatedClinicalInformation []Reference `json:"relatedClinicalInformation,omitempty"`

	// This is a MedicationStatement resource
	ResourceType interface{} `json:"resourceType"`

	// A code representing the status of recording the medication statement.
	Status_2 *Code `json:"status,omitempty"`

	// The person, animal or group who is/was taking the medication.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A record of a medication that is being consumed by a patient.   A
// MedicationStatement may indicate that the patient may be taking the medication
// now or has taken the medication in the past or will be taking the medication in
// the future.  The source of this information can be the patient, significant
// other (such as a family member or spouse), or a clinician.  A common scenario
// where this information is captured is during the history taking process during a
// patient visit or stay.   The medication information may come from sources such
// as the patient's memory, from a prescription bottle,  or from a list of
// medications the patient, clinician or other party maintains.
//
// The primary difference between a medicationstatement and a
// medicationadministration is that the medication administration has complete
// administration information and is based on actual administration information
// from the person who administered the medication.  A medicationstatement is
// often, if not always, less specific.  There is no required date/time when the
// medication was administered, in fact we only know that a source has reported the
// patient is taking this medication, where details such as time, quantity, or rate
// or even medication product may be incomplete or missing or less precise.  As
// stated earlier, the Medication Statement information may come from the patient's
// memory, from a prescription bottle or from a list of medications the patient,
// clinician or other party maintains.  Medication administration is more formal
// and is not missing detailed information.
type MedicationStatementAdherence struct {
	// Type of the adherence for the medication.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Captures the reason for the current use or adherence of a medication.
	Reason *CodeableConcept `json:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationStatementAdherence) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in MedicationStatementAdherence: required")
	}
	type Plain MedicationStatementAdherence
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicationStatementAdherence(plain)
	return nil
}

type MedicationStatementContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicationStatement) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["medication"]; raw != nil && !ok {
		return fmt.Errorf("field medication in MedicationStatement: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MedicationStatement: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in MedicationStatement: required")
	}
	type Plain MedicationStatement
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EffectiveDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.EffectiveDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectiveDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = MedicationStatement(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Medication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Medication: required")
	}
	type Plain Medication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Medication(plain)
	return nil
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinition struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for indication
	Indication *Element `json:"_indication,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for statusDate
	StatusDate *Element `json:"_statusDate,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Whether the Medicinal Product is subject to additional monitoring for
	// regulatory reasons, such as heightened reporting requirements.
	AdditionalMonitoringIndicator *CodeableConcept `json:"additionalMonitoringIndicator,omitempty"`

	// Additional information or supporting documentation about the medicinal product.
	AttachedDocument []Reference `json:"attachedDocument,omitempty"`

	// Allows the key product features to be recorded, such as "sugar free", "modified
	// release", "parallel import".
	Characteristic []MedicinalProductDefinitionCharacteristic `json:"characteristic,omitempty"`

	// Allows the product to be classified by various systems, commonly WHO ATC.
	Classification []CodeableConcept `json:"classification,omitempty"`

	// Clinical trials or studies that this product is involved in.
	ClinicalTrial []Reference `json:"clinicalTrial,omitempty"`

	// A code that this product is known by, usually within some formal terminology,
	// perhaps assigned by a third party (i.e. not the manufacturer or regulator).
	// Products (types of medications) tend to be known by identifiers during
	// development and within regulatory process. However when they are prescribed
	// they tend to be identified by codes. The same product may be have multiple
	// codes, applied to it by multiple organizations.
	Code []Coding `json:"code,omitempty"`

	// The dose form for a single part product, or combined form of a multiple part
	// product. This is one concept that describes all the components. It does not
	// represent the form with components physically mixed, if that might be
	// necessary, for which see
	// (AdministrableProductDefinition.administrableDoseForm).
	CombinedPharmaceuticalDoseForm *CodeableConcept `json:"combinedPharmaceuticalDoseForm,omitempty"`

	// Types of medicinal manufactured items and/or devices that this product consists
	// of, such as tablets, capsule, or syringes. Used as a direct link when the
	// item's packaging is not being recorded (see also
	// PackagedProductDefinition.package.containedItem.item).
	ComprisedOf []Reference `json:"comprisedOf,omitempty"`

	// A product specific contact, person (in a role), or an organization.
	Contact []MedicinalProductDefinitionContact `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MedicinalProductDefinitionContainedElem `json:"contained,omitempty"`

	// Reference to another product, e.g. for linking authorised to investigational
	// product, or a virtual product.
	CrossReference []MedicinalProductDefinitionCrossReference `json:"crossReference,omitempty"`

	// General description of this product.
	Description_2 *Markdown `json:"description,omitempty"`

	// If this medicine applies to human or veterinary uses.
	Domain *CodeableConcept `json:"domain,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifier for this product. Could be an MPID. When in development or
	// being regulated, products are typically referenced by official identifiers,
	// assigned by a manufacturer or regulator, and unique to a product (which, when
	// compared to a product instance being prescribed, is actually a product type).
	// See also MedicinalProductDefinition.code.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Any component of the drug product which is not the chemical entity defined as
	// the drug substance, or an excipient in the drug product. This includes
	// process-related impurities and contaminants, product-related impurities
	// including degradation products.
	Impurity []CodeableReference `json:"impurity,omitempty"`

	// Description of indication(s) for this product, used when structured indications
	// are not required. In cases where structured indications are required, they are
	// captured using the ClinicalUseDefinition resource. An indication is a medical
	// situation for which using the product is appropriate.
	Indication_2 *Markdown `json:"indication,omitempty"`

	// The ingredients of this medicinal product - when not detailed in other
	// resources. This is only needed if the ingredients are not specified by incoming
	// references from the Ingredient resource, or indirectly via incoming
	// AdministrableProductDefinition, PackagedProductDefinition or
	// ManufacturedItemDefinition references. In cases where those levels of detail
	// are not used, the ingredients may be specified directly here as codes.
	Ingredient []CodeableConcept `json:"ingredient,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The legal status of supply of the medicinal product as classified by the
	// regulator.
	LegalStatusOfSupply *CodeableConcept `json:"legalStatusOfSupply,omitempty"`

	// Marketing status of the medicinal product, in contrast to marketing
	// authorization. This refers to the product being actually 'on the market' as
	// opposed to being allowed to be on the market (which is an authorization).
	MarketingStatus []MarketingStatus `json:"marketingStatus,omitempty"`

	// A master file for the medicinal product (e.g. Pharmacovigilance System Master
	// File). Drug master files (DMFs) are documents submitted to regulatory agencies
	// to provide confidential detailed information about facilities, processes or
	// articles used in the manufacturing, processing, packaging and storing of drug
	// products.
	MasterFile []Reference `json:"masterFile,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The product's name, including full name and possibly coded parts.
	Name []MedicinalProductDefinitionName `json:"name"`

	// A manufacturing or administrative process or step associated with (or performed
	// on) the medicinal product.
	Operation []MedicinalProductDefinitionOperation `json:"operation,omitempty"`

	// Package type for the product. See also the PackagedProductDefinition resource.
	PackagedMedicinalProduct []CodeableConcept `json:"packagedMedicinalProduct,omitempty"`

	// If authorised for use in children, or infants, neonates etc.
	PediatricUseIndicator *CodeableConcept `json:"pediatricUseIndicator,omitempty"`

	// This is a MedicinalProductDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The path by which the product is taken into or makes contact with the body. In
	// some regions this is referred to as the licensed or approved route. See also
	// AdministrableProductDefinition resource. MedicinalProductDefinition.route is
	// the same concept as AdministrableProductDefinition.routeOfAdministration.code,
	// and they cannot be used together.
	Route []CodeableConcept `json:"route,omitempty"`

	// Whether the Medicinal Product is subject to special measures for regulatory
	// reasons, such as a requirement to conduct post-authorization studies.
	SpecialMeasures []CodeableConcept `json:"specialMeasures,omitempty"`

	// The status within the lifecycle of this product record. A high-level status,
	// this is not intended to duplicate details carried elsewhere such as legal
	// status, or authorization status.
	Status *CodeableConcept `json:"status,omitempty"`

	// The date at which the given status became applicable.
	StatusDate_2 *DateTime `json:"statusDate,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Regulatory type, e.g. Investigational or Authorized.
	Type *CodeableConcept `json:"type,omitempty"`

	// A business identifier relating to a specific version of the product, this is
	// commonly used to support revisions to an existing product.
	Version_2 *String `json:"version,omitempty"`
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionCharacteristic struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code expressing the type of characteristic.
	Type CodeableConcept `json:"type"`

	// A value for the characteristic.text.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// A value for the characteristic.text.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// A value for the characteristic.text.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value for the characteristic.text.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A value for the characteristic.text.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// A value for the characteristic.text.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// A value for the characteristic.text.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A value for the characteristic.text.
	ValueRange *Range `json:"valueRange,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinitionCharacteristic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MedicinalProductDefinitionCharacteristic: required")
	}
	type Plain MedicinalProductDefinitionCharacteristic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	*j = MedicinalProductDefinitionCharacteristic(plain)
	return nil
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionContact struct {
	// A product specific contact, person (in a role), or an organization.
	Contact Reference `json:"contact"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Allows the contact to be classified, for example QPPV, Pharmacovigilance
	// Enquiry Information.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinitionContact) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contact"]; raw != nil && !ok {
		return fmt.Errorf("field contact in MedicinalProductDefinitionContact: required")
	}
	type Plain MedicinalProductDefinitionContact
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicinalProductDefinitionContact(plain)
	return nil
}

type MedicinalProductDefinitionContainedElem interface{}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionCrossReference struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to another product, e.g. for linking authorised to investigational
	// product.
	Product CodeableReference `json:"product"`

	// The type of relationship, for instance branded to generic, virtual to actual
	// product, product to development product (investigational), parallel import
	// version.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinitionCrossReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["product"]; raw != nil && !ok {
		return fmt.Errorf("field product in MedicinalProductDefinitionCrossReference: required")
	}
	type Plain MedicinalProductDefinitionCrossReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicinalProductDefinitionCrossReference(plain)
	return nil
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionName struct {
	// Extensions for productName
	ProductName *Element `json:"_productName,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Coding words or phrases of the name.
	Part []MedicinalProductDefinitionPart `json:"part,omitempty"`

	// The full product name.
	ProductName_2 *String `json:"productName,omitempty"`

	// Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
	Type *CodeableConcept `json:"type,omitempty"`

	// Country and jurisdiction where the name applies, and associated language.
	Usage []MedicinalProductDefinitionUsage `json:"usage,omitempty"`
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionOperation struct {
	// Specifies whether this particular business or manufacturing process is
	// considered proprietary or confidential.
	ConfidentialityIndicator *CodeableConcept `json:"confidentialityIndicator,omitempty"`

	// Date range of applicability.
	EffectiveDate *Period `json:"effectiveDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The organization or establishment responsible for (or associated with) the
	// particular process or step, examples include the manufacturer, importer, agent.
	Organization []Reference `json:"organization,omitempty"`

	// The type of manufacturing operation e.g. manufacturing itself, re-packaging.
	// For the authorization of this, a RegulatedAuthorization would point to the same
	// plan or activity referenced here.
	Type *CodeableReference `json:"type,omitempty"`
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionPart struct {
	// Extensions for part
	Part *Element `json:"_part,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A fragment of a product name.
	Part_2 *String `json:"part,omitempty"`

	// Identifying type for this part of the name (e.g. strength part).
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinitionPart) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MedicinalProductDefinitionPart: required")
	}
	type Plain MedicinalProductDefinitionPart
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicinalProductDefinitionPart(plain)
	return nil
}

// A medicinal product, being a substance or combination of substances that is
// intended to treat, prevent or diagnose a disease, or to restore, correct or
// modify physiological functions by exerting a pharmacological, immunological or
// metabolic action. This resource is intended to define and detail such products
// and their properties, for uses other than direct patient care (e.g. regulatory
// use, or drug catalogs).
type MedicinalProductDefinitionUsage struct {
	// Country code for where this name applies.
	Country CodeableConcept `json:"country"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Jurisdiction code for where this name applies. A jurisdiction may be a sub- or
	// supra-national entity (e.g. a state or a geographic region).
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`

	// Language code for this name.
	Language CodeableConcept `json:"language"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinitionUsage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["country"]; raw != nil && !ok {
		return fmt.Errorf("field country in MedicinalProductDefinitionUsage: required")
	}
	if _, ok := raw["language"]; raw != nil && !ok {
		return fmt.Errorf("field language in MedicinalProductDefinitionUsage: required")
	}
	type Plain MedicinalProductDefinitionUsage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicinalProductDefinitionUsage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MedicinalProductDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in MedicinalProductDefinition: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MedicinalProductDefinition: required")
	}
	type Plain MedicinalProductDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MedicinalProductDefinition(plain)
	return nil
}

// Defines the characteristics of a message that can be shared between systems,
// including the type of event that initiates the message, the content to be
// transmitted and what response(s), if any, are permitted.
type MessageDefinition struct {
	// Extensions for category
	Category *Element `json:"_category,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for eventUri
	EventUri *Element `json:"_eventUri,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for responseRequired
	ResponseRequired *Element `json:"_responseRequired,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Indicates what types of messages may be sent as an application-level response
	// to this message.
	AllowedResponse []MessageDefinitionAllowedResponse `json:"allowedResponse,omitempty"`

	// The MessageDefinition that is the basis for the contents of this resource.
	Base *Canonical `json:"base,omitempty"`

	// The impact of the content of the message.
	Category_2 *Code `json:"category,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MessageDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the message definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the message definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the message definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the message definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the message definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// Event code or link to the EventDefinition.
	EventCoding *Coding `json:"eventCoding,omitempty"`

	// Event code or link to the EventDefinition.
	EventUri_2 *string `json:"eventUri,omitempty"`

	// A Boolean value to indicate that this message definition is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Identifies the resource (or resources) that are being addressed by the event.
	// For example, the Encounter for an admit message or two Account records for a
	// merge.
	Focus []MessageDefinitionFocus `json:"focus,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this message definition when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the message definition. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Identifies a protocol or workflow that this MessageDefinition represents a step
	// in.
	Parent []Canonical `json:"parent,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the message definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this message definition is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// A MessageDefinition that is superseded by this definition.
	Replaces []Canonical `json:"replaces,omitempty"`

	// This is a MessageDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// Declare at a message definition level whether a response is required or only
	// upon error or success, or never.
	ResponseRequired_2 *Code `json:"responseRequired,omitempty"`

	// The status of this message definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the message definition.
	Title_2 *String `json:"title,omitempty"`

	// The business identifier that is used to reference the MessageDefinition and
	// *is* expected to be consistent from server to server.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate message
	// definition instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the message definition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the message definition author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// Defines the characteristics of a message that can be shared between systems,
// including the type of event that initiates the message, the content to be
// transmitted and what response(s), if any, are permitted.
type MessageDefinitionAllowedResponse struct {
	// Extensions for situation
	Situation *Element `json:"_situation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A reference to the message definition that must be adhered to by this supported
	// response.
	Message Canonical `json:"message"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides a description of the circumstances in which this response should be
	// used (as opposed to one of the alternative responses).
	Situation_2 *Markdown `json:"situation,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageDefinitionAllowedResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in MessageDefinitionAllowedResponse: required")
	}
	type Plain MessageDefinitionAllowedResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MessageDefinitionAllowedResponse(plain)
	return nil
}

type MessageDefinitionContainedElem interface{}

// Defines the characteristics of a message that can be shared between systems,
// including the type of event that initiates the message, the content to be
// transmitted and what response(s), if any, are permitted.
type MessageDefinitionFocus struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// The kind of resource that must be the focus for this message.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifies the maximum number of resources of this type that must be pointed to
	// by a message in order for it to be valid against this MessageDefinition.
	Max_2 *String `json:"max,omitempty"`

	// Identifies the minimum number of resources of this type that must be pointed to
	// by a message in order for it to be valid against this MessageDefinition.
	Min_2 *UnsignedInt `json:"min,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A profile that reflects constraints for the focal resource (and potentially for
	// related resources).
	Profile *Canonical `json:"profile,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MessageDefinition: required")
	}
	type Plain MessageDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EventUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.EventUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EventUri_2", `^\S*$`)
		}
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = MessageDefinition(plain)
	return nil
}

// The header for a message exchange that is either requesting or responding to an
// action.  The reference(s) that are the subject of the action as well as other
// information related to the action are typically transmitted in a bundle in which
// the MessageHeader resource instance is the first resource in the bundle.
type MessageHeader struct {
	// Extensions for eventCanonical
	EventCanonical *Element `json:"_eventCanonical,omitempty"`

	// Extensions for eventUri
	EventUri *Element `json:"_eventUri,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []MessageHeaderContainedElem `json:"contained,omitempty"`

	// Permanent link to the MessageDefinition for this message.
	Definition *Canonical `json:"definition,omitempty"`

	// The destination application which the message is intended for.
	Destination []MessageHeaderDestination `json:"destination,omitempty"`

	// Code that identifies the event this message represents and connects it with its
	// definition. Events are defined by codes, or by URIs that identify events, or by
	// reference to EventDefinition or SubscriptionTopic resources that define the
	// event directly. This element is intentionally unbound, and the selection of
	// appropriate event codes is delegated to implementations and implementation
	// guides. For codes, a good set of example codes is found in [the V2 event
	// codes](https://terminology.hl7.org/ValueSet-v2-0003.html).
	EventCanonical_2 *string `json:"eventCanonical,omitempty"`

	// Code that identifies the event this message represents and connects it with its
	// definition. Events are defined by codes, or by URIs that identify events, or by
	// reference to EventDefinition or SubscriptionTopic resources that define the
	// event directly. This element is intentionally unbound, and the selection of
	// appropriate event codes is delegated to implementations and implementation
	// guides. For codes, a good set of example codes is found in [the V2 event
	// codes](https://terminology.hl7.org/ValueSet-v2-0003.html).
	EventCoding *Coding `json:"eventCoding,omitempty"`

	// Code that identifies the event this message represents and connects it with its
	// definition. Events are defined by codes, or by URIs that identify events, or by
	// reference to EventDefinition or SubscriptionTopic resources that define the
	// event directly. This element is intentionally unbound, and the selection of
	// appropriate event codes is delegated to implementations and implementation
	// guides. For codes, a good set of example codes is found in [the V2 event
	// codes](https://terminology.hl7.org/ValueSet-v2-0003.html).
	EventUri_2 *string `json:"eventUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual data of the message - a reference to the root/focus class of the
	// event. This is allowed to be a Parameters resource.
	Focus []Reference `json:"focus,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Coded indication of the cause for the event - indicates  a reason for the
	// occurrence of the event that is a focus of this message.
	Reason *CodeableConcept `json:"reason,omitempty"`

	// This is a MessageHeader resource
	ResourceType interface{} `json:"resourceType"`

	// Information about the message that this message is a response to.  Only present
	// if this message is a response.
	Response *MessageHeaderResponse `json:"response,omitempty"`

	// The source application from which this message originated.
	Source MessageHeaderSource `json:"source"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type MessageHeaderContainedElem interface{}

// The header for a message exchange that is either requesting or responding to an
// action.  The reference(s) that are the subject of the action as well as other
// information related to the action are typically transmitted in a bundle in which
// the MessageHeader resource instance is the first resource in the bundle.
type MessageHeaderDestination struct {
	// Extensions for endpointUrl
	EndpointUrl *Element `json:"_endpointUrl,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Indicates where the message should be routed.
	EndpointReference *Reference `json:"endpointReference,omitempty"`

	// Indicates where the message should be routed.
	EndpointUrl_2 *string `json:"endpointUrl,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Human-readable name for the target system.
	Name_2 *String `json:"name,omitempty"`

	// Allows data conveyed by a message to be addressed to a particular person or
	// department when routing to a specific application isn't sufficient.
	Receiver *Reference `json:"receiver,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageHeaderDestination) UnmarshalJSON(value []byte) error {
	type Plain MessageHeaderDestination
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EndpointUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.EndpointUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EndpointUrl_2", `^\S*$`)
		}
	}
	*j = MessageHeaderDestination(plain)
	return nil
}

// The header for a message exchange that is either requesting or responding to an
// action.  The reference(s) that are the subject of the action as well as other
// information related to the action are typically transmitted in a bundle in which
// the MessageHeader resource instance is the first resource in the bundle.
type MessageHeaderResponse struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Code that identifies the type of response to the message - whether it was
	// successful or not, and whether it should be resent or not.
	Code_2 *Code `json:"code,omitempty"`

	// Full details of any issues found in the message.
	Details *Reference `json:"details,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The Bundle.identifier of the message to which this message is a response.
	Identifier Identifier `json:"identifier"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageHeaderResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["identifier"]; raw != nil && !ok {
		return fmt.Errorf("field identifier in MessageHeaderResponse: required")
	}
	type Plain MessageHeaderResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MessageHeaderResponse(plain)
	return nil
}

// The header for a message exchange that is either requesting or responding to an
// action.  The reference(s) that are the subject of the action as well as other
// information related to the action are typically transmitted in a bundle in which
// the MessageHeader resource instance is the first resource in the bundle.
type MessageHeaderSource struct {
	// Extensions for endpointUrl
	EndpointUrl *Element `json:"_endpointUrl,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for software
	Software *Element `json:"_software,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// An e-mail, phone, website or other contact point to use to resolve issues with
	// message communications.
	Contact *ContactPoint `json:"contact,omitempty"`

	// Identifies the routing target to send acknowledgements to.
	EndpointReference *Reference `json:"endpointReference,omitempty"`

	// Identifies the routing target to send acknowledgements to.
	EndpointUrl_2 *string `json:"endpointUrl,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Human-readable name for the source system.
	Name_2 *String `json:"name,omitempty"`

	// Identifies the sending entity to allow the use of a trust relationship.
	Sender *Reference `json:"sender,omitempty"`

	// May include configuration or other information useful in debugging.
	Software_2 *String `json:"software,omitempty"`

	// Can convey versions of multiple systems in situations where a message passes
	// through multiple hands.
	Version_2 *String `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageHeaderSource) UnmarshalJSON(value []byte) error {
	type Plain MessageHeaderSource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EndpointUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.EndpointUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EndpointUrl_2", `^\S*$`)
		}
	}
	*j = MessageHeaderSource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageHeader) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in MessageHeader: required")
	}
	if _, ok := raw["source"]; raw != nil && !ok {
		return fmt.Errorf("field source in MessageHeader: required")
	}
	type Plain MessageHeader
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EventCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.EventCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EventCanonical_2", `^\S*$`)
		}
	}
	if plain.EventUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.EventUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EventUri_2", `^\S*$`)
		}
	}
	*j = MessageHeader(plain)
	return nil
}

// The metadata about a resource. This is content in the resource that is
// maintained by the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
type Meta struct {
	// Extensions for lastUpdated
	LastUpdated *Element `json:"_lastUpdated,omitempty"`

	// Extensions for source
	Source *Element `json:"_source,omitempty"`

	// Extensions for versionId
	VersionID *Element `json:"_versionId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// When the resource last changed - e.g. when the version changed.
	LastUpdated_2 *Instant `json:"lastUpdated,omitempty"`

	// A list of profiles (references to [[[StructureDefinition]]] resources) that
	// this resource claims to conform to. The URL is a reference to
	// [[[StructureDefinition.url]]].
	Profile []Canonical `json:"profile,omitempty"`

	// Security labels applied to this resource. These tags connect specific resources
	// to the overall security policy and infrastructure.
	Security []Coding `json:"security,omitempty"`

	// A uri that identifies the data source of the resource. This provides a minimal
	// amount of [[[Provenance]]] information that can be used to track or
	// differentiate the source of information in the resource. The source may
	// identify another server, document, message, database, etc.  It can also refer
	// to portions of a structure, such as a section, segment, row, etc.
	Source_2 *Uri `json:"source,omitempty"`

	// Tags applied to this resource. Tags are intended to be used to identify and
	// relate resources to process and workflow, and applications are not required to
	// consider the tags when interpreting the meaning of a resource.
	Tag []Coding `json:"tag,omitempty"`

	// The version specific identifier, as it appears in the version portion of the
	// URL. This value changes when the resource is created, updated, or deleted.
	VersionID_2 *ID `json:"versionId,omitempty"`
}

// Financial line items use this datatype to commonly categorize the value, and
// other factors that may effect how the value should be interpreted.
type MonetaryComponent struct {
	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// The explicit value amount of the component (based on type/code).
	Amount *Money `json:"amount,omitempty"`

	// A codable breakdown of the type of monetary component. e.g. State Tax, Federal
	// Tax, VIP-Discount.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The factor that has been applied to the base price (in another monetary
	// component value) when performing calculations.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The type of monetary component, what the value is to be used for and how that
	// should be applied in its context. e.g. A surchange would increase the cost, a
	// deduction would reduce the cost.
	Type_2 *Code `json:"type,omitempty"`
}

// An amount of economic utility in some recognized currency.
type Money struct {
	// Extensions for currency
	Currency *Element `json:"_currency,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// ISO 4217 Currency Code.
	Currency_2 *Code `json:"currency,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Numerical value (with implicit precision).
	Value_2 *Decimal `json:"value,omitempty"`
}

// A curated namespace that issues unique symbols within that namespace for the
// identification of concepts, people, devices, etc.  Represents a "System" used
// within the Identifier and Coding data types.
type NamingSystem struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for responsible
	Responsible *Element `json:"_responsible,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the NamingSystem.
	Author []ContactDetail `json:"author,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []NamingSystemContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the naming system and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the naming system.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the naming system was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the naming system changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the naming system from a consumer's
	// perspective. Details about what the namespace identifies including scope,
	// granularity, version labeling, etc.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the NamingSystem.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the NamingSystem content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the NamingSystem for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this naming system is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this naming system when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// Indicates the purpose for the naming system - what kinds of things does it make
	// unique?
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the naming system. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the naming system.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this naming system is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts. If the type is `successor` or `predecessor`, the related resource
	// must be a NamingSystem.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a NamingSystem resource
	ResourceType interface{} `json:"resourceType"`

	// The name of the organization that is responsible for issuing identifiers or
	// codes for this namespace and ensuring their non-collision.
	Responsible_2 *String `json:"responsible,omitempty"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the NamingSystem.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this naming system. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the naming system.
	Title_2 *String `json:"title,omitempty"`

	// Descriptions related to the content of the NamingSystem. Topics provide a
	// high-level categorization as well as keywords for the NamingSystem that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// Categorizes a naming system for easier search by grouping related naming
	// systems.
	Type *CodeableConcept `json:"type,omitempty"`

	// Indicates how the system may be identified when referenced in electronic
	// exchange.
	UniqueID []NamingSystemUniqueID `json:"uniqueId"`

	// An absolute URI that is used to identify this naming system when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this naming system is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the naming system is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// Provides guidance on the use of the namespace, including the handling of
	// formatting characters, use of upper vs. lower case, etc.
	Usage_2 *String `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate naming system
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the naming system when
	// it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the naming system author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which
	// NamingSystem is more current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which
	// NamingSystem is more current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type NamingSystemContainedElem interface{}

// A curated namespace that issues unique symbols within that namespace for the
// identification of concepts, people, devices, etc.  Represents a "System" used
// within the Identifier and Coding data types.
type NamingSystemUniqueID struct {
	// Extensions for authoritative
	Authoritative *Element `json:"_authoritative,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Indicates whether this identifier ie endorsed by the official owner of the
	// associated naming system.
	Authoritative_2 *Boolean `json:"authoritative,omitempty"`

	// Notes about the past or intended usage of this identifier.
	Comment_2 *String `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies the period of time over which this identifier is considered
	// appropriate to refer to the naming system.  Outside of this window, the
	// identifier might be non-deterministic.
	Period *Period `json:"period,omitempty"`

	// Indicates whether this identifier is the "preferred" identifier of this type.
	Preferred_2 *Boolean `json:"preferred,omitempty"`

	// Identifies the unique identifier scheme used for this particular identifier.
	Type_2 *Code `json:"type,omitempty"`

	// The string that should be sent over the wire to identify the code system or
	// identifier system.
	Value_2 *String `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NamingSystem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in NamingSystem: required")
	}
	if _, ok := raw["uniqueId"]; raw != nil && !ok {
		return fmt.Errorf("field uniqueId in NamingSystem: required")
	}
	type Plain NamingSystem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = NamingSystem(plain)
	return nil
}

// A human-readable summary of the resource conveying the essential clinical and
// business information for the resource.
type Narrative struct {
	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The actual narrative content, a stripped down version of XHTML.
	Div NarrativeDiv `json:"div"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The status of the narrative - whether it's entirely generated (from just the
	// defined data or the extensions too), or whether a human authored it and it may
	// contain additional data.
	Status_2 *NarrativeStatus_2 `json:"status,omitempty"`
}

// The actual narrative content, a stripped down version of XHTML.
type NarrativeDiv interface{}

type NarrativeStatus_2 string

const NarrativeStatus_2_Additional NarrativeStatus_2 = "additional"
const NarrativeStatus_2_Empty NarrativeStatus_2 = "empty"
const NarrativeStatus_2_Extensions NarrativeStatus_2 = "extensions"
const NarrativeStatus_2_Generated NarrativeStatus_2 = "generated"

var enumValues_NarrativeStatus_2 = []interface{}{
	"generated",
	"extensions",
	"additional",
	"empty",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NarrativeStatus_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NarrativeStatus_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NarrativeStatus_2, v)
	}
	*j = NarrativeStatus_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Narrative) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["div"]; raw != nil && !ok {
		return fmt.Errorf("field div in Narrative: required")
	}
	type Plain Narrative
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Narrative(plain)
	return nil
}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntake struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for reportedBoolean
	ReportedBoolean *Element `json:"_reportedBoolean,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this event.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Overall type of nutrition intake.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []NutritionIntakeContainedElem `json:"contained,omitempty"`

	// Allows linking the NutritionIntake to the underlying NutritionOrder, or to
	// other information, such as AllergyIntolerance, that supports or is used to
	// derive the NutritionIntake.
	DerivedFrom []Reference `json:"derivedFrom,omitempty"`

	// The encounter that establishes the context for this NutritionIntake.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers associated with this Nutrition Intake that are defined by business
	// processes and/or used to refer to it when a direct URL reference to the
	// resource itself is not appropriate. They are business identifiers assigned to
	// this resource by the performer or other systems and remain constant as the
	// resource is updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Where the intake occurred.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides extra information about the Nutrition Intake that is not conveyed by
	// the other attributes.
	Note []Annotation `json:"note,omitempty"`

	// The nutrition product intended for consumption and/or administration.
	NutritionItem []NutritionIntakeNutritionItem `json:"nutritionItem,omitempty"`

	// The interval of time during which it is being asserted that the patient is/was
	// consuming the food (i.e. solid and/or liquid).
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The interval of time during which it is being asserted that the patient is/was
	// consuming the food (i.e. solid and/or liquid).
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// A larger event of which this particular event is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// Who or what performed the intake and how they were involved.
	Performer []NutritionIntakePerformer `json:"performer,omitempty"`

	// A reason, Condition or observation for why the food (i.e. solid and/or liquid)
	// is /was consumed.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The date when the Nutrition Intake was asserted by the information source.
	Recorded_2 *DateTime `json:"recorded,omitempty"`

	// Indicates if this record was captured as a secondary 'reported' record rather
	// than as an original primary source-of-truth.  It may also indicate the source
	// that provided the information about the consumption.
	ReportedBoolean_2 *bool `json:"reportedBoolean,omitempty"`

	// Indicates if this record was captured as a secondary 'reported' record rather
	// than as an original primary source-of-truth.  It may also indicate the source
	// that provided the information about the consumption.
	ReportedReference *Reference `json:"reportedReference,omitempty"`

	// This is a NutritionIntake resource
	ResourceType interface{} `json:"resourceType"`

	// A code representing the patient or other source's judgment about the state of
	// the intake that this assertion is about.  Generally, this will be active or
	// completed.
	Status_2 *Code `json:"status,omitempty"`

	// Captures the reason for the current state of the NutritionIntake.
	StatusReason []CodeableConcept `json:"statusReason,omitempty"`

	// The person or group who is/was consuming the food (i.e. solid and/or liquid).
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntakeConsumedItem struct {
	// Quantity of the specified food (i.e. solid and/or liquid).
	Amount *Quantity `json:"amount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Rate of enteral feeding administration.
	RateQuantity *Quantity `json:"rateQuantity,omitempty"`

	// Rate of enteral feeding administration.
	RateRatio *Ratio `json:"rateRatio,omitempty"`

	// Scheduled frequency of consumption.
	Schedule *Timing `json:"schedule,omitempty"`

	// Nutrients and/or energy contained in the intake.
	TotalIntake []NutritionIntakeTotalIntake `json:"totalIntake,omitempty"`
}

type NutritionIntakeContainedElem interface{}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntakeNotConsumedItem struct {
	// Quantity of the specified food (i.e. solid and/or liquid) that was not
	// consumed.
	Amount *Quantity `json:"amount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Document the reason the nutrition item was not consumed, such as refused, held,
	// etc.
	Reason *CodeableConcept `json:"reason,omitempty"`

	// The intended frequency of consumption that was not followed.
	Schedule *Timing `json:"schedule,omitempty"`
}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntakeNutritionItem struct {
	// What nutrition item was consumed.
	ConsumedItem []NutritionIntakeConsumedItem `json:"consumedItem,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// What nutrition item was not consumed.
	NotConsumedItem []NutritionIntakeNotConsumedItem `json:"notConsumedItem,omitempty"`

	// Identifies the food (i.e. solid and/or liquid) product that is to be consumed.
	// This is potentially a link to a resource representing the details of the food
	// product or a simple attribute carrying a code that identifies the food from a
	// known list of foods.
	NutritionProduct *CodeableReference `json:"nutritionProduct,omitempty"`

	// Indicates what a category of item that is intended to be consumed: e.g., food
	// (i.e. solid and/or liquid), breastmilk, infant formula, supplements, enteral
	// formula.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntakePerformer struct {
	// Who or what performed the intake.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Type of performance.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionIntakePerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in NutritionIntakePerformer: required")
	}
	type Plain NutritionIntakePerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionIntakePerformer(plain)
	return nil
}

// A record of intake by a patient.  A NutritionIntake may indicate that the
// patient may be consuming the food (i.e., solid and/or liquid), breastmilk,
// infant formula, supplements, enteral formula now or has consumed it in the past.
// The source of this information can be the patient, significant other (such as a
// family member or spouse), or a clinician.  A common scenario where this
// information is captured is during the history taking process during a patient
// visit or stay or through an app that tracks food (i.e., solid and/or liquid),
// breastmilk, infant formula, supplements, enteral formula consumed.   The
// consumption information may come from sources such as the patient's memory, from
// a nutrition label, or from a clinician documenting observed intake.
type NutritionIntakeTotalIntake struct {
	// Total amount of nutrient consumed.
	Amount Quantity `json:"amount"`

	// Total energy consumed in kilocalories or kilojoules.
	Energy *Quantity `json:"energy,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Type of nutrient consumed. This could be a macronutrient (protein, fat,
	// carbohydrate), or a vitamin and mineral.
	Nutrient CodeableReference `json:"nutrient"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionIntakeTotalIntake) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in NutritionIntakeTotalIntake: required")
	}
	if _, ok := raw["nutrient"]; raw != nil && !ok {
		return fmt.Errorf("field nutrient in NutritionIntakeTotalIntake: required")
	}
	type Plain NutritionIntakeTotalIntake
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionIntakeTotalIntake(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionIntake) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in NutritionIntake: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in NutritionIntake: required")
	}
	type Plain NutritionIntake
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = NutritionIntake(plain)
	return nil
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrder struct {
	// Extensions for dateTime
	DateTime *Element `json:"_dateTime,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outsideFoodAllowed
	OutsideFoodAllowed *Element `json:"_outsideFoodAllowed,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Indicates modular components to be provided in addition or mixed with the oral
	// diet, supplement, and/or enteral feeding.
	Additive []NutritionOrderAdditive `json:"additive,omitempty"`

	// A link to a record of allergies or intolerances  which should be included in
	// the nutrition order.
	AllergyIntolerance []Reference `json:"allergyIntolerance,omitempty"`

	// A plan or request that is fulfilled in whole or in part by this nutrition
	// order.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []NutritionOrderContainedElem `json:"contained,omitempty"`

	// The date and time that this nutrition order was requested.
	DateTime_2 *DateTime `json:"dateTime,omitempty"`

	// An encounter that provides additional information about the healthcare context
	// in which this request is made.
	Encounter *Reference `json:"encounter,omitempty"`

	// Feeding provided through the gastrointestinal tract via a tube, catheter, or
	// stoma that delivers nutrition distal to the oral cavity.
	EnteralFormula *NutritionOrderEnteralFormula `json:"enteralFormula,omitempty"`

	// This modifier is used to convey Order-specific modifiers that should not be
	// given. These can be derived from patient allergies, intolerances, or
	// preferences such as No Red Meat, No Soy or No Wheat or Gluten-Free. While it
	// should not be necessary to repeat allergy or intolerance information captured
	// in the referenced AllergyIntolerance resource in the excludeFoodModifier, this
	// element may be used to convey additional specificity related to what should be
	// eliminated from the patientâ€™s diet for any reason. This modifier applies to the
	// entire nutrition order inclusive of the oral diet, nutritional supplements and
	// enteral formula feedings.
	ExcludeFoodModifier []CodeableConcept `json:"excludeFoodModifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// This modifier is used to convey order-specific modifiers about the type of food
	// (i.e. solid and/or liquid) that should be given. These can be derived from
	// patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher.
	// This modifier applies to the entire nutrition order inclusive of the oral diet,
	// nutritional supplements and enteral formula feedings.
	FoodPreferenceModifier []CodeableConcept `json:"foodPreferenceModifier,omitempty"`

	// A shared identifier common to all nutrition orders that were authorized more or
	// less simultaneously by a single author, representing the composite or group
	// identifier.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this order by the order sender or by the order
	// receiver.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Indicates the level of authority/intentionality associated with the
	// NutrionOrder and where the request fits into the workflow chain.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the nutrition order by the requester, performer, subject or
	// other participants.
	Note []Annotation `json:"note,omitempty"`

	// Diet given orally that may include texture modification, such as International
	// Dysphagia Diet Standardisation Initiative Framework - Slightly Thick Level 1
	// drinks and Minced and International Dysphagia Diet Standardisation Initiative
	// Framework - Minced and Moist Level 5 food as well as, for example, Decreased
	// potassium diet (ie, nutrient modification), Halal diet (ie, cultural
	// modification), and/or Low microbial diet (eg, other modification).
	OralDiet *NutritionOrderOralDiet `json:"oralDiet,omitempty"`

	// This modifier is used to convey whether a food item, brought in by the patient,
	// family, and/or caregiver, can be consumed by the patient.  If set to true,
	// indicates that the receiving system does not need to supply the food item.
	OutsideFoodAllowed_2 *Boolean `json:"outsideFoodAllowed,omitempty"`

	// The specified desired performer of the nutrition order.
	Performer []CodeableReference `json:"performer,omitempty"`

	// Indicates how quickly the Nutrition Order should be addressed with respect to
	// other        requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// The practitioner that holds legal responsibility for ordering the diet,
	// nutritional supplement, or formula feedings.
	Requester *Reference `json:"requester,omitempty"`

	// This is a NutritionOrder resource
	ResourceType interface{} `json:"resourceType"`

	// The workflow status of the nutrition order/request.
	Status_2 *Code `json:"status,omitempty"`

	// The person or set of individuals who needs the nutrition order for an oral
	// diet, nutritional supplement and/or enteral or formula feeding.
	Subject Reference `json:"subject"`

	// Oral nutritional products given in order to add further nutritional value to
	// the patient's diet.
	Supplement []NutritionOrderSupplement `json:"supplement,omitempty"`

	// Information to support fulfilling (i.e. dispensing or administering) of the
	// nutrition,        for example, patient height and weight).
	SupportingInformation []Reference `json:"supportingInformation,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderAdditive struct {
	// Extensions for productName
	ProductName *Element `json:"_productName,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the type of modular component such as protein, carbohydrate, fat or
	// fiber to be provided in addition to or mixed with the oral diet, supplement,
	// and/or enteral feeding.
	ModularType *CodeableReference `json:"modularType,omitempty"`

	// The product or brand name of the type of modular additive to be added to the
	// oral diet, supplement, and/or enteral feeding.
	ProductName_2 *String `json:"productName,omitempty"`

	// The amount of additive to be given in addition or to be mixed in with the oral
	// diet, supplement, and/or enteral feeding.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The administration into the patient's gastrointestinal  tract for purposes of
	// providing the additive, e.g. nasogastric tube, oral.
	RouteOfAdministration []CodeableConcept `json:"routeOfAdministration,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderAdministration struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The volume of formula feeding to provide to the patient per the specified
	// administration schedule.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The rate of administration of formula feeding via a feeding pump, e.g. 60 mL
	// per hour, according to the specified schedule.
	RateQuantity *Quantity `json:"rateQuantity,omitempty"`

	// The rate of administration of formula feeding via a feeding pump, e.g. 60 mL
	// per hour, according to the specified schedule.
	RateRatio *Ratio `json:"rateRatio,omitempty"`

	// Schedule information for an enteral feeding.
	Schedule *NutritionOrderSchedule2 `json:"schedule,omitempty"`
}

type NutritionOrderContainedElem interface{}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderEnteralFormula struct {
	// Extensions for administrationInstruction
	AdministrationInstruction *Element `json:"_administrationInstruction,omitempty"`

	// Extensions for deliveryDeviceCanonical
	DeliveryDeviceCanonical *Element `json:"_deliveryDeviceCanonical,omitempty"`

	// Extensions for productName
	ProductName *Element `json:"_productName,omitempty"`

	// Formula feeding administration instructions as structured data.  This repeating
	// structure allows for changing the administration rate or volume over time for
	// both bolus and continuous feeding.  An example of this would be an instruction
	// to increase the rate of continuous feeding every 2 hours.
	Administration []NutritionOrderAdministration `json:"administration,omitempty"`

	// Free text formula administration, feeding instructions or additional
	// instructions or information.
	AdministrationInstruction_2 *Markdown `json:"administrationInstruction,omitempty"`

	// The amount of energy (calories or kilojoules) that the feeding should provide
	// per specified volume, typically per mL or fluid oz.  For example, an infant may
	// require a formula that provides 24 calories per fluid ounce or an adult may
	// require an enteral formula that provides 1.5 calorie/mL.
	CaloricDensity *Quantity `json:"caloricDensity,omitempty"`

	// The intended type of device that is to be used for the administration of the
	// enteral formula.
	DeliveryDeviceCanonical_2 *string `json:"deliveryDeviceCanonical,omitempty"`

	// The intended type of device that is to be used for the administration of the
	// enteral formula.
	DeliveryDeviceCodeableConcept *CodeableConcept `json:"deliveryDeviceCodeableConcept,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The maximum total quantity of formula feeding that may be administered to a
	// subject over the period of time, e.g. 1440 mL over 24 hours.
	MaxVolumeToAdminister *Quantity `json:"maxVolumeToAdminister,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The product or brand name of the enteral feeding product such as "ACME Adult
	// Standard Formula".
	ProductName_2 *String `json:"productName,omitempty"`

	// The administration into the patient's gastrointestinal  tract for purposes of
	// providing the formula feeding, e.g. nasogastric tube, oral.
	RouteOfAdministration []CodeableConcept `json:"routeOfAdministration,omitempty"`

	// The type of adult or pediatric enteral feeding such as an adult standard
	// formula with fiber or a soy-based infant feeding.
	Type *CodeableReference `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionOrderEnteralFormula) UnmarshalJSON(value []byte) error {
	type Plain NutritionOrderEnteralFormula
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeliveryDeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DeliveryDeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeliveryDeviceCanonical_2", `^\S*$`)
		}
	}
	*j = NutritionOrderEnteralFormula(plain)
	return nil
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderNutrient struct {
	// The quantity of the specified nutrient to include in diet.
	Amount *Quantity `json:"amount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The nutrient that is being modified such as carbohydrate or sodium.
	Modifier *CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderOralDiet struct {
	// Extensions for instruction
	Instruction *Element `json:"_instruction,omitempty"`

	// The amount of energy (calories or kilojoules) that the oral diet should
	// provide.  For example, an infant formula feeding of 30 ounces of 20 kcal/ounce
	// (67 kcal/100 mL) formula per day.
	CaloricDensity *Quantity `json:"caloricDensity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Free text or additional instructions or information pertaining to the oral
	// diet.
	Instruction_2 *String `json:"instruction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Defines the quantity and the nutrient modified (for example carbohydrate, fiber
	// or sodium) in the oral diet.
	Nutrient []NutritionOrderNutrient `json:"nutrient,omitempty"`

	// Schedule information for an oral diet.
	Schedule *NutritionOrderSchedule `json:"schedule,omitempty"`

	// Class that describes any texture modifications in addition to the oral diet
	// type required for the patient to safely consume various types of foods (i.e.
	// solid and/or liquid).
	Texture []NutritionOrderTexture `json:"texture,omitempty"`

	// The kind of diet or dietary restriction such as fiber restricted diet or diet
	// for diabetes.
	Type []CodeableConcept `json:"type,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderSchedule struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Indicates whether the diet is only taken when needed within a specific
	// administration schedule.
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// Indicates whether the diet is only taken based on a precondition for taking the
	// diet.
	AsNeededFor *CodeableConcept `json:"asNeededFor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time period and frequency at which the diet should be given.  The diet
	// should be given for the combination of all schedules if more than one schedule
	// is present.
	Timing []Timing `json:"timing,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderSchedule1 struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Indicates whether the supplement is only taken when needed within a specific
	// dosing schedule.
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// Indicates whether the supplement is only taken based on a precondition for
	// taking the supplement.
	AsNeededFor *CodeableConcept `json:"asNeededFor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time period and frequency at which the supplement should be given.  The
	// supplement should be given for the combination of all schedules if more than
	// one schedule is present.
	Timing []Timing `json:"timing,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderSchedule2 struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Indicates whether the enteral feeding is only taken when needed within a
	// specific dosing schedule.
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// Indicates whether the enteral feeding is only taken based on a precondition for
	// taking the enteral feeding.
	AsNeededFor *CodeableConcept `json:"asNeededFor,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time period and frequency at which the enteral feeding should be given.
	// The enteral feeding should be given for the combination of all schedules if
	// more than one schedule is present.
	Timing []Timing `json:"timing,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderSupplement struct {
	// Extensions for instruction
	Instruction *Element `json:"_instruction,omitempty"`

	// Extensions for productName
	ProductName *Element `json:"_productName,omitempty"`

	// The amount of energy (calories or kilojoules) that the supplement should
	// provide per specified volume, typically per ml or fluid oz.  For example, a
	// patient may required a supplement that provides 24 calories per fluid ounce.
	CaloricDensity *Quantity `json:"caloricDensity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Free text or additional instructions or information pertaining to the oral
	// supplement.
	Instruction_2 *String `json:"instruction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The product or brand name of the nutritional supplement such as "Acme Protein
	// Shake".
	ProductName_2 *String `json:"productName,omitempty"`

	// The amount of the nutritional supplement to be given.
	Quantity *Quantity `json:"quantity,omitempty"`

	// Schedule information for a supplement.
	Schedule *NutritionOrderSchedule1 `json:"schedule,omitempty"`

	// The kind of nutritional supplement product required such as a high protein or
	// pediatric clear liquid supplement.
	Type *CodeableReference `json:"type,omitempty"`
}

// A request to supply a diet, formula feeding (enteral) or oral nutritional
// supplement to an individual or group.
type NutritionOrderTexture struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Texture modifications in the addition to the oral diet type that should be
	// made, e.g. easy to chew, chopped, ground, and pureed.
	Modifier *CodeableConcept `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The food (i.e. solid and/or liquid) type(s) (e.g. meats, all foods)  that the
	// texture modification applies to.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionOrder) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in NutritionOrder: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in NutritionOrder: required")
	}
	type Plain NutritionOrder
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionOrder(plain)
	return nil
}

// A food or supplement that is consumed by patients.
type NutritionProduct struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for ingredientSummary
	IngredientSummary *Element `json:"_ingredientSummary,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Nutrition products fall into various categories based on their composition
	// (e.g., Fruit and Grain, Vegetables) or form (e.g., Beverages).
	Category []CodeableConcept `json:"category,omitempty"`

	// Specifies descriptive properties of the nutrition product.
	Characteristic []NutritionProductCharacteristic `json:"characteristic,omitempty"`

	// A code that specifies the product or a textual description if no code is
	// available. This could be such codes as a USDA Branded Food Products Database
	// number, a USDA Food Data Central (FDC) ID number, Universal Product Code (UPC),
	// a Langual code, or a country specific food database code.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []NutritionProductContainedElem `json:"contained,omitempty"`

	// The amount of energy present in the product expressed in kilocalories or
	// kilojoules.
	Energy *Quantity `json:"energy,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Ingredients contained in this product.
	Ingredient []NutritionProductIngredient `json:"ingredient,omitempty"`

	// The textual description of the ingredients in the product.  For example, the
	// following is a concatenated list of the ingredients for a peanut butter would
	// read 'ROASTED PEANUTS, SUGAR, HYDROGENATED VEGETABLE OIL (COTTONSEED, SOYBEAN
	// AND RAPESEED OIL) TO PREVENT SEPARATION, SALT'.
	IngredientSummary_2 *Markdown `json:"ingredientSummary,omitempty"`

	// Conveys instance-level information about this product item. One or several
	// physical, countable instances or occurrences of the product.
	Instance []NutritionProductInstance `json:"instance,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The organisation (manufacturer, representative or legal authorization holder)
	// or person that is responsible for nutrition product.
	Manufacturer []Reference `json:"manufacturer,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments made about the product.
	Note []Annotation `json:"note,omitempty"`

	// The product's nutritional information expressed by the nutrients.
	Nutrient []NutritionProductNutrient `json:"nutrient,omitempty"`

	// This is a NutritionProduct resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of the product.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A food or supplement that is consumed by patients.
type NutritionProductCharacteristic struct {
	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code specifying which characteristic of the product is being described (for
	// example, colour, shape).
	Type CodeableConcept `json:"type"`

	// The actual characteristic value corresponding to the type.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The actual characteristic value corresponding to the type.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The actual characteristic value corresponding to the type.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The actual characteristic value corresponding to the type.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The actual characteristic value corresponding to the type.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The actual characteristic value corresponding to the type.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionProductCharacteristic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NutritionProductCharacteristic: required")
	}
	type Plain NutritionProductCharacteristic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = NutritionProductCharacteristic(plain)
	return nil
}

type NutritionProductContainedElem interface{}

// A food or supplement that is consumed by patients.
type NutritionProductIngredient struct {
	// Extensions for allergen
	Allergen *Element `json:"_allergen,omitempty"`

	// A known or suspected allergenic and/or substance that is associated with an
	// intolerance.
	Allergen_2 *Boolean `json:"allergen,omitempty"`

	// The amount of ingredient that is in the product.
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`

	// The amount of ingredient that is in the product.
	AmountRatio *Ratio `json:"amountRatio,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The ingredient contained in the product.
	Item CodeableReference `json:"item"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionProductIngredient) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in NutritionProductIngredient: required")
	}
	type Plain NutritionProductIngredient
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionProductIngredient(plain)
	return nil
}

// A food or supplement that is consumed by patients.
type NutritionProductInstance struct {
	// Extensions for expiry
	Expiry *Element `json:"_expiry,omitempty"`

	// Extensions for lotNumber
	LotNumber *Element `json:"_lotNumber,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for useBy
	UseBy *Element `json:"_useBy,omitempty"`

	// An identifier of the donation, collection, or pooling event from which
	// biological material in this nutrition product was derived.
	BiologicalSourceEvent *Identifier `json:"biologicalSourceEvent,omitempty"`

	// The time after which the product is no longer expected to be in proper
	// condition, or its use is not advised or not allowed.
	Expiry_2 *DateTime `json:"expiry,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identifier for the physical instance, typically a serial number or
	// manufacturer number.
	Identifier []Identifier `json:"identifier,omitempty"`

	// The identification of the batch or lot of the product.
	LotNumber_2 *String `json:"lotNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name or brand for the specific product.
	Name_2 *String `json:"name,omitempty"`

	// The amount of items or instances that the resource considers, for instance when
	// referring to 2 identical units together.
	Quantity *Quantity `json:"quantity,omitempty"`

	// The time after which the product is no longer expected to be in proper
	// condition, or its use is not advised or not allowed.
	UseBy_2 *DateTime `json:"useBy,omitempty"`
}

// A food or supplement that is consumed by patients.
type NutritionProductNutrient struct {
	// The amount of nutrient expressed in one or more units, either X per pack / per
	// serving / per dose or X amount.
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`

	// The amount of nutrient expressed in one or more units, either X per pack / per
	// serving / per dose or X amount.
	AmountRatio *Ratio `json:"amountRatio,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The (relevant) nutrients in the product.
	Item CodeableReference `json:"item"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionProductNutrient) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in NutritionProductNutrient: required")
	}
	type Plain NutritionProductNutrient
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionProductNutrient(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NutritionProduct) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in NutritionProduct: required")
	}
	type Plain NutritionProduct
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NutritionProduct(plain)
	return nil
}

// Measurements and simple assertions made about a patient, device or other
// subject.
type Observation struct {
	// Extensions for effectiveDateTime
	EffectiveDateTime *Element `json:"_effectiveDateTime,omitempty"`

	// Extensions for effectiveInstant
	EffectiveInstant *Element `json:"_effectiveInstant,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for issued
	Issued *Element `json:"_issued,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for organizer
	Organizer *Element `json:"_organizer,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this event.
	// For example, a MedicationRequest may require a patient to have laboratory test
	// performed before  it is dispensed.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// DEPRECATED: This element is deprecated. Use bodyStructure instead. Indicates
	// the site on the subject's body where the observation was made (i.e. the target
	// site).
	BodySite *CodeableConcept `json:"bodySite,omitempty"`

	// Indicates the body structure on the subject's body where the observation was
	// made (i.e. the target site).
	BodyStructure *CodeableReference `json:"bodyStructure,omitempty"`

	// A code that classifies the general type of observation being made.
	Category []CodeableConcept `json:"category,omitempty"`

	// Describes what was observed. Sometimes this is called the observation "name".
	Code CodeableConcept `json:"code"`

	// Some observations have multiple component observations.  These component
	// observations are expressed as separate code value pairs that share the same
	// attributes.  Examples include systolic and diastolic component observations for
	// blood pressure measurement and multiple component observations for genetics
	// observations.
	Component []ObservationComponent `json:"component,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ObservationContainedElem `json:"contained,omitempty"`

	// Provides a reason why the expected value in the element Observation.value[x] is
	// missing.
	DataAbsentReason *CodeableConcept `json:"dataAbsentReason,omitempty"`

	// The target resource that represents a measurement from which this observation
	// value is derived. For example, a calculated anion gap or a fetal measurement
	// based on an ultrasound image.
	DerivedFrom []Reference `json:"derivedFrom,omitempty"`

	// A reference to the device that generates the measurements or the device
	// settings for the device.
	Device *Reference `json:"device,omitempty"`

	// The time or time-period the observed value is asserted as being true. For
	// biological subjects - e.g. human patients - this is usually called the
	// "physiologically relevant time". This is usually either the time of the
	// procedure or of specimen collection, but very often the source of the date/time
	// is not known, only the date/time itself.
	EffectiveDateTime_2 *string `json:"effectiveDateTime,omitempty"`

	// The time or time-period the observed value is asserted as being true. For
	// biological subjects - e.g. human patients - this is usually called the
	// "physiologically relevant time". This is usually either the time of the
	// procedure or of specimen collection, but very often the source of the date/time
	// is not known, only the date/time itself.
	EffectiveInstant_2 *string `json:"effectiveInstant,omitempty"`

	// The time or time-period the observed value is asserted as being true. For
	// biological subjects - e.g. human patients - this is usually called the
	// "physiologically relevant time". This is usually either the time of the
	// procedure or of specimen collection, but very often the source of the date/time
	// is not known, only the date/time itself.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// The time or time-period the observed value is asserted as being true. For
	// biological subjects - e.g. human patients - this is usually called the
	// "physiologically relevant time". This is usually either the time of the
	// procedure or of specimen collection, but very often the source of the date/time
	// is not known, only the date/time itself.
	EffectiveTiming *Timing `json:"effectiveTiming,omitempty"`

	// The healthcare event  (e.g. a patient and healthcare provider interaction)
	// during which this observation is made.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual focus of an observation when it is not the subject of record
	// representing something or someone associated with the patient such as a spouse,
	// parent, fetus, or donor. For example, fetus observations in a mother's record.
	// The focus of an observation could also be an existing condition,  an
	// intervention, the subject's diet,  another observation of the subject,  or a
	// body structure such as tumor or implanted device.   An example use case would
	// be using the Observation resource to capture whether the mother is trained to
	// change her child's tracheostomy tube. In this example, the child is the patient
	// of record and the mother is the focus. As another use case,a caregiver
	// (RelatedPerson) has back strain and is unable to provide ADL support to a
	// patient (Subject).
	Focus []Reference `json:"focus,omitempty"`

	// This observation is a group observation (e.g. a battery, a panel of tests, a
	// set of vital sign measurements) that includes the target as a member of the
	// group.
	HasMember []Reference `json:"hasMember,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this observation.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A categorical assessment of an observation value.  For example, high, low,
	// normal.
	Interpretation []CodeableConcept `json:"interpretation,omitempty"`

	// Other preceding or concurrent information that is critical to understand the
	// context and significance of the observation.
	InterpretationContext []CodeableReference `json:"interpretationContext,omitempty"`

	// The date and time this version of the observation was made available to
	// providers, typically after the results have been reviewed and verified.
	Issued_2 *Instant `json:"issued,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// Indicates the mechanism used to perform the observation.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Comments about the observation or the results.
	Note []Annotation `json:"note,omitempty"`

	// This observation serves as an organizer or grouper for a set of (one or more)
	// sub-observations.
	Organizer_2 *Boolean `json:"organizer,omitempty"`

	// A larger event of which this particular Observation is a component or step.
	// For example,  an observation as part of a procedure.
	PartOf []Reference `json:"partOf,omitempty"`

	// Who was responsible for asserting the observed value as "true".
	Performer []Reference `json:"performer,omitempty"`

	// Guidance on how to interpret the value by comparison to a normal or recommended
	// range.  Multiple reference ranges are interpreted as an "OR".   In other words,
	// to represent two distinct target populations, two `referenceRange` elements
	// would be used.
	ReferenceRange []ObservationReferenceRange `json:"referenceRange,omitempty"`

	// This is a Observation resource
	ResourceType interface{} `json:"resourceType"`

	// The specimen that was used when this observation was made.
	Specimen *Reference `json:"specimen,omitempty"`

	// The status of the result value.
	Status_2 *Code `json:"status,omitempty"`

	// The patient, or group of patients, location, device, organization, procedure or
	// practitioner this observation is about and into whose or what record the
	// observation is placed. If the actual focus of the observation is different from
	// the subject (or a sample of, part, or region of the subject), the `focus`
	// element or the `code` itself specifies the actual focus of the observation.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Identifies the observation(s) that triggered the performance of this
	// observation.
	TriggeredBy []ObservationTriggeredBy `json:"triggeredBy,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueTime_2 *string `json:"valueTime,omitempty"`
}

// Measurements and simple assertions made about a patient, device or other
// subject.
type ObservationComponent struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Describes what was observed. Sometimes this is called the observation "code".
	Code CodeableConcept `json:"code"`

	// Provides a reason why the expected value in the element
	// Observation.component.value[x] is missing.
	DataAbsentReason *CodeableConcept `json:"dataAbsentReason,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A categorical assessment of an observation value.  For example, high, low,
	// normal.
	Interpretation []CodeableConcept `json:"interpretation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Guidance on how to interpret the value by comparison to a normal or recommended
	// range.
	ReferenceRange []ObservationReferenceRange `json:"referenceRange,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	ValueTime_2 *string `json:"valueTime,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObservationComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ObservationComponent: required")
	}
	type Plain ObservationComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	*j = ObservationComponent(plain)
	return nil
}

type ObservationContainedElem interface{}

// Set of definitional characteristics for a kind of observation or measurement
// produced or consumed by an orderable health care service.
type ObservationDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for derivedFromUri
	DerivedFromUri []Element `json:"_derivedFromUri,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for deviceCanonical
	DeviceCanonical *Element `json:"_deviceCanonical,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for multipleResultsAllowed
	MultipleResultsAllowed *Element `json:"_multipleResultsAllowed,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for permittedDataType
	PermittedDataType []Element `json:"_permittedDataType,omitempty"`

	// Extensions for preferredReportName
	PreferredReportName *Element `json:"_preferredReportName,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the asset content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the {{title}}.
	Author []ContactDetail `json:"author,omitempty"`

	// The body structure on the subject's body where the observation is to be made.
	BodyStructure *CodeableReference `json:"bodyStructure,omitempty"`

	// A code that classifies the general type of observation.
	Category []CodeableConcept `json:"category,omitempty"`

	// Describes what will be observed. Sometimes this is called the observation
	// "name".
	Code CodeableConcept `json:"code"`

	// Some observations have multiple component observations, expressed as separate
	// code value pairs.
	Component []ObservationDefinitionComponent `json:"component,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ObservationDefinitionContainedElem `json:"contained,omitempty"`

	// Copyright statement relating to the ObservationDefinition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the ObservationDefinition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date (and optionally time) when the ObservationDefinition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the ObservationDefinition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// The canonical URL pointing to another FHIR-defined ObservationDefinition that
	// is adhered to in whole or in part by this definition.
	DerivedFromCanonical []Canonical `json:"derivedFromCanonical,omitempty"`

	// The URL pointing to an externally-defined observation definition, guideline or
	// other definition that is adhered to in whole or in part by this definition.
	DerivedFromUri_2 []Uri `json:"derivedFromUri,omitempty"`

	// A free text natural language description of the ObservationDefinition from the
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// The measurement model of device or actual device used to produce observations
	// of this type.
	DeviceCanonical_2 *string `json:"deviceCanonical,omitempty"`

	// The measurement model of device or actual device used to produce observations
	// of this type.
	DeviceReference *Reference `json:"deviceReference,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the {{title}}.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the ObservationDefinition content was or is planned to
	// be effective.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the {{title}} for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A flag to indicate that this ObservationDefinition is authored for testing
	// purposes (or education/evaluation/marketing), and is not intended to be used
	// for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// This ObservationDefinition defines a group  observation (e.g. a battery, a
	// panel of tests, a set of vital sign measurements) that includes the target as a
	// member of the group.
	HasMember []Reference `json:"hasMember,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this ObservationDefinition. by the performer
	// and/or other systems. These identifiers remain constant as the resource is
	// updated and propagates from server to server.
	Identifier *Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A jurisdiction in which the ObservationDefinition is intended to be used.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the asset content was last reviewed. Review happens
	// periodically after that, but doesn't change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The method or technique used to perform the observation.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Multiple results allowed for observations conforming to this
	// ObservationDefinition.
	MultipleResultsAllowed_2 *Boolean `json:"multipleResultsAllowed,omitempty"`

	// A natural language name identifying the ObservationDefinition. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The type of individual/organization/device that is expected to act upon
	// instances of this definition.
	PerformerType *CodeableConcept `json:"performerType,omitempty"`

	// The data types allowed for the value element of the instance observations
	// conforming to this ObservationDefinition.
	PermittedDataType_2 []Code `json:"permittedDataType,omitempty"`

	// Units allowed for the valueQuantity element in the instance observations
	// conforming to this ObservationDefinition.
	PermittedUnit []Coding `json:"permittedUnit,omitempty"`

	// The preferred name to be used when reporting the results of observations
	// conforming to this ObservationDefinition.
	PreferredReportName_2 *String `json:"preferredReportName,omitempty"`

	// Helps establish the "authority/credibility" of the ObservationDefinition. May
	// also allow for contact.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explains why this ObservationDefinition is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// A set of qualified values associated with a context and a set of conditions -
	// provides a range for quantitative and ordinal observations and a collection of
	// value sets for qualitative observations.
	QualifiedValue []ObservationDefinitionQualifiedValue `json:"qualifiedValue,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a ObservationDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the {{title}}.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The kind of specimen that this type of observation is produced on.
	Specimen []Reference `json:"specimen,omitempty"`

	// The current state of the ObservationDefinition.
	Status_2 *Code `json:"status,omitempty"`

	// A code that describes the intended kind of subject of Observation instances
	// conforming to this ObservationDefinition.
	Subject []CodeableConcept `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the ObservationDefinition.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the {{title}}. Topics provide a
	// high-level categorization as well as keywords for the {{title}} that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URL that is used to identify this ObservationDefinition when it is
	// referenced in a specification, model, design or an instance. This SHALL be a
	// URL, SHOULD be globally unique, and SHOULD be an address at which this
	// ObservationDefinition is (or will be) published. The URL SHOULD include the
	// major version of the ObservationDefinition. For more information see Technical
	// and Business Versions.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate
	// ObservationDefinition instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the
	// ObservationDefinition when it is referenced in a specification, model, design
	// or instance. This is an arbitrary value managed by the ObservationDefinition
	// author and is not expected to be globally unique. For example, it might be a
	// timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
	// no expectation that versions are orderable.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// Set of definitional characteristics for a kind of observation or measurement
// produced or consumed by an orderable health care service.
type ObservationDefinitionComponent struct {
	// Extensions for permittedDataType
	PermittedDataType []Element `json:"_permittedDataType,omitempty"`

	// Describes what will be observed.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The data types allowed for the value element of the instance of this component
	// observations.
	PermittedDataType_2 []Code `json:"permittedDataType,omitempty"`

	// Units allowed for the valueQuantity element in the instance observations
	// conforming to this ObservationDefinition.
	PermittedUnit []Coding `json:"permittedUnit,omitempty"`

	// A set of qualified values associated with a context and a set of conditions -
	// provides a range for quantitative and ordinal observations and a collection of
	// value sets for qualitative observations.
	QualifiedValue []ObservationDefinitionQualifiedValue `json:"qualifiedValue,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObservationDefinitionComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ObservationDefinitionComponent: required")
	}
	type Plain ObservationDefinitionComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ObservationDefinitionComponent(plain)
	return nil
}

type ObservationDefinitionContainedElem interface{}

// Set of definitional characteristics for a kind of observation or measurement
// produced or consumed by an orderable health care service.
type ObservationDefinitionQualifiedValue struct {
	// Extensions for condition
	Condition *Element `json:"_condition,omitempty"`

	// Extensions for rangeCategory
	RangeCategory *Element `json:"_rangeCategory,omitempty"`

	// Extensions for sexParameterForClinicalUse
	SexParameterForClinicalUse *Element `json:"_sexParameterForClinicalUse,omitempty"`

	// The set of abnormal coded results for qualitative observations  that match the
	// criteria of this set of qualified values.
	AbnormalCodedValueSet *Canonical `json:"abnormalCodedValueSet,omitempty"`

	// The age range this  set of qualified values applies to.
	Age *Range `json:"age,omitempty"`

	// The target population this  set of qualified values applies to.
	AppliesTo []CodeableConcept `json:"appliesTo,omitempty"`

	// Description of the criterion for which the qualified value is valid.
	Condition_2 *String `json:"condition,omitempty"`

	// A concept defining the context for this set of qualified values.
	Context *CodeableConcept `json:"context,omitempty"`

	// The set of critical coded results for qualitative observations  that match the
	// criteria of this set of qualified values.
	CriticalCodedValueSet *Canonical `json:"criticalCodedValueSet,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The gestational age this  set of qualified values applies to.
	GestationalAge *Range `json:"gestationalAge,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The expected coded interpretation values of an observation that matches this
	// qualified interval. For example, high, low, normal.
	Interpretation []CodeableConcept `json:"interpretation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The set of normal coded results for qualitative observations  that match the
	// criteria of this set of qualified values.
	NormalCodedValueSet *Canonical `json:"normalCodedValueSet,omitempty"`

	// The range of values defined for continuous or ordinal observations that match
	// the criteria of this set of qualified values.
	Range *Range `json:"range,omitempty"`

	// The category of range of values for continuous or ordinal observations that
	// match the criteria of this set of qualified values.
	RangeCategory_2 *Code `json:"rangeCategory,omitempty"`

	// The sex parameter for clinical use this set of qualified values applies to.
	SexParameterForClinicalUse_2 *Code `json:"sexParameterForClinicalUse,omitempty"`

	// The set of valid coded results for qualitative observations  that match the
	// criteria of this set of qualified values.
	ValidCodedValueSet *Canonical `json:"validCodedValueSet,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObservationDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ObservationDefinition: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ObservationDefinition: required")
	}
	type Plain ObservationDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeviceCanonical_2", `^\S*$`)
		}
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ObservationDefinition(plain)
	return nil
}

// Measurements and simple assertions made about a patient, device or other
// subject.
type ObservationReferenceRange struct {
	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// The age at which this reference range is applicable. This is a neonatal age
	// (e.g. number of weeks at term) if the meaning says so.
	Age *Range `json:"age,omitempty"`

	// Codes to indicate the target population this reference range applies to.  For
	// example, a reference range may be based on the normal population or a
	// particular sex or race.  Multiple `appliesTo`  are interpreted as an "AND" of
	// the target populations.  For example, to represent a target population of
	// African American females, both a code of female and a code for African American
	// would be used.
	AppliesTo []CodeableConcept `json:"appliesTo,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The value of the high bound of the reference range.
	High *Quantity `json:"high,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The value of the low bound of the reference range.
	Low *Quantity `json:"low,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The value of the normal value of the reference range.
	NormalValue *CodeableConcept `json:"normalValue,omitempty"`

	// Text based reference range in an observation which may be used when a
	// quantitative range is not appropriate for an observation.  An example would be
	// a reference value of "Negative" or a list or table of "normals".
	Text_2 *Markdown `json:"text,omitempty"`

	// Codes to indicate the what part of the targeted reference population it applies
	// to. For example, the normal or therapeutic range.
	Type *CodeableConcept `json:"type,omitempty"`
}

// Measurements and simple assertions made about a patient, device or other
// subject.
type ObservationTriggeredBy struct {
	// Extensions for reason
	Reason *Element `json:"_reason,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the triggering observation.
	Observation Reference `json:"observation"`

	// Provides the reason why this observation was performed as a result of the
	// observation(s) referenced.
	Reason_2 *String `json:"reason,omitempty"`

	// The type of trigger.
	// Reflex | Repeat | Re-run.
	Type_2 *Code `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObservationTriggeredBy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["observation"]; raw != nil && !ok {
		return fmt.Errorf("field observation in ObservationTriggeredBy: required")
	}
	type Plain ObservationTriggeredBy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ObservationTriggeredBy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Observation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in Observation: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Observation: required")
	}
	type Plain Observation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EffectiveDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.EffectiveDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectiveDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.EffectiveInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.EffectiveInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectiveInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	*j = Observation(plain)
	return nil
}

// An OID represented as a URI
type Oid string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oid) UnmarshalJSON(value []byte) error {
	type Plain Oid
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
	}
	*j = Oid(plain)
	return nil
}

// A formal computable definition of an operation (on the RESTful interface) or a
// named query (using the search interaction).
type OperationDefinition struct {
	// Extensions for affectsState
	AffectsState *Element `json:"_affectsState,omitempty"`

	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for instance
	Instance *Element `json:"_instance,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for resource
	Resource []Element `json:"_resource,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for synchronicity
	Synchronicity *Element `json:"_synchronicity,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Whether the operation affects state. Side effects such as producing audit trail
	// entries do not count as 'affecting  state'.
	AffectsState_2 *Boolean `json:"affectsState,omitempty"`

	// Indicates that this operation definition is a constraining profile on the base.
	Base *Canonical `json:"base,omitempty"`

	// The label that is recommended to be used in the URL for this operation. In some
	// cases, servers may need to use a different CapabilityStatement operation.name
	// to differentiate between multiple SearchParameters that happen to have the same
	// code.
	Code_2 *Code `json:"code,omitempty"`

	// Additional information about how to use this operation or named query.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []OperationDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the operation definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the operation definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the operation definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the operation definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the operation definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this operation definition is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this implementation guide when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Additional validation information for the in parameters - a single profile that
	// covers all the parameters. The profile is a constraint on the parameters
	// resource as a whole.
	InputProfile *Canonical `json:"inputProfile,omitempty"`

	// Indicates whether this operation can be invoked on a particular instance of one
	// of the given types.
	Instance_2 *Boolean `json:"instance,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// Whether this is an operation or a named query.
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the operation definition. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Additional validation information for the out parameters - a single profile
	// that covers all the parameters. The profile is a constraint on the parameters
	// resource.
	OutputProfile *Canonical `json:"outputProfile,omitempty"`

	// Defines an appropriate combination of parameters to use when invoking this
	// operation, to help code generators when generating overloaded parameter sets
	// for this operation.
	Overload []OperationDefinitionOverload `json:"overload,omitempty"`

	// The parameters for the operation/query.
	Parameter []OperationDefinitionParameter `json:"parameter,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the operation definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this operation definition is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// The types on which this operation can be executed.
	Resource_2 []Code `json:"resource,omitempty"`

	// This is a OperationDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of this operation definition.
	Status_2 *Code `json:"status,omitempty"`

	// Indicates that this operation must always be handled as synchronous or
	// asynchronous, or that the server must provide both options, and clients can
	// choose.
	Synchronicity_2 *Code `json:"synchronicity,omitempty"`

	// Indicates whether this operation or named query can be invoked at the system
	// level (e.g. without needing to choose a resource type for the context).
	System_2 *Boolean `json:"system,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the operation definition.
	Title_2 *String `json:"title,omitempty"`

	// Indicates whether this operation or named query can be invoked at the resource
	// type level for any given resource type level (e.g. without needing to choose a
	// specific resource id for the context).
	Type_2 *Boolean `json:"type,omitempty"`

	// An absolute URI that is used to identify this operation definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this operation definition is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the operation definition is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate operation
	// definition.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the operation
	// definition when it is referenced in a specification, model, design or instance.
	// This is an arbitrary value managed by the operation definition author and is
	// not expected to be globally unique. For example, it might be a timestamp (e.g.
	// yyyymmdd) if a managed version is not available. There is also no expectation
	// that versions can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A formal computable definition of an operation (on the RESTful interface) or a
// named query (using the search interaction).
type OperationDefinitionBinding struct {
	// Extensions for strength
	Strength *Element `json:"_strength,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates the degree of conformance expectations associated with this binding -
	// that is, the degree to which the provided value set must be adhered to in the
	// instances.
	Strength_2 *Code `json:"strength,omitempty"`

	// Points to the value set or external definition (e.g. implicit value set) that
	// identifies the set of codes to be used.
	ValueSet Canonical `json:"valueSet"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationDefinitionBinding) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["valueSet"]; raw != nil && !ok {
		return fmt.Errorf("field valueSet in OperationDefinitionBinding: required")
	}
	type Plain OperationDefinitionBinding
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OperationDefinitionBinding(plain)
	return nil
}

type OperationDefinitionContainedElem interface{}

// A formal computable definition of an operation (on the RESTful interface) or a
// named query (using the search interaction).
type OperationDefinitionOverload struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for parameterName
	ParameterName []Element `json:"_parameterName,omitempty"`

	// Comments to go on overload.
	Comment_2 *String `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of parameter to include in overload.
	ParameterName_2 []String `json:"parameterName,omitempty"`
}

// A formal computable definition of an operation (on the RESTful interface) or a
// named query (using the search interaction).
type OperationDefinitionParameter struct {
	// Extensions for allowedType
	AllowedType []Element `json:"_allowedType,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for scope
	Scope []Element `json:"_scope,omitempty"`

	// Extensions for searchType
	SearchType *Element `json:"_searchType,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// Support for polymorphic types. If the parameter type is abstract, this element
	// lists allowed sub-types for the parameter.
	AllowedType_2 []Code `json:"allowedType,omitempty"`

	// Binds to a value set if this parameter is coded (code, Coding,
	// CodeableConcept).
	Binding *OperationDefinitionBinding `json:"binding,omitempty"`

	// Describes the meaning or use of this parameter.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The maximum number of times this element is permitted to appear in the request
	// or response.
	Max_2 *String `json:"max,omitempty"`

	// The minimum number of times this parameter SHALL appear in the request or
	// response.
	Min_2 *UnsignedInt `json:"min,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name of used to identify the parameter.
	Name_2 *Code `json:"name,omitempty"`

	// The parts of a nested Parameter.
	Part []OperationDefinitionParameter `json:"part,omitempty"`

	// Identifies other resource parameters within the operation invocation that are
	// expected to resolve to this resource.
	ReferencedFrom []OperationDefinitionReferencedFrom `json:"referencedFrom,omitempty"`

	// If present, indicates that the parameter applies when the operation is being
	// invoked at the specified level.
	Scope_2 []Code `json:"scope,omitempty"`

	// How the parameter is understood if/when it used as search parameter. This is
	// only used if the parameter is a string.
	SearchType_2 *Code `json:"searchType,omitempty"`

	// Used when the type is "Reference" or "canonical", and identifies a profile
	// structure or implementation Guide that applies to the target of the reference
	// this parameter refers to. If any profiles are specified, then the content must
	// conform to at least one of them. The URL can be a local reference - to a
	// contained StructureDefinition, or a reference to another StructureDefinition or
	// Implementation Guide by a canonical URL. When an implementation guide is
	// specified, the target resource SHALL conform to at least one profile defined in
	// the implementation guide.
	TargetProfile []Canonical `json:"targetProfile,omitempty"`

	// The type for this parameter.
	Type_2 *Code `json:"type,omitempty"`

	// Whether this is an input or an output parameter.
	Use_2 *Code `json:"use,omitempty"`
}

// A formal computable definition of an operation (on the RESTful interface) or a
// named query (using the search interaction).
type OperationDefinitionReferencedFrom struct {
	// Extensions for source
	Source *Element `json:"_source,omitempty"`

	// Extensions for sourceId
	SourceID *Element `json:"_sourceId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name of the parameter or dot-separated path of parameter names pointing to
	// the resource parameter that is expected to contain a reference to this
	// resource.
	Source_2 *String `json:"source,omitempty"`

	// The id of the element in the referencing resource that is expected to resolve
	// to this resource.
	SourceID_2 *String `json:"sourceId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in OperationDefinition: required")
	}
	type Plain OperationDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = OperationDefinition(plain)
	return nil
}

// A collection of error, warning, or information messages that result from a
// system action.
type OperationOutcome struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []OperationOutcomeContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// An error, warning, or information message that results from a system action.
	Issue []OperationOutcomeIssue `json:"issue"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This is a OperationOutcome resource
	ResourceType interface{} `json:"resourceType"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type OperationOutcomeContainedElem interface{}

// A collection of error, warning, or information messages that result from a
// system action.
type OperationOutcomeIssue struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for diagnostics
	Diagnostics *Element `json:"_diagnostics,omitempty"`

	// Extensions for expression
	Expression []Element `json:"_expression,omitempty"`

	// Extensions for location
	Location []Element `json:"_location,omitempty"`

	// Extensions for severity
	Severity *Element `json:"_severity,omitempty"`

	// Describes the type of the issue. The system that creates an OperationOutcome
	// SHALL choose the most applicable code from the IssueType value set, and may
	// additional provide its own code for the error in the details element.
	Code_2 *Code `json:"code,omitempty"`

	// Additional details about the error. This may be a text description of the error
	// or a system code that identifies the error.
	Details *CodeableConcept `json:"details,omitempty"`

	// Additional diagnostic information about the issue.
	Diagnostics_2 *String `json:"diagnostics,omitempty"`

	// A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names,
	// repetition indicators and the default child accessor that identifies one of the
	// elements in the resource that caused this issue to be raised.
	Expression_2 []String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// This element is deprecated because it is XML specific. It is replaced by
	// issue.expression, which is format independent, and simpler to parse.
	//
	// For resource issues, this will be a simple XPath limited to element names,
	// repetition indicators and the default child accessor that identifies one of the
	// elements in the resource that caused this issue to be raised.  For HTTP errors,
	// will be "http." + the parameter name.
	Location_2 []String `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether the issue indicates a variation from successful processing.
	Severity_2 *Code `json:"severity,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationOutcome) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["issue"]; raw != nil && !ok {
		return fmt.Errorf("field issue in OperationOutcome: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in OperationOutcome: required")
	}
	type Plain OperationOutcome
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OperationOutcome(plain)
	return nil
}

// A formally or informally recognized grouping of people or organizations formed
// for the purpose of achieving some form of collective action.
type Organization struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for alias
	Alias []Element `json:"_alias,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Whether the organization's record is still in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// A list of alternate names that the organization is known as, or was known as in
	// the past.
	Alias_2 []String `json:"alias,omitempty"`

	// The contact details of communication devices available relevant to the specific
	// Organization. This can include addresses, phone numbers, fax numbers, mobile
	// numbers, email addresses and web sites.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []OrganizationContainedElem `json:"contained,omitempty"`

	// Description of the organization, which helps provide additional general context
	// on the organization to ensure that the correct organization is selected.
	Description_2 *Markdown `json:"description,omitempty"`

	// Technical endpoints providing access to services operated for the organization.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for the organization that is used to identify the organization
	// across multiple disparate systems.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name associated with the organization.
	Name_2 *String `json:"name,omitempty"`

	// The organization of which this organization forms a part.
	PartOf *Reference `json:"partOf,omitempty"`

	// The official certifications, accreditations, training, designations and
	// licenses that authorize and/or otherwise endorse the provision of care by the
	// organization.For example, an approval to provide a type of services issued by
	// a certifying body (such as the US Joint Commission) to an organization.
	Qualification []OrganizationQualification `json:"qualification,omitempty"`

	// This is a Organization resource
	ResourceType interface{} `json:"resourceType"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The kind(s) of organization that this is.
	Type []CodeableConcept `json:"type,omitempty"`
}

// Defines an affiliation/association/relationship between 2 distinct
// organizations, that is not a part-of relationship/sub-division relationship.
type OrganizationAffiliation struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Whether this organization affiliation record is in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// Definition of the role the participatingOrganization plays in the association.
	Code []CodeableConcept `json:"code,omitempty"`

	// The contact details of communication devices available at the
	// participatingOrganization relevant to this Affiliation.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []OrganizationAffiliationContainedElem `json:"contained,omitempty"`

	// Technical endpoints providing access to services operated for this role.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Healthcare services provided through the role.
	HealthcareService []Reference `json:"healthcareService,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers that are specific to this role.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The location(s) at which the role occurs.
	Location []Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The network in which the participatingOrganization provides the role's services
	// (if defined) at the indicated locations (if defined).
	Network []Reference `json:"network,omitempty"`

	// Organization where the role is available (primary organization/has members).
	Organization *Reference `json:"organization,omitempty"`

	// The Participating Organization provides/performs the role(s) defined by the
	// code to the Primary Organization (e.g. providing services or is a member of).
	ParticipatingOrganization *Reference `json:"participatingOrganization,omitempty"`

	// The period during which the participatingOrganization is affiliated with the
	// primary organization.
	Period *Period `json:"period,omitempty"`

	// This is a OrganizationAffiliation resource
	ResourceType interface{} `json:"resourceType"`

	// Specific specialty of the participatingOrganization in the context of the role.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type OrganizationAffiliationContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrganizationAffiliation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in OrganizationAffiliation: required")
	}
	type Plain OrganizationAffiliation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OrganizationAffiliation(plain)
	return nil
}

type OrganizationContainedElem interface{}

// A formally or informally recognized grouping of people or organizations formed
// for the purpose of achieving some form of collective action.
type OrganizationQualification struct {
	// Coded representation of the qualification.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier allocated to this qualification for this organization.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Organization that regulates and issues the qualification.
	Issuer *Reference `json:"issuer,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Period during which the qualification is valid.
	Period *Period `json:"period,omitempty"`

	// Qualifications often take time to attain and might be tracked during this time,
	// and completed qualifications might not always be valid. This status concept has
	// some overlap with period and both should be considered together. Refer to the
	// descriptions of the codes for how the period should be interpreted.If a
	// qualification is revoked or otherwise cancelled, then the period is likely to
	// be ignored, and might be related to when it was active.
	Status *CodeableConcept `json:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrganizationQualification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in OrganizationQualification: required")
	}
	type Plain OrganizationQualification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OrganizationQualification(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Organization) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Organization: required")
	}
	type Plain Organization
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Organization(plain)
	return nil
}

// A medically related item or items, in a container or package.
type PackagedProductDefinition struct {
	// Extensions for copackagedIndicator
	CopackagedIndicator *Element `json:"_copackagedIndicator,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for statusDate
	StatusDate *Element `json:"_statusDate,omitempty"`

	// Additional information or supporting documentation about the packaged product.
	AttachedDocument []Reference `json:"attachedDocument,omitempty"`

	// Allows the key features to be recorded, such as "hospital pack", "nurse
	// prescribable", "calendar pack".
	Characteristic []PackagedProductDefinitionProperty `json:"characteristic,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PackagedProductDefinitionContainedElem `json:"contained,omitempty"`

	// A total of the complete count of contained items of a particular type/form,
	// independent of sub-packaging or organization. This can be considered as the
	// pack size. This attribute differs from containedItem.amount in that it can give
	// a single aggregated count of all tablet types in a pack, even when these are
	// different manufactured items. For example a pill pack of 21 tablets plus 7
	// sugar tablets, can be denoted here as '28 tablets'. This attribute is
	// repeatable so that the different item types in one pack type can be counted
	// (e.g. a count of vials and count of syringes). Each repeat must have different
	// units, so that it is clear what the different sets of counted items are, and it
	// is not intended to allow different counts of similar items (e.g. not '2 tubes
	// and 3 tubes'). Repeats are not to be used to represent different pack sizes
	// (e.g. 20 pack vs. 50 pack) - which would be different instances of this
	// resource.
	ContainedItemQuantity []Quantity `json:"containedItemQuantity,omitempty"`

	// Identifies if the package contains different items, such as when a drug product
	// is supplied with another item e.g. a diluent or adjuvant.
	CopackagedIndicator_2 *Boolean `json:"copackagedIndicator,omitempty"`

	// Textual description. Note that this is not the name of the package or product.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier for this package as whole - not the content of the package.
	// Unique instance identifiers assigned to a package by manufacturers, regulators,
	// drug catalogue custodians or other organizations.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The legal status of supply of the packaged item as classified by the regulator.
	LegalStatusOfSupply []PackagedProductDefinitionLegalStatusOfSupply `json:"legalStatusOfSupply,omitempty"`

	// Manufacturer of this package type. When there are multiple it means these are
	// all possible manufacturers.
	Manufacturer []Reference `json:"manufacturer,omitempty"`

	// Allows specifying that an item is on the market for sale, or that it is not
	// available, and the dates and locations associated.
	MarketingStatus []MarketingStatus `json:"marketingStatus,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name for this package. Typically what it would be listed as in a drug
	// formulary or catalogue, inventory etc.
	Name_2 *String `json:"name,omitempty"`

	// The product this package model relates to, not the contents of the package (for
	// which see package.containedItem).
	PackageFor []Reference `json:"packageFor,omitempty"`

	// A packaging item, as a container for medically related items, possibly with
	// other packaging items within, or a packaging component, such as bottle cap
	// (which is not a device or a medication manufactured item).
	Packaging *PackagedProductDefinitionPackaging `json:"packaging,omitempty"`

	// This is a PackagedProductDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// The status within the lifecycle of this item. A high level status, this is not
	// intended to duplicate details carried elsewhere such as legal status, or
	// authorization or marketing status.
	Status *CodeableConcept `json:"status,omitempty"`

	// The date at which the given status became applicable.
	StatusDate_2 *DateTime `json:"statusDate,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A high level category e.g. medicinal product, raw material, shipping/transport
	// container, etc.
	Type *CodeableConcept `json:"type,omitempty"`
}

type PackagedProductDefinitionContainedElem interface{}

// A medically related item or items, in a container or package.
type PackagedProductDefinitionContainedItem struct {
	// The number of this type of item within this packaging or for continuous items
	// such as liquids it is the quantity (for example 25ml). See also
	// PackagedProductDefinition.containedItemQuantity (especially the long
	// definition).
	Amount *Quantity `json:"amount,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The actual item(s) of medication, as manufactured, or a device (typically, but
	// not necessarily, a co-packaged one), or other medically related item (such as
	// food, biologicals, raw materials, medical fluids, gases etc.), as contained in
	// the package. This also allows another whole packaged product to be included,
	// which is solely for the case where a package of other entire packages is wanted
	// - such as a wholesale or distribution pack (for layers within one package, use
	// PackagedProductDefinition.packaging.packaging).
	Item CodeableReference `json:"item"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PackagedProductDefinitionContainedItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in PackagedProductDefinitionContainedItem: required")
	}
	type Plain PackagedProductDefinitionContainedItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PackagedProductDefinitionContainedItem(plain)
	return nil
}

// A medically related item or items, in a container or package.
type PackagedProductDefinitionLegalStatusOfSupply struct {
	// The actual status of supply. Conveys in what situation this package type may be
	// supplied for use.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The place where the legal status of supply applies. When not specified, this
	// indicates it is unknown in this context.
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A medically related item or items, in a container or package.
type PackagedProductDefinitionPackaging struct {
	// Extensions for componentPart
	ComponentPart *Element `json:"_componentPart,omitempty"`

	// Extensions for quantity
	Quantity *Element `json:"_quantity,omitempty"`

	// A possible alternate material for this part of the packaging, that is allowed
	// to be used instead of the usual material (e.g. different types of plastic for a
	// blister sleeve).
	AlternateMaterial []CodeableConcept `json:"alternateMaterial,omitempty"`

	// Is this a part of the packaging (e.g. a cap or bottle stopper), rather than the
	// packaging itself (e.g. a bottle or vial). The latter type are designed be a
	// container, but the former are not.
	ComponentPart_2 *Boolean `json:"componentPart,omitempty"`

	// The item(s) within the packaging.
	ContainedItem []PackagedProductDefinitionContainedItem `json:"containedItem,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A business identifier that is specific to this particular part of the
	// packaging, often assigned by the manufacturer. Including possibly Data Carrier
	// Identifier (a GS1 barcode).
	Identifier []Identifier `json:"identifier,omitempty"`

	// Manufacturer of this packaging item. When there are multiple values each one is
	// a potential manufacturer of this packaging item.
	Manufacturer []Reference `json:"manufacturer,omitempty"`

	// Material type of the package item.
	Material []CodeableConcept `json:"material,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Allows containers (and parts of containers) within containers, still as a part
	// of a single packaged product. See also
	// PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
	Packaging []PackagedProductDefinitionPackaging `json:"packaging,omitempty"`

	// General characteristics of this item.
	Property []PackagedProductDefinitionProperty `json:"property,omitempty"`

	// The quantity of packaging items contained at this layer of the package. This
	// does not relate to the number of contained items but relates solely to the
	// number of packaging items. When looking at the outermost layer it is always 1.
	// If there are two boxes within, at the next layer it would be 2.
	Quantity_2 *Integer `json:"quantity,omitempty"`

	// Shelf Life and storage information.
	ShelfLifeStorage []ProductShelfLife `json:"shelfLifeStorage,omitempty"`

	// The physical type of the container of the items.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A medically related item or items, in a container or package.
type PackagedProductDefinitionProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code expressing the type of characteristic.
	Type CodeableConcept `json:"type"`

	// A value for the characteristic.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// A value for the characteristic.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// A value for the characteristic.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value for the characteristic.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A value for the characteristic.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PackagedProductDefinitionProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PackagedProductDefinitionProperty: required")
	}
	type Plain PackagedProductDefinitionProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = PackagedProductDefinitionProperty(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PackagedProductDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in PackagedProductDefinition: required")
	}
	type Plain PackagedProductDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PackagedProductDefinition(plain)
	return nil
}

// The parameters to the module. This collection specifies both the input and
// output parameters. Input parameters are provided by the caller as part of the
// $evaluate operation. Output parameters are included in the GuidanceResponse.
type ParameterDefinition struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for use
	Use *Element `json:"_use,omitempty"`

	// A brief discussion of what the parameter is for and how it is used by the
	// module.
	Documentation_2 *String `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The maximum number of times this element is permitted to appear in the request
	// or response.
	Max_2 *String `json:"max,omitempty"`

	// The minimum number of times this parameter SHALL appear in the request or
	// response.
	Min_2 *Integer `json:"min,omitempty"`

	// The name of the parameter used to allow access to the value of the parameter in
	// evaluation contexts.
	Name_2 *Code `json:"name,omitempty"`

	// If specified, this indicates a profile that the input data must conform to, or
	// that the output data will conform to.
	Profile *Canonical `json:"profile,omitempty"`

	// The type of the parameter.
	Type_2 *Code `json:"type,omitempty"`

	// Whether the parameter is input or output for the module.
	Use_2 *Code `json:"use,omitempty"`
}

// This resource is used to pass information into and back from an operation
// (whether invoked directly from REST or within a messaging environment).  It is
// not persisted or allowed to be referenced by other resources.
type Parameters struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// A parameter passed to or received from the operation.
	Parameter []ParametersParameter `json:"parameter,omitempty"`

	// This is a Parameters resource
	ResourceType interface{} `json:"resourceType"`
}

// This resource is used to pass information into and back from an operation
// (whether invoked directly from REST or within a messaging environment).  It is
// not persisted or allowed to be referenced by other resources.
type ParametersParameter struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name of the parameter (reference to the operation definition).
	Name_2 *String `json:"name,omitempty"`

	// A named part of a multi-part parameter.
	Part []ParametersParameter `json:"part,omitempty"`

	// Conveys the content if the parameter is a whole resource.
	Resource ParametersParameterResource `json:"resource,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueAge *Age `json:"valueAge,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueCount *Count `json:"valueCount,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueID_2 *string `json:"valueId,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// Conveys the content if the parameter is a data type.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// Conveys the content if the parameter is a whole resource.
type ParametersParameterResource interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParametersParameter) UnmarshalJSON(value []byte) error {
	type Plain ParametersParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = ParametersParameter(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parameters) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Parameters: required")
	}
	type Plain Parameters
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Parameters(plain)
	return nil
}

// Demographics and other administrative information about an individual or animal
// that is the subject of potential, past, current, or future health-related care,
// services, or processes.
type Patient struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for birthDate
	BirthDate *Element `json:"_birthDate,omitempty"`

	// Extensions for deceasedBoolean
	DeceasedBoolean *Element `json:"_deceasedBoolean,omitempty"`

	// Extensions for deceasedDateTime
	DeceasedDateTime *Element `json:"_deceasedDateTime,omitempty"`

	// Extensions for gender
	Gender *Element `json:"_gender,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for multipleBirthBoolean
	MultipleBirthBoolean *Element `json:"_multipleBirthBoolean,omitempty"`

	// Extensions for multipleBirthInteger
	MultipleBirthInteger *Element `json:"_multipleBirthInteger,omitempty"`

	// Whether this patient record is in active use.
	// Many systems use this property to mark as non-current patients, such as those
	// that have not been seen for a period of time based on an organization's
	// business rules.
	//
	// It is often used to filter patient lists to exclude inactive patients
	//
	// Deceased patients may also be marked as inactive for the same reasons, but may
	// be active for some time after death.
	Active_2 *Boolean `json:"active,omitempty"`

	// An address for the individual.
	Address []Address `json:"address,omitempty"`

	// The date of birth for the individual.
	BirthDate_2 *Date `json:"birthDate,omitempty"`

	// A language which may be used to communicate with the patient about his or her
	// health.
	Communication []PatientCommunication `json:"communication,omitempty"`

	// A contact party (e.g. guardian, partner, friend) for the patient.
	Contact []PatientContact `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PatientContainedElem `json:"contained,omitempty"`

	// Indicates the date when the individual died, or, if the date is not known or
	// cannot be estimated, a flag indicating the patient is known to be deceased.
	DeceasedBoolean_2 *bool `json:"deceasedBoolean,omitempty"`

	// Indicates the date when the individual died, or, if the date is not known or
	// cannot be estimated, a flag indicating the patient is known to be deceased.
	DeceasedDateTime_2 *string `json:"deceasedDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Administrative Gender - the gender that the patient is considered to have for
	// administration and record keeping purposes.See the [Patient Gender and Sex
	// section](patient.html#gender) for additional information about communicating
	// patient gender and sex.
	Gender_2 *Code `json:"gender,omitempty"`

	// Patient's nominated care provider.
	GeneralPractitioner []Reference `json:"generalPractitioner,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// An identifier for this patient.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Link to a Patient or RelatedPerson resource that concerns the same actual
	// individual.
	Link []PatientLink `json:"link,omitempty"`

	// Organization that is the custodian of the patient record.
	ManagingOrganization *Reference `json:"managingOrganization,omitempty"`

	// This field contains a patient's most recent marital (civil) status.
	MaritalStatus *CodeableConcept `json:"maritalStatus,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether the patient is part of a multiple (boolean) or indicates the
	// actual birth order (integer).  This count is relative to the total of live
	// births and fetal losses, which MAY be tracked in the
	// `patient-multipleBirthTotal` extension.The boolean option for this property
	// can also be used to track that there are known to be multiple fetuses prior to
	// birth.
	MultipleBirthBoolean_2 *bool `json:"multipleBirthBoolean,omitempty"`

	// Indicates whether the patient is part of a multiple (boolean) or indicates the
	// actual birth order (integer).  This count is relative to the total of live
	// births and fetal losses, which MAY be tracked in the
	// `patient-multipleBirthTotal` extension.The boolean option for this property
	// can also be used to track that there are known to be multiple fetuses prior to
	// birth.
	MultipleBirthInteger_2 *float64 `json:"multipleBirthInteger,omitempty"`

	// A name associated with the individual.
	Name []HumanName `json:"name,omitempty"`

	// Image of the patient.
	Photo []Attachment `json:"photo,omitempty"`

	// This is a Patient resource
	ResourceType interface{} `json:"resourceType"`

	// A contact detail (e.g. a telephone number or an email address) by which the
	// individual may be contacted.
	Telecom []ContactPoint `json:"telecom,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Demographics and other administrative information about an individual or animal
// that is the subject of potential, past, current, or future health-related care,
// services, or processes.
type PatientCommunication struct {
	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language which may be used to communicate with the individual.
	Language CodeableConcept `json:"language"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether or not the patient prefers this language (over other
	// languages he masters up a certain level).
	Preferred_2 *Boolean `json:"preferred,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PatientCommunication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["language"]; raw != nil && !ok {
		return fmt.Errorf("field language in PatientCommunication: required")
	}
	type Plain PatientCommunication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PatientCommunication(plain)
	return nil
}

// Demographics and other administrative information about an individual or animal
// that is the subject of potential, past, current, or future health-related care,
// services, or processes.
type PatientContact struct {
	// Extensions for gender
	Gender *Element `json:"_gender,omitempty"`

	// Additional addresses for the contact person.
	AdditionalAddress []Address `json:"additionalAddress,omitempty"`

	// Additional names for the contact person.
	AdditionalName []HumanName `json:"additionalName,omitempty"`

	// Address for the contact person. Alternate/additional addresses for this contact
	// can be found in the `additionalAddress` property.
	Address *Address `json:"address,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Administrative Gender - the gender that the contact person is considered to
	// have for administration and record keeping purposes.
	Gender_2 *Code `json:"gender,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name associated with the contact person. Alternate/additional names for this
	// contact can be found in the `additionalName` property.
	Name *HumanName `json:"name,omitempty"`

	// Organization on behalf of which the contact is acting or for which the contact
	// is working.
	Organization *Reference `json:"organization,omitempty"`

	// The period during which this contact person or organization is valid to be
	// contacted relating to this patient.
	Period *Period `json:"period,omitempty"`

	// The nature of the personal relationship between the patient and the contact
	// person.
	Relationship []CodeableConcept `json:"relationship,omitempty"`

	// The nature of the functional role between the patient and the contact person.
	Role []CodeableConcept `json:"role,omitempty"`

	// A contact detail for the person, e.g. a telephone number or an email address.
	Telecom []ContactPoint `json:"telecom,omitempty"`
}

type PatientContainedElem interface{}

// Demographics and other administrative information about an individual or animal
// that is the subject of potential, past, current, or future health-related care,
// services, or processes.
type PatientLink struct {
	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Link to a Patient or RelatedPerson resource that concerns the same actual
	// individual.
	Other Reference `json:"other"`

	// The type of link between this patient resource and another patient resource.
	Type_2 *Code `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PatientLink) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["other"]; raw != nil && !ok {
		return fmt.Errorf("field other in PatientLink: required")
	}
	type Plain PatientLink
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PatientLink(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Patient) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Patient: required")
	}
	type Plain Patient
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeceasedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.DeceasedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeceasedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = Patient(plain)
	return nil
}

// This resource provides the status of the payment for goods and services
// rendered, and the request and response resource references.
type PaymentNotice struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for paymentDate
	PaymentDate *Element `json:"_paymentDate,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// The amount sent to the payee.
	Amount Money `json:"amount"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PaymentNoticeContainedElem `json:"contained,omitempty"`

	// The date when this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this payment notice.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The party who will receive or has received payment that is the subject of this
	// notification.
	Payee *Reference `json:"payee,omitempty"`

	// A reference to the payment which is the subject of this notice.
	Payment *Reference `json:"payment,omitempty"`

	// The date when the above payment action occurred.
	PaymentDate_2 *Date `json:"paymentDate,omitempty"`

	// A code indicating whether payment has been sent or cleared.
	PaymentStatus *CodeableConcept `json:"paymentStatus,omitempty"`

	// The party who is notified of the payment status.
	Recipient Reference `json:"recipient"`

	// The party who reports the payment notice.
	Reporter *Reference `json:"reporter,omitempty"`

	// Reference of resource for which payment is being made.
	Request *Reference `json:"request,omitempty"`

	// This is a PaymentNotice resource
	ResourceType interface{} `json:"resourceType"`

	// Reference of response to resource for which payment is being made.
	Response *Reference `json:"response,omitempty"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type PaymentNoticeContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentNotice) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in PaymentNotice: required")
	}
	if _, ok := raw["recipient"]; raw != nil && !ok {
		return fmt.Errorf("field recipient in PaymentNotice: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in PaymentNotice: required")
	}
	type Plain PaymentNotice
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PaymentNotice(plain)
	return nil
}

// This resource provides the details including amount of a payment and allocates
// the payment items being paid.
type PaymentReconciliation struct {
	// Extensions for accountNumber
	AccountNumber *Element `json:"_accountNumber,omitempty"`

	// Extensions for authorization
	Authorization *Element `json:"_authorization,omitempty"`

	// Extensions for cardBrand
	CardBrand *Element `json:"_cardBrand,omitempty"`

	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for disposition
	Disposition *Element `json:"_disposition,omitempty"`

	// Extensions for expirationDate
	ExpirationDate *Element `json:"_expirationDate,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for outcome
	Outcome *Element `json:"_outcome,omitempty"`

	// Extensions for processor
	Processor *Element `json:"_processor,omitempty"`

	// Extensions for referenceNumber
	ReferenceNumber *Element `json:"_referenceNumber,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for statusReason
	StatusReason *Element `json:"_statusReason,omitempty"`

	// A portion of the account number, often the last 4 digits, used for verification
	// not charging purposes.
	AccountNumber_2 *String `json:"accountNumber,omitempty"`

	// Distribution of the payment amount for a previously acknowledged payable.
	Allocation []PaymentReconciliationAllocation `json:"allocation,omitempty"`

	// Total payment amount as indicated on the financial instrument.
	Amount *Money `json:"amount,omitempty"`

	// An alphanumeric issued by the processor to confirm the successful issuance of
	// payment.
	Authorization_2 *String `json:"authorization,omitempty"`

	// The card brand such as debit, Visa, Amex etc. used if a card is the method of
	// payment.
	CardBrand_2 *String `json:"cardBrand,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PaymentReconciliationContainedElem `json:"contained,omitempty"`

	// The date when the resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// The date of payment as indicated on the financial instrument.
	Date_2 *Date `json:"date,omitempty"`

	// A human readable description of the status of the request for the
	// reconciliation.
	Disposition_2 *String `json:"disposition,omitempty"`

	// Payment enterer if not the actual payment issuer.
	Enterer *Reference `json:"enterer,omitempty"`

	// The year and month (YYYY-MM) when the instrument, typically card, expires.
	ExpirationDate_2 *Date `json:"expirationDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A code for the form to be used for printing the content.
	FormCode *CodeableConcept `json:"formCode,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this payment reconciliation.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The type of the source such as patient or insurance.
	IssuerType *CodeableConcept `json:"issuerType,omitempty"`

	// The workflow or activity which gave rise to or during which the payment ocurred
	// such as a kiosk, deposit on account, periodic payment etc.
	Kind *CodeableConcept `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The location of the site or device for electronic transfers or physical
	// location for cash payments.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The means of payment such as check, card cash, or electronic funds transfer.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The outcome of a request for a reconciliation.
	Outcome_2 *Code `json:"outcome,omitempty"`

	// Issuer's unique identifier for the payment instrument.
	PaymentIdentifier *Identifier `json:"paymentIdentifier,omitempty"`

	// The party who generated the payment.
	PaymentIssuer *Reference `json:"paymentIssuer,omitempty"`

	// The period of time for which payments have been gathered into this bulk payment
	// for settlement.
	Period *Period `json:"period,omitempty"`

	// A note that describes or explains the processing in a human readable form.
	ProcessNote []PaymentReconciliationProcessNote `json:"processNote,omitempty"`

	// The name of the card processor, etf processor, bank for checks.
	Processor_2 *String `json:"processor,omitempty"`

	// The check number, eft reference, car processor reference.
	ReferenceNumber_2 *String `json:"referenceNumber,omitempty"`

	// Original request resource reference.
	Request *Reference `json:"request,omitempty"`

	// The practitioner who is responsible for the services rendered to the patient.
	Requestor *Reference `json:"requestor,omitempty"`

	// This is a PaymentReconciliation resource
	ResourceType interface{} `json:"resourceType"`

	// The amount returned by the receiver which is excess to the amount payable,
	// often referred to as 'change'.
	ReturnedAmount *Money `json:"returnedAmount,omitempty"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// Used to indicate why the status has changed.
	StatusReason_2 *String `json:"statusReason,omitempty"`

	// The amount offered by the issuer, typically applies to cash when the issuer
	// provides an amount in bank note denominations equal to or excess of the amount
	// actually being paid.
	TenderedAmount *Money `json:"tenderedAmount,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Code to indicate the nature of the payment such as payment, adjustment.
	Type CodeableConcept `json:"type"`
}

// This resource provides the details including amount of a payment and allocates
// the payment items being paid.
type PaymentReconciliationAllocation struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for noteNumber
	NoteNumber []Element `json:"_noteNumber,omitempty"`

	// Extensions for targetItemPositiveInt
	TargetItemPositiveInt *Element `json:"_targetItemPositiveInt,omitempty"`

	// Extensions for targetItemString
	TargetItemString *Element `json:"_targetItemString,omitempty"`

	// The Account to which this payment applies, may be completed by the receiver,
	// used for search.
	Account *Reference `json:"account,omitempty"`

	// The monetary amount allocated from the total payment to the payable.
	Amount *Money `json:"amount,omitempty"`

	// The date from the response resource containing a commitment to pay.
	Date_2 *Date `json:"date,omitempty"`

	// The Encounter to which this payment applies, may be completed by the receiver,
	// used for search.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Unique identifier for the current payment item for the referenced payable.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The numbers associated with notes below which apply to the adjudication of this
	// item.
	NoteNumber_2 []PositiveInt `json:"noteNumber,omitempty"`

	// The party which is receiving the payment.
	Payee *Reference `json:"payee,omitempty"`

	// Unique identifier for the prior payment item for the referenced payable.
	Predecessor *Identifier `json:"predecessor,omitempty"`

	// A resource, such as a ClaimResponse, which contains a commitment to payment.
	Response *Reference `json:"response,omitempty"`

	// A reference to the individual who is responsible for inquiries regarding the
	// response and its payment.
	Responsible *Reference `json:"responsible,omitempty"`

	// The party which submitted the claim or financial transaction.
	Submitter *Reference `json:"submitter,omitempty"`

	// Specific resource to which the payment/adjustment/advance applies.
	Target *Reference `json:"target,omitempty"`

	//  Identifies the claim line item, encounter or other sub-element being paid.
	// Note payment may be partial, that is not match the then outstanding balance or
	// amount incurred.
	TargetItemIdentifier *Identifier `json:"targetItemIdentifier,omitempty"`

	//  Identifies the claim line item, encounter or other sub-element being paid.
	// Note payment may be partial, that is not match the then outstanding balance or
	// amount incurred.
	TargetItemPositiveInt_2 *float64 `json:"targetItemPositiveInt,omitempty"`

	//  Identifies the claim line item, encounter or other sub-element being paid.
	// Note payment may be partial, that is not match the then outstanding balance or
	// amount incurred.
	TargetItemString_2 *string `json:"targetItemString,omitempty"`

	// Code to indicate the nature of the payment.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentReconciliationAllocation) UnmarshalJSON(value []byte) error {
	type Plain PaymentReconciliationAllocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetItemString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetItemString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetItemString_2", `^^[\s\S]+$$`)
		}
	}
	*j = PaymentReconciliationAllocation(plain)
	return nil
}

type PaymentReconciliationContainedElem interface{}

// This resource provides the details including amount of a payment and allocates
// the payment items being paid.
type PaymentReconciliationProcessNote struct {
	// Extensions for number
	Number *Element `json:"_number,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// A code to indicate the business purpose of the note.
	Class *CodeableConcept `json:"class,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A number to uniquely identify a note entry.
	Number_2 *PositiveInt `json:"number,omitempty"`

	// The explanation or description associated with the processing.
	Text_2 *Markdown `json:"text,omitempty"`

	// The business purpose of the note text.
	Type_2 *Code `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentReconciliation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in PaymentReconciliation: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PaymentReconciliation: required")
	}
	type Plain PaymentReconciliation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PaymentReconciliation(plain)
	return nil
}

// A time period defined by a start and end date and optionally time.
type Period struct {
	// Extensions for end
	End *Element `json:"_end,omitempty"`

	// Extensions for start
	Start *Element `json:"_start,omitempty"`

	// The end of the period. If the end of the period is missing, it means no end was
	// known or planned at the time the instance was created. The start may be in the
	// past, and the end date in the future, which means that period is
	// expected/planned to end at that time.
	End_2 *DateTime `json:"end,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The start of the period. The boundary is inclusive.
	Start_2 *DateTime `json:"start,omitempty"`
}

// Demographics and administrative information about a person independent of a
// specific health-related context.
type Person struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for birthDate
	BirthDate *Element `json:"_birthDate,omitempty"`

	// Extensions for deceasedBoolean
	DeceasedBoolean *Element `json:"_deceasedBoolean,omitempty"`

	// Extensions for deceasedDateTime
	DeceasedDateTime *Element `json:"_deceasedDateTime,omitempty"`

	// Extensions for gender
	Gender *Element `json:"_gender,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Whether this person's record is in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// One or more addresses for the person.
	Address []Address `json:"address,omitempty"`

	// The birth date for the person.
	BirthDate_2 *Date `json:"birthDate,omitempty"`

	// A language which may be used to communicate with the person about his or her
	// health.
	Communication []PersonCommunication `json:"communication,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PersonContainedElem `json:"contained,omitempty"`

	// Indicates if the individual is deceased or not.
	DeceasedBoolean_2 *bool `json:"deceasedBoolean,omitempty"`

	// Indicates if the individual is deceased or not.
	DeceasedDateTime_2 *string `json:"deceasedDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Administrative Gender.
	Gender_2 *Code `json:"gender,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for a person within a particular scope.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Link to a resource that concerns the same actual person.
	Link []PersonLink `json:"link,omitempty"`

	// The organization that is the custodian of the person record.
	ManagingOrganization *Reference `json:"managingOrganization,omitempty"`

	// This field contains a person's most recent marital (civil) status.
	MaritalStatus *CodeableConcept `json:"maritalStatus,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name associated with the person.
	Name []HumanName `json:"name,omitempty"`

	// An image that can be displayed as a thumbnail of the person to enhance the
	// identification of the individual.
	Photo []Attachment `json:"photo,omitempty"`

	// This is a Person resource
	ResourceType interface{} `json:"resourceType"`

	// A contact detail for the person, e.g. a telephone number or an email address.
	Telecom []ContactPoint `json:"telecom,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Demographics and administrative information about a person independent of a
// specific health-related context.
type PersonCommunication struct {
	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language which may be used to communicate with the individual.
	Language CodeableConcept `json:"language"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether or not the person prefers this language (over other languages
	// he masters up a certain level).
	Preferred_2 *Boolean `json:"preferred,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PersonCommunication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["language"]; raw != nil && !ok {
		return fmt.Errorf("field language in PersonCommunication: required")
	}
	type Plain PersonCommunication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PersonCommunication(plain)
	return nil
}

type PersonContainedElem interface{}

// Demographics and administrative information about a person independent of a
// specific health-related context.
type PersonLink struct {
	// Extensions for assurance
	Assurance *Element `json:"_assurance,omitempty"`

	// Level of assurance that this link is associated with the target resource.
	Assurance_2 *Code `json:"assurance,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The resource to which this actual person is associated.
	Target Reference `json:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PersonLink) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in PersonLink: required")
	}
	type Plain PersonLink
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PersonLink(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Person) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Person: required")
	}
	type Plain Person
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeceasedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.DeceasedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeceasedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = Person(plain)
	return nil
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for asNeededBoolean
	AsNeededBoolean *Element `json:"_asNeededBoolean,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subjectCanonical
	SubjectCanonical *Element `json:"_subjectCanonical,omitempty"`

	// Extensions for subtitle
	Subtitle *Element `json:"_subtitle,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// An action or group of actions to be taken as part of the plan. For example, in
	// clinical care, an action would be to prescribe a particular indicated
	// medication, or perform a particular test as appropriate. In pharmaceutical
	// quality, an action would be the test that needs to be performed on a drug
	// product as defined in the quality specification or the steps that are planned
	// in a manufacturing process of a drug product or a drug substance.
	Action []PlanDefinitionAction `json:"action,omitempty"`

	// Actors represent the individuals or groups involved in the execution of the
	// defined set of activities.
	Actor []PlanDefinitionActor `json:"actor,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// If a CodeableConcept is present, it indicates the pre-condition for performing
	// the service.  For example "pain", "on flare-up", etc.
	AsNeededBoolean_2 *bool `json:"asNeededBoolean,omitempty"`

	// If a CodeableConcept is present, it indicates the pre-condition for performing
	// the service.  For example "pain", "on flare-up", etc.
	AsNeededCodeableConcept *CodeableConcept `json:"asNeededCodeableConcept,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []ContactDetail `json:"author,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PlanDefinitionContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the plan definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the plan definition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the plan definition was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the plan definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the plan definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the content.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the plan definition content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the content for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this plan definition is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A goal describes an expected outcome that activities within the plan are
	// intended to achieve. For example, weight loss, restoring an activity of daily
	// living, obtaining herd immunity via immunization, meeting a process improvement
	// objective, meeting the acceptance criteria for a test as specified by a quality
	// specification, etc.
	Goal []PlanDefinitionGoal `json:"goal,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this plan definition when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// A reference to a Library resource containing any formal logic used by the plan
	// definition.
	Library []Canonical `json:"library,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the plan definition. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the plan definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this plan definition is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a PlanDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the content.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this plan definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the plan definition. Canonical references are allowed
	// to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCanonical_2 *string `json:"subjectCanonical,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the plan definition. Canonical references are allowed
	// to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code, group definition, or canonical reference that describes  or identifies
	// the intended subject of the plan definition. Canonical references are allowed
	// to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// An explanatory or alternate title for the plan definition giving additional
	// information about its content.
	Subtitle_2 *String `json:"subtitle,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the plan definition.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the plan definition. Topics
	// provide a high-level categorization of the definition that can be useful for
	// filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// A high-level category for the plan definition that distinguishes the kinds of
	// systems that would be interested in the plan definition.
	Type *CodeableConcept `json:"type,omitempty"`

	// An absolute URI that is used to identify this plan definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this plan definition is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the plan definition is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the plan definition is used from a clinical
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate plan definition
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the plan definition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the plan definition author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence. To provide a version consistent
	// with the Decision Support Service specification, use the format
	// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge
	// assets, refer to the Decision Support Service specification. Note that a
	// version is required for non-experimental active artifacts.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionAction struct {
	// Extensions for applicabilityBehavior
	ApplicabilityBehavior *Element `json:"_applicabilityBehavior,omitempty"`

	// Extensions for cardinalityBehavior
	CardinalityBehavior *Element `json:"_cardinalityBehavior,omitempty"`

	// Extensions for definitionCanonical
	DefinitionCanonical *Element `json:"_definitionCanonical,omitempty"`

	// Extensions for definitionUri
	DefinitionUri *Element `json:"_definitionUri,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for goalId
	GoalID []Element `json:"_goalId,omitempty"`

	// Extensions for groupingBehavior
	GroupingBehavior *Element `json:"_groupingBehavior,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for precheckBehavior
	PrecheckBehavior *Element `json:"_precheckBehavior,omitempty"`

	// Extensions for prefix
	Prefix *Element `json:"_prefix,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for requiredBehavior
	RequiredBehavior *Element `json:"_requiredBehavior,omitempty"`

	// Extensions for selectionBehavior
	SelectionBehavior *Element `json:"_selectionBehavior,omitempty"`

	// Extensions for subjectCanonical
	SubjectCanonical *Element `json:"_subjectCanonical,omitempty"`

	// Extensions for textEquivalent
	TextEquivalent *Element `json:"_textEquivalent,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Sub actions that are contained within the action. The behavior of this action
	// determines the functionality of the sub-actions. For example, a selection
	// behavior of at-most-one indicates that of the sub-actions, at most one may be
	// chosen as part of realizing the action definition.
	Action []PlanDefinitionAction `json:"action,omitempty"`

	// All - meaning the applicability of each child action is evaluated
	// independently; if a child action is applicable according to the applicability
	// criteria, it is applied. Any - meaning that each child action is evaluated in
	// order, and the first action that returns an applicability of true will be
	// applied, and processing of the parent action will stop. If not specified, the
	// default behavior of All is used.
	ApplicabilityBehavior_2 *Code `json:"applicabilityBehavior,omitempty"`

	// Defines whether the action can be selected multiple times.
	CardinalityBehavior_2 *Code `json:"cardinalityBehavior,omitempty"`

	// A code that provides a meaning, grouping, or classification for the action or
	// action group. For example, a section may have a LOINC code for the section of a
	// documentation template. In pharmaceutical quality, an action (Test) such as pH
	// could be classified as a physical property.
	Code *CodeableConcept `json:"code,omitempty"`

	// An expression that describes applicability criteria or start/stop conditions
	// for the action.
	Condition []PlanDefinitionCondition `json:"condition,omitempty"`

	// A reference to an ActivityDefinition that describes the action to be taken in
	// detail, a Measure defining a measure to be evaluated, a MessageDefinition
	// describing a message to be sent, a PlanDefinition that describes a series of
	// actions to be taken, a Questionnaire that should be filled out, a
	// SpecimenDefinition describing a specimen to be collected, an
	// ObservationDefinition that specifies what observation should be captured, or an
	// OperationDefinition that specifies what operation should be invoked. When the
	// value is a uri, it is intended to be a reference to non-FHIR content that
	// characterizes the action to be performed. This option is allowed to enable the
	// PlanDefinition to be used to provide semi-structured representation, when the
	// guidance is not computable, but there is still value in elaborating the overall
	// structure with a PlanDefinition. The intended behavior when a definitionUri is
	// realized as part of an apply is that it is copied to the resulting
	// RequestOrchestration so that it is available to the consuming system. How that
	// system interprets that uri is not specified.
	DefinitionCanonical_2 *string `json:"definitionCanonical,omitempty"`

	// A reference to an ActivityDefinition that describes the action to be taken in
	// detail, a Measure defining a measure to be evaluated, a MessageDefinition
	// describing a message to be sent, a PlanDefinition that describes a series of
	// actions to be taken, a Questionnaire that should be filled out, a
	// SpecimenDefinition describing a specimen to be collected, an
	// ObservationDefinition that specifies what observation should be captured, or an
	// OperationDefinition that specifies what operation should be invoked. When the
	// value is a uri, it is intended to be a reference to non-FHIR content that
	// characterizes the action to be performed. This option is allowed to enable the
	// PlanDefinition to be used to provide semi-structured representation, when the
	// guidance is not computable, but there is still value in elaborating the overall
	// structure with a PlanDefinition. The intended behavior when a definitionUri is
	// realized as part of an apply is that it is copied to the resulting
	// RequestOrchestration so that it is available to the consuming system. How that
	// system interprets that uri is not specified.
	DefinitionUri_2 *string `json:"definitionUri,omitempty"`

	// A brief description of the action used to provide a summary to display to the
	// user.
	Description_2 *Markdown `json:"description,omitempty"`

	// Didactic or other informational resources associated with the action that can
	// be provided to the CDS recipient. Information resources can include inline text
	// commentary and links to web resources.
	Documentation []RelatedArtifact `json:"documentation,omitempty"`

	// Customizations that should be applied to the statically defined resource. For
	// example, if the dosage of a medication must be computed based on the patient's
	// weight, a customization would be used to specify an expression that calculated
	// the weight, and the path on the resource that would contain the result.
	DynamicValue []PlanDefinitionDynamicValue `json:"dynamicValue,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Identifies goals that this action supports. The reference must be to a goal
	// element defined within this plan definition. In pharmaceutical quality, a goal
	// represents acceptance criteria (Goal) for a given action (Test), so the goalId
	// would be the unique id of a defined goal element establishing the acceptance
	// criteria for the action.
	GoalID_2 []String `json:"goalId,omitempty"`

	// Defines the grouping behavior for the action and its children.
	GroupingBehavior_2 *Code `json:"groupingBehavior,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Defines input data requirements for the action.
	Input []PlanDefinitionInput `json:"input,omitempty"`

	// An identifier that is unique within the PlanDefinition to allow linkage within
	// the realized CarePlan and/or RequestOrchestration.
	LinkID_2 *String `json:"linkId,omitempty"`

	// Identifies the facility where the action will occur; e.g. home, hospital,
	// specific clinic, etc.
	Location *CodeableReference `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Defines the outputs of the action, if any.
	Output []PlanDefinitionOutput `json:"output,omitempty"`

	// Indicates who should participate in performing the action described.
	Participant []PlanDefinitionParticipant `json:"participant,omitempty"`

	// Defines whether the action should usually be preselected.
	PrecheckBehavior_2 *Code `json:"precheckBehavior,omitempty"`

	// A user-visible prefix for the action. For example a section or item numbering
	// such as 1. or A.
	Prefix_2 *String `json:"prefix,omitempty"`

	// Indicates how quickly the action should be addressed with respect to other
	// actions.
	Priority_2 *Code `json:"priority,omitempty"`

	// A description of why this action is necessary or appropriate.
	Reason []CodeableConcept `json:"reason,omitempty"`

	// A relationship to another action such as "before" or "30-60 minutes after start
	// of".
	RelatedAction []PlanDefinitionRelatedAction `json:"relatedAction,omitempty"`

	// Defines the required behavior for the action.
	RequiredBehavior_2 *Code `json:"requiredBehavior,omitempty"`

	// Defines the selection behavior for the action and its children.
	SelectionBehavior_2 *Code `json:"selectionBehavior,omitempty"`

	// A code, group definition, or canonical reference that describes the intended
	// subject of the action and its children, if any. Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCanonical_2 *string `json:"subjectCanonical,omitempty"`

	// A code, group definition, or canonical reference that describes the intended
	// subject of the action and its children, if any. Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code, group definition, or canonical reference that describes the intended
	// subject of the action and its children, if any. Canonical references are
	// allowed to support the definition of protocols for drug and substance quality
	// specifications, and is allowed to reference a MedicinalProductDefinition,
	// SubstanceDefinition, AdministrableProductDefinition,
	// ManufacturedItemDefinition, or PackagedProductDefinition resource.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// A text equivalent of the action to be performed. This provides a
	// human-interpretable description of the action when the definition is consumed
	// by a system that might not be capable of interpreting it dynamically.
	TextEquivalent_2 *Markdown `json:"textEquivalent,omitempty"`

	// An optional value describing when the action should be performed.
	TimingAge *Age `json:"timingAge,omitempty"`

	// An optional value describing when the action should be performed.
	TimingDuration *Duration `json:"timingDuration,omitempty"`

	// An optional value describing when the action should be performed.
	TimingRange *Range `json:"timingRange,omitempty"`

	// An optional value describing when the action should be performed.
	TimingRelativeTime *RelativeTime `json:"timingRelativeTime,omitempty"`

	// An optional value describing when the action should be performed.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// The textual description of the action displayed to a user. For example, when
	// the action is a test to be performed, the title would be the title of the test
	// such as Assay by HPLC.
	Title_2 *String `json:"title,omitempty"`

	// A reference to a StructureMap resource that defines a transform that can be
	// executed to produce the intent resource using the ActivityDefinition instance
	// as the input.
	Transform *Canonical `json:"transform,omitempty"`

	// A description of when the action should be triggered. When multiple triggers
	// are specified on an action, any triggering event invokes the action.
	Trigger []TriggerDefinition `json:"trigger,omitempty"`

	// The type of action to perform (create, update, remove).
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanDefinitionAction) UnmarshalJSON(value []byte) error {
	type Plain PlanDefinitionAction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DefinitionCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefinitionCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefinitionCanonical_2", `^\S*$`)
		}
	}
	if plain.DefinitionUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefinitionUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefinitionUri_2", `^\S*$`)
		}
	}
	if plain.SubjectCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SubjectCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SubjectCanonical_2", `^\S*$`)
		}
	}
	*j = PlanDefinitionAction(plain)
	return nil
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionActor struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// A description of how the actor fits into the overall actions of the plan
	// definition.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The characteristics of the candidates that could serve as the actor.
	Option []PlanDefinitionOption `json:"option"`

	// A descriptive label for the actor.
	Title_2 *String `json:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanDefinitionActor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["option"]; raw != nil && !ok {
		return fmt.Errorf("field option in PlanDefinitionActor: required")
	}
	type Plain PlanDefinitionActor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PlanDefinitionActor(plain)
	return nil
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionCondition struct {
	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// An expression that returns true or false, indicating whether the condition is
	// satisfied.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The kind of condition.
	Kind_2 *Code `json:"kind,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type PlanDefinitionContainedElem interface{}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionDynamicValue struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// An expression specifying the value of the customized element.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The path to the element to be customized. This is the path on the resource that
	// will hold the result of the calculation defined by the expression. The
	// specified path SHALL be a FHIRPath resolvable on the specified target type of
	// the ActivityDefinition, and SHALL consist only of identifiers, constant
	// indexers, and a restricted subset of functions. The path is allowed to contain
	// qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	Path_2 *String `json:"path,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionGoal struct {
	// Identifies problems, conditions, issues, or concerns the goal is intended to
	// address.
	Addresses []CodeableConcept `json:"addresses,omitempty"`

	// Indicates a category the goal falls within.
	Category *CodeableConcept `json:"category,omitempty"`

	// Human-readable and/or coded description of a specific desired objective of
	// care, such as "control blood pressure" or "negotiate an obstacle course" or
	// "dance with child at wedding".
	Description CodeableConcept `json:"description"`

	// Didactic or other informational resources associated with the goal that provide
	// further supporting information about the goal. Information resources can
	// include inline text commentary and links to web resources.
	Documentation []RelatedArtifact `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies the expected level of importance associated with reaching/sustaining
	// the defined goal.
	Priority *CodeableConcept `json:"priority,omitempty"`

	// The event after which the goal should begin being pursued.
	Start *CodeableConcept `json:"start,omitempty"`

	// Indicates what should be done and within what timeframe.
	Target []PlanDefinitionTarget `json:"target,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanDefinitionGoal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in PlanDefinitionGoal: required")
	}
	type Plain PlanDefinitionGoal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PlanDefinitionGoal(plain)
	return nil
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionInput struct {
	// Extensions for relatedData
	RelatedData *Element `json:"_relatedData,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Points to an existing input or output element that provides data to this input.
	RelatedData_2 *String `json:"relatedData,omitempty"`

	// Defines the data that is to be provided as input to the action.
	Requirement *DataRequirement `json:"requirement,omitempty"`

	// A human-readable label for the data requirement used to label data flows in
	// BPMN or similar diagrams. Also provides a human readable label when rendering
	// the data requirement that conveys its purpose to human readers.
	Title_2 *String `json:"title,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionOption struct {
	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The role the participant should play in performing the described action.
	Role *CodeableConcept `json:"role,omitempty"`

	// The type of participant in the action.
	Type_2 *Code `json:"type,omitempty"`

	// The type of participant in the action.
	TypeCanonical *Canonical `json:"typeCanonical,omitempty"`

	// The type of participant in the action.
	TypeReference *Reference `json:"typeReference,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionOutput struct {
	// Extensions for relatedData
	RelatedData *Element `json:"_relatedData,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Points to an existing input or output element that is results as output from
	// the action.
	RelatedData_2 *String `json:"relatedData,omitempty"`

	// Defines the data that results as output from the action.
	Requirement *DataRequirement `json:"requirement,omitempty"`

	// A human-readable label for the data requirement used to label data flows in
	// BPMN or similar diagrams. Also provides a human readable label when rendering
	// the data requirement that conveys its purpose to human readers.
	Title_2 *String `json:"title,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionParticipant struct {
	// Extensions for actorId
	ActorID *Element `json:"_actorId,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// A reference to the id element of the actor who will participate in this action.
	ActorID_2 *String `json:"actorId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates how the actor will be involved in the action - author, reviewer,
	// witness, etc.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The role the participant should play in performing the described action.
	Role *CodeableConcept `json:"role,omitempty"`

	// The type of participant in the action.
	Type_2 *Code `json:"type,omitempty"`

	// The type of participant in the action.
	TypeCanonical *Canonical `json:"typeCanonical,omitempty"`

	// The type of participant in the action.
	TypeReference *Reference `json:"typeReference,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionRelatedAction struct {
	// Extensions for endRelationship
	EndRelationship *Element `json:"_endRelationship,omitempty"`

	// Extensions for relationship
	Relationship *Element `json:"_relationship,omitempty"`

	// Extensions for targetId
	TargetID *Element `json:"_targetId,omitempty"`

	// The relationship of the end of this action to the related action.
	EndRelationship_2 *Code `json:"endRelationship,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A duration or range of durations to apply to the relationship. For example,
	// 30-60 minutes before.
	OffsetDuration *Duration `json:"offsetDuration,omitempty"`

	// A duration or range of durations to apply to the relationship. For example,
	// 30-60 minutes before.
	OffsetRange *Range `json:"offsetRange,omitempty"`

	// The relationship of the start of this action to the related action.
	Relationship_2 *Code `json:"relationship,omitempty"`

	// The element id of the target related action.
	TargetID_2 *String `json:"targetId,omitempty"`
}

// This resource allows for the definition of various types of plans as a sharable,
// consumable, and executable artifact. The resource is general enough to support
// the description of a broad range of clinical and non-clinical artifacts such as
// clinical decision support rules, order sets, protocols, and drug quality
// specifications.
type PlanDefinitionTarget struct {
	// Extensions for detailBoolean
	DetailBoolean *Element `json:"_detailBoolean,omitempty"`

	// Extensions for detailInteger
	DetailInteger *Element `json:"_detailInteger,omitempty"`

	// Extensions for detailString
	DetailString *Element `json:"_detailString,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailBoolean_2 *bool `json:"detailBoolean,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailCodeableConcept *CodeableConcept `json:"detailCodeableConcept,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailInteger_2 *float64 `json:"detailInteger,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailQuantity *Quantity `json:"detailQuantity,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailRange *Range `json:"detailRange,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailRatio *Ratio `json:"detailRatio,omitempty"`

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT
	// 0.6%, Clear solution, etc. Either the high or low or both values of the range
	// can be specified. When a low value is missing, it indicates that the goal is
	// achieved at any value at or below the high value. Similarly, if the high value
	// is missing, it indicates that the goal is achieved at any value at or above the
	// low value.
	DetailString_2 *string `json:"detailString,omitempty"`

	// Indicates the timeframe after the start of the goal in which the goal should be
	// met.
	Due *Duration `json:"due,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The parameter whose value is to be tracked, e.g. body weight, blood pressure,
	// or hemoglobin A1c level.
	Measure *CodeableConcept `json:"measure,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanDefinitionTarget) UnmarshalJSON(value []byte) error {
	type Plain PlanDefinitionTarget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DetailString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.DetailString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DetailString_2", `^^[\s\S]+$$`)
		}
	}
	*j = PlanDefinitionTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in PlanDefinition: required")
	}
	type Plain PlanDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SubjectCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.SubjectCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SubjectCanonical_2", `^\S*$`)
		}
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = PlanDefinition(plain)
	return nil
}

// An integer with a value that is positive (e.g. >0)
type PositiveInt float64

// A person who is directly or indirectly involved in the provisioning of
// healthcare or related services.
type Practitioner struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for birthDate
	BirthDate *Element `json:"_birthDate,omitempty"`

	// Extensions for deceasedBoolean
	DeceasedBoolean *Element `json:"_deceasedBoolean,omitempty"`

	// Extensions for deceasedDateTime
	DeceasedDateTime *Element `json:"_deceasedDateTime,omitempty"`

	// Extensions for gender
	Gender *Element `json:"_gender,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Whether this practitioner's record is in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// Address(es) of the practitioner that are not role specific (typically home
	// address). Work addresses are not typically entered in this property as they
	// are usually role dependent.
	Address []Address `json:"address,omitempty"`

	// The date of birth for the practitioner.
	BirthDate_2 *Date `json:"birthDate,omitempty"`

	// A language which may be used to communicate with the practitioner, often for
	// correspondence/administrative purposes.The `PractitionerRole.communication`
	// property should be used for publishing the languages that a practitioner is
	// able to communicate with patients (on a per Organization/Role basis).
	Communication []PractitionerCommunication `json:"communication,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PractitionerContainedElem `json:"contained,omitempty"`

	// Indicates if the practitioner is deceased or not.
	DeceasedBoolean_2 *bool `json:"deceasedBoolean,omitempty"`

	// Indicates if the practitioner is deceased or not.
	DeceasedDateTime_2 *string `json:"deceasedDateTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Administrative Gender - the gender that the person is considered to have for
	// administration and record keeping purposes.
	Gender_2 *Code `json:"gender,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// An identifier that applies to this person in this role.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The name(s) associated with the practitioner.
	Name []HumanName `json:"name,omitempty"`

	// Image of the person.
	Photo []Attachment `json:"photo,omitempty"`

	// The official qualifications, certifications, accreditations, training, licenses
	// (and other types of educations/skills/capabilities) that authorize or otherwise
	// pertain to the provision of care by the practitioner.For example, a medical
	// license issued by a medical board of licensure authorizing the practitioner to
	// practice medicine within a certain locality.
	Qualification []PractitionerQualification `json:"qualification,omitempty"`

	// This is a Practitioner resource
	ResourceType interface{} `json:"resourceType"`

	// A contact detail for the practitioner, e.g. a telephone number or an email
	// address.
	Telecom []ContactPoint `json:"telecom,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A person who is directly or indirectly involved in the provisioning of
// healthcare or related services.
type PractitionerCommunication struct {
	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language which may be used to communicate with the individual.
	Language CodeableConcept `json:"language"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether or not the person prefers this language (over other languages
	// he masters up a certain level).
	Preferred_2 *Boolean `json:"preferred,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PractitionerCommunication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["language"]; raw != nil && !ok {
		return fmt.Errorf("field language in PractitionerCommunication: required")
	}
	type Plain PractitionerCommunication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PractitionerCommunication(plain)
	return nil
}

type PractitionerContainedElem interface{}

// A person who is directly or indirectly involved in the provisioning of
// healthcare or related services.
type PractitionerQualification struct {
	// Coded representation of the qualification.
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier that applies to this person's qualification.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Organization that regulates and issues the qualification.
	Issuer *Reference `json:"issuer,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Period during which the qualification is valid.
	Period *Period `json:"period,omitempty"`

	// Qualifications often take time to attain and might be tracked during this time,
	// and completed qualifications might not always be valid. This status concept has
	// some overlap with period and both should be considered together. Refer to the
	// descriptions of the codes for how the period should be interpreted.If a
	// qualification is revoked or otherwise cancelled, then the period is likely to
	// be ignored, and m be related to when it was active.
	Status *CodeableConcept `json:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PractitionerQualification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in PractitionerQualification: required")
	}
	type Plain PractitionerQualification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PractitionerQualification(plain)
	return nil
}

// A specific set of Roles/Locations/specialties/services that a practitioner may
// perform at an organization for a period of time.
type PractitionerRole struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	//  Whether this practitioner role record is in active use. Some systems may use
	// this property to mark non-active practitioners, such as those that are not
	// currently employed.
	Active_2 *Boolean `json:"active,omitempty"`

	// A collection of times the practitioner is available or performing this role at
	// the location and/or healthcareservice.
	Availability *Availability `json:"availability,omitempty"`

	// Collection of characteristics (attributes).
	Characteristic []CodeableConcept `json:"characteristic,omitempty"`

	// Roles which this practitioner is authorized to perform for the organization.
	Code []CodeableConcept `json:"code,omitempty"`

	// A language the practitioner can use in patient communication. The practitioner
	// may know several languages (listed in practitioner.communication), however
	// these are the languages that could be advertised in a directory for a patient
	// to search.
	Communication []CodeableConcept `json:"communication,omitempty"`

	// The contact details of communication devices available relevant to the specific
	// PractitionerRole. This can include addresses, phone numbers, fax numbers,
	// mobile numbers, email addresses and web sites.
	Contact []ExtendedContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []PractitionerRoleContainedElem `json:"contained,omitempty"`

	// A value that describes the intersection of the practitioner, organization, and
	// the role of the practitioner within the organization.  This is not the human
	// name of the practitioner, though the textual representation of that human name
	// may be a part of this property.
	Display_2 *String `json:"display,omitempty"`

	//  Technical endpoints providing access to services operated for the practitioner
	// with this role. Commonly used for locating scheduling services, or identifying
	// where to send referrals electronically.
	Endpoint []Reference `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The list of healthcare services that this worker provides for this role's
	// Organization/Location(s).
	HealthcareService []Reference `json:"healthcareService,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business Identifiers that are specific to a role/location.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The location(s) at which this practitioner provides care.
	Location []Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The network in which the PractitionerRole provides the role's services (if
	// defined) at the indicated locations (if defined).
	Network []Reference `json:"network,omitempty"`

	// The organization where this role is available.
	Organization *Reference `json:"organization,omitempty"`

	// The period during which the person is authorized to act as a practitioner in
	// these role(s) for the organization.
	Period *Period `json:"period,omitempty"`

	// Practitioner that is able to provide the defined services for the organization.
	Practitioner *Reference `json:"practitioner,omitempty"`

	// This is a PractitionerRole resource
	ResourceType interface{} `json:"resourceType"`

	// The specialty of a practitioner that describes the functional role they are
	// practicing at a given organization or location.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type PractitionerRoleContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PractitionerRole) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in PractitionerRole: required")
	}
	type Plain PractitionerRole
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PractitionerRole(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Practitioner) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Practitioner: required")
	}
	type Plain Practitioner
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeceasedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.DeceasedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeceasedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = Practitioner(plain)
	return nil
}

// The base type for all re-useable types defined that have a simple property.
type PrimitiveType struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`
}

// An action that is or was performed on or for a patient, practitioner, device,
// organization, or location. For example, this can be a physical intervention on a
// patient like an operation, or less invasive like long term services, counseling,
// or hypnotherapy.  This can be a quality or safety inspection for a location,
// organization, or device.  This can be an accreditation procedure on a
// practitioner for licensing.
type Procedure struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for occurrenceString
	OccurrenceString *Element `json:"_occurrenceString,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for reportedBoolean
	ReportedBoolean *Element `json:"_reportedBoolean,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A reference to a resource that contains details of the request for this
	// procedure.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Detailed and structured anatomical location information. Multiple locations are
	// allowed - e.g. multiple punch biopsies of a lesion.
	BodySite []CodeableConcept `json:"bodySite,omitempty"`

	// Indicates the body structure on the subject's body where the procedure was
	// performed.
	BodyStructure *Reference `json:"bodyStructure,omitempty"`

	// A code that classifies the procedure for searching, sorting and display
	// purposes (e.g. "Surgical Procedure").
	Category []CodeableConcept `json:"category,omitempty"`

	// The specific procedure that is performed. Use text if the exact nature of the
	// procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
	Code *CodeableConcept `json:"code,omitempty"`

	// Any complications that occurred during the procedure, or in the immediate
	// post-performance period. These are generally tracked separately from the notes,
	// which will typically describe the procedure itself rather than any 'post
	// procedure' issues.
	Complication []CodeableReference `json:"complication,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ProcedureContainedElem `json:"contained,omitempty"`

	// The Encounter during which this Procedure was created or performed or to which
	// the creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A device that is implanted, removed or otherwise manipulated (calibration,
	// battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a
	// focal portion of the Procedure.
	FocalDevice []ProcedureFocalDevice `json:"focalDevice,omitempty"`

	// Who is the target of the procedure when it is not the subject of record only.
	// If focus is not present, then subject is the focus.  If focus is present and
	// the subject is one of the targets of the procedure, include subject as a focus
	// as well. If focus is present and the subject is not included in focus, it
	// implies that the procedure was only targeted on the focus. For example, when a
	// caregiver is given education for a patient, the caregiver would be the focus
	// and the procedure record is associated with the subject (e.g. patient).  For
	// example, use focus when recording the target of the education, training, or
	// counseling is the parent or relative of a patient.
	Focus *Reference `json:"focus,omitempty"`

	// If the procedure required specific follow up - e.g. removal of sutures. The
	// follow up may be represented as a simple note or could potentially be more
	// complex, in which case the CarePlan resource can be used. CarePlan can
	// reference the Procedure via CarePlan.addresses.
	FollowUp []CodeableReference `json:"followUp,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this procedure by the performer or other
	// systems which remain constant as the resource is updated and is propagated from
	// server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The location where the procedure actually happened.  E.g. a newborn at home, a
	// tracheostomy at a restaurant.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Any other notes and comments about the procedure.
	Note []Annotation `json:"note,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrenceAge *Age `json:"occurrenceAge,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrenceRange *Range `json:"occurrenceRange,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrenceString_2 *string `json:"occurrenceString,omitempty"`

	// Estimated or actual date, date-time, period, or age when the procedure did
	// occur or is occurring.  Allows a period to support complex procedures that span
	// more than one date, and also allows for the length of the procedure to be
	// captured.
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`

	// The short term outcome of the procedure assessed during the procedure, at the
	// conclusion of the procedure, during the immediate post-performance period, or
	// at discharge. The outcome is usually expected to be within the encounter during
	// which the procedure was performed.
	Outcome []CodeableReference `json:"outcome,omitempty"`

	// A larger event of which this particular procedure is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// Indicates who or what performed the procedure and how they were involved.
	Performer []ProcedurePerformer `json:"performer,omitempty"`

	// The coded reason or reference why the procedure was performed. This may be a
	// coded entity of some type, be present as text, or be a reference to one of
	// several resources that justify the procedure.
	Reason []CodeableReference `json:"reason,omitempty"`

	// The date the occurrence of the procedure was first captured in the record
	// regardless of Procedure.status (potentially after the occurrence of the event).
	Recorded_2 *DateTime `json:"recorded,omitempty"`

	// Individual who recorded the record and takes responsibility for its content.
	Recorder *Reference `json:"recorder,omitempty"`

	// This could be a histology result, pathology report, surgical report, etc.
	Report []Reference `json:"report,omitempty"`

	// Indicates if this record was captured as a secondary 'reported' record rather
	// than as an original primary source-of-truth record.  It may also indicate the
	// source of the report.
	ReportedBoolean_2 *bool `json:"reportedBoolean,omitempty"`

	// Indicates if this record was captured as a secondary 'reported' record rather
	// than as an original primary source-of-truth record.  It may also indicate the
	// source of the report.
	ReportedReference *Reference `json:"reportedReference,omitempty"`

	// This is a Procedure resource
	ResourceType interface{} `json:"resourceType"`

	// A code specifying the state of the procedure. Generally, this will be the
	// in-progress or completed state.
	Status_2 *Code `json:"status,omitempty"`

	// Captures the reason for the current state of the procedure.
	StatusReason *CodeableConcept `json:"statusReason,omitempty"`

	// On whom or on what the procedure was performed. This is usually an individual
	// human, but can also be performed on animals, groups of humans or animals,
	// organizations or practitioners (for licensing), locations or devices (for
	// safety inspections or regulatory authorizations).  If the actual focus of the
	// procedure is different from the subject, the focus element specifies the actual
	// focus of the procedure.
	Subject Reference `json:"subject"`

	// Other resources from the patient record that may be relevant to the procedure.
	// The information from these resources was either used to create the instance or
	// is provided to help with its interpretation. This extension should not be used
	// if more specific inline elements or extensions are available.
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Identifies medications, devices and any other substance used as part of the
	// procedure.
	Used []CodeableReference `json:"used,omitempty"`
}

type ProcedureContainedElem interface{}

// An action that is or was performed on or for a patient, practitioner, device,
// organization, or location. For example, this can be a physical intervention on a
// patient like an operation, or less invasive like long term services, counseling,
// or hypnotherapy.  This can be a quality or safety inspection for a location,
// organization, or device.  This can be an accreditation procedure on a
// practitioner for licensing.
type ProcedureFocalDevice struct {
	// The kind of change that happened to the device during the procedure.
	Action *CodeableConcept `json:"action,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The device that was manipulated (changed) during the procedure.
	Manipulated Reference `json:"manipulated"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProcedureFocalDevice) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["manipulated"]; raw != nil && !ok {
		return fmt.Errorf("field manipulated in ProcedureFocalDevice: required")
	}
	type Plain ProcedureFocalDevice
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProcedureFocalDevice(plain)
	return nil
}

// An action that is or was performed on or for a patient, practitioner, device,
// organization, or location. For example, this can be a physical intervention on a
// patient like an operation, or less invasive like long term services, counseling,
// or hypnotherapy.  This can be a quality or safety inspection for a location,
// organization, or device.  This can be an accreditation procedure on a
// practitioner for licensing.
type ProcedurePerformer struct {
	// Indicates who or what performed the procedure.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Distinguishes the type of involvement of the performer in the procedure. For
	// example, surgeon, anaesthetist, endoscopist.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The Organization the Patient, RelatedPerson, Device, CareTeam, and
	// HealthcareService was acting on behalf of.
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`

	// Time period during which the performer performed the procedure.
	Period *Period `json:"period,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProcedurePerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in ProcedurePerformer: required")
	}
	type Plain ProcedurePerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProcedurePerformer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Procedure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Procedure: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in Procedure: required")
	}
	type Plain Procedure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.OccurrenceString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.OccurrenceString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Procedure(plain)
	return nil
}

// The shelf-life and storage information for a medicinal product item or container
// can be described using this class.
type ProductShelfLife struct {
	// Extensions for periodString
	PeriodString *Element `json:"_periodString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The shelf life time period can be specified using a numerical value for the
	// period of time and its unit of time measurement The unit of measurement shall
	// be specified in accordance with ISO 11240 and the resulting terminology The
	// symbol and the symbol identifier shall be used.
	PeriodDuration *Duration `json:"periodDuration,omitempty"`

	// The shelf life time period can be specified using a numerical value for the
	// period of time and its unit of time measurement The unit of measurement shall
	// be specified in accordance with ISO 11240 and the resulting terminology The
	// symbol and the symbol identifier shall be used.
	PeriodString_2 *string `json:"periodString,omitempty"`

	// Special precautions for storage, if any, can be specified using an appropriate
	// controlled vocabulary The controlled term and the controlled term identifier
	// shall be specified.
	SpecialPrecautionsForStorage []CodeableConcept `json:"specialPrecautionsForStorage,omitempty"`

	// This describes the shelf life, taking into account various scenarios such as
	// shelf life of the packaged Medicinal Product itself, shelf life after
	// transformation where necessary and shelf life after the first opening of a
	// bottle, etc. The shelf life type shall be specified using an appropriate
	// controlled vocabulary The controlled term and the controlled term identifier
	// shall be specified.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductShelfLife) UnmarshalJSON(value []byte) error {
	type Plain ProductShelfLife
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.PeriodString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.PeriodString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "PeriodString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ProductShelfLife(plain)
	return nil
}

// Provenance of a resource is a record that describes entities and processes
// involved in producing and delivering or otherwise influencing that resource.
// Provenance provides a critical foundation for assessing authenticity, enabling
// trust, and allowing reproducibility. Provenance assertions are a form of
// contextual metadata and can themselves become important records with their own
// provenance. Provenance statement indicates clinical significance in terms of
// confidence in authenticity, reliability, and trustworthiness, integrity, and
// stage in lifecycle (e.g. Document Completion - has the artifact been legally
// authenticated), all of which MAY impact security, privacy, and trust policies.
type Provenance struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurredDateTime
	OccurredDateTime *Element `json:"_occurredDateTime,omitempty"`

	// Extensions for policy
	Policy []Element `json:"_policy,omitempty"`

	// Extensions for recorded
	Recorded *Element `json:"_recorded,omitempty"`

	// Extensions for why
	Why *Element `json:"_why,omitempty"`

	// An activity is something that occurs over a period of time and acts upon or
	// with entities; it MAY include consuming, processing, transforming, modifying,
	// relocating, using, or generating entities.
	Activity *CodeableConcept `json:"activity,omitempty"`

	// An actor taking a role in an activity  for which it can be assigned some degree
	// of responsibility for the activity taking place.
	Agent []ProvenanceAgent `json:"agent"`

	// The authorization (e.g., PurposeOfUse) that was used during the event being
	// recorded.
	Authorization []CodeableReference `json:"authorization,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this
	// provenance.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ProvenanceContainedElem `json:"contained,omitempty"`

	// This will typically be the encounter the event occurred, but some events MAY be
	// initiated prior to or after the official completion of an encounter but still
	// be tied to the context of the encounter (e.g. pre-admission lab tests).
	Encounter *Reference `json:"encounter,omitempty"`

	// An entity used in this activity.
	Entity []ProvenanceEntity `json:"entity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Where the activity occurred.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The period during which the activity occurred.
	OccurredDateTime_2 *string `json:"occurredDateTime,omitempty"`

	// The period during which the activity occurred.
	OccurredPeriod *Period `json:"occurredPeriod,omitempty"`

	// The patient element is available to enable deterministic tracking of activities
	// that involve the patient as the subject of the data used in an activity.
	Patient *Reference `json:"patient,omitempty"`

	// Policy or plan the activity was defined by. Typically, a single activity MAY
	// have multiple applicable policy documents, such as patient consent, guarantor
	// funding, etc.
	Policy_2 []Uri `json:"policy,omitempty"`

	// The date and time at which the provenance information was recorded / updated,
	// whether in the FHIR Provenance resource or in some other form that is later
	// communicated in the FHIR Provenance.
	Recorded_2 *Instant `json:"recorded,omitempty"`

	// This is a Provenance resource
	ResourceType interface{} `json:"resourceType"`

	// A digital signature on the target Reference(s). The signer SHOULD match a
	// Provenance.agent. The purpose of the signature is indicated.
	Signature []Signature `json:"signature,omitempty"`

	// The Reference(s) that were generated or updated by  the activity described in
	// this resource. A provenance can point to more than one target if multiple
	// resources were created/updated by the same activity.
	Target []Reference `json:"target"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Describes why the event recorded in this provenenace occurred in textual form.
	Why_2 *Markdown `json:"why,omitempty"`
}

// Provenance of a resource is a record that describes entities and processes
// involved in producing and delivering or otherwise influencing that resource.
// Provenance provides a critical foundation for assessing authenticity, enabling
// trust, and allowing reproducibility. Provenance assertions are a form of
// contextual metadata and can themselves become important records with their own
// provenance. Provenance statement indicates clinical significance in terms of
// confidence in authenticity, reliability, and trustworthiness, integrity, and
// stage in lifecycle (e.g. Document Completion - has the artifact been legally
// authenticated), all of which MAY impact security, privacy, and trust policies.
type ProvenanceAgent struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The agent that delegated authority to perform the activity performed by the
	// agent.who element.
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`

	// The structural roles of the agent indicating the agent's competency. The
	// security role enabling the agent with respect to the activity.
	Role []CodeableConcept `json:"role,omitempty"`

	// The Functional Role of the agent with respect to the activity.
	Type *CodeableConcept `json:"type,omitempty"`

	// Indicates who or what performed in the event.
	Who Reference `json:"who"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProvenanceAgent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["who"]; raw != nil && !ok {
		return fmt.Errorf("field who in ProvenanceAgent: required")
	}
	type Plain ProvenanceAgent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProvenanceAgent(plain)
	return nil
}

type ProvenanceContainedElem interface{}

// Provenance of a resource is a record that describes entities and processes
// involved in producing and delivering or otherwise influencing that resource.
// Provenance provides a critical foundation for assessing authenticity, enabling
// trust, and allowing reproducibility. Provenance assertions are a form of
// contextual metadata and can themselves become important records with their own
// provenance. Provenance statement indicates clinical significance in terms of
// confidence in authenticity, reliability, and trustworthiness, integrity, and
// stage in lifecycle (e.g. Document Completion - has the artifact been legally
// authenticated), all of which MAY impact security, privacy, and trust policies.
type ProvenanceEntity struct {
	// Extensions for role
	Role *Element `json:"_role,omitempty"`

	// The entity is attributed to an agent to express the agent's responsibility for
	// that entity, possibly along with other agents. This description can be
	// understood as shorthand for saying that the agent was responsible for the
	// activity which used the entity.
	Agent []ProvenanceAgent `json:"agent,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// How the entity was used during the activity.
	Role_2 *Code `json:"role,omitempty"`

	// Identity of the  Entity used. May be a logical or physical uri and maybe
	// absolute or relative.
	What Reference `json:"what"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProvenanceEntity) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["what"]; raw != nil && !ok {
		return fmt.Errorf("field what in ProvenanceEntity: required")
	}
	type Plain ProvenanceEntity
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProvenanceEntity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Provenance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["agent"]; raw != nil && !ok {
		return fmt.Errorf("field agent in Provenance: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Provenance: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Provenance: required")
	}
	type Plain Provenance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurredDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurredDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurredDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = Provenance(plain)
	return nil
}

// A measured amount (or an amount that can potentially be measured). Note that
// measured amounts include amounts that are not precisely quantified, including
// amounts involving arbitrary units and floating currencies.
type Quantity struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for unit
	Unit *Element `json:"_unit,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// A computer processable form of the unit in some unit representation system.
	Code_2 *Code `json:"code,omitempty"`

	// How the value should be understood and represented - whether the actual value
	// is greater or less than the stated value due to measurement issues; e.g. if the
	// comparator is "<" , then the real value is < stated value.
	Comparator_2 *QuantityComparator_2 `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The identification of the system that provides the coded form of the unit.
	System_2 *Uri `json:"system,omitempty"`

	// A human-readable form of the unit.
	Unit_2 *String `json:"unit,omitempty"`

	// The value of the measured amount. The value includes an implicit precision in
	// the presentation of the value.
	Value_2 *Decimal `json:"value,omitempty"`
}

type QuantityComparator_2 string

const QuantityComparator_2_Ad QuantityComparator_2 = "ad"
const QuantityComparator_2_GE QuantityComparator_2 = ">="
const QuantityComparator_2_GT QuantityComparator_2 = ">"
const QuantityComparator_2_LT QuantityComparator_2 = "<"
const QuantityComparator_2_LE QuantityComparator_2 = "<="

var enumValues_QuantityComparator_2 = []interface{}{
	"<",
	"<=",
	">=",
	">",
	"ad",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuantityComparator_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuantityComparator_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuantityComparator_2, v)
	}
	*j = QuantityComparator_2(v)
	return nil
}

// A structured set of questions intended to guide the collection of answers from
// end-users. Questionnaires provide detailed control over order, presentation,
// phraseology and grouping to allow coherent, consistent data collection.
type Questionnaire struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for subjectType
	SubjectType []Element `json:"_subjectType,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the {{title}}.
	Author []ContactDetail `json:"author,omitempty"`

	// An identifier for this collection of questions in a particular terminology such
	// as LOINC.
	Code []Coding `json:"code,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []QuestionnaireContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the questionnaire and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the questionnaire.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the questionnaire was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the questionnaire changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// The URL of a Questionnaire that this Questionnaire is based on.
	DerivedFrom []Canonical `json:"derivedFrom,omitempty"`

	// A free text natural language description of the questionnaire from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the {{title}}.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the questionnaire content was or is planned to be in
	// active use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the {{title}} for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A Boolean value to indicate that this questionnaire is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this questionnaire when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A particular question, question grouping or display text that is part of the
	// questionnaire.
	Item []QuestionnaireItem `json:"item,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the questionnaire. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the questionnaire.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this questionnaire is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a Questionnaire resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the {{title}}.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The current state of this questionnaire.
	Status_2 *Code `json:"status,omitempty"`

	// The types of subjects that can be the subject of responses created for the
	// questionnaire.
	SubjectType_2 []Code `json:"subjectType,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the questionnaire.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the {{title}}. Topics provide a
	// high-level categorization as well as keywords for the {{title}} that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this questionnaire when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this questionnaire is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the questionnaire is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate questionnaires.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the questionnaire when
	// it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the questionnaire author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A structured set of questions intended to guide the collection of answers from
// end-users. Questionnaires provide detailed control over order, presentation,
// phraseology and grouping to allow coherent, consistent data collection.
type QuestionnaireAnswerOption struct {
	// Extensions for initialSelected
	InitialSelected *Element `json:"_initialSelected,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Indicates whether the answer value is selected when the list of possible
	// answers is initially shown.
	InitialSelected_2 *Boolean `json:"initialSelected,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueString_2 *string `json:"valueString,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// A potential answer that's allowed as the answer to this question.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionnaireAnswerOption) UnmarshalJSON(value []byte) error {
	type Plain QuestionnaireAnswerOption
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = QuestionnaireAnswerOption(plain)
	return nil
}

type QuestionnaireContainedElem interface{}

// A structured set of questions intended to guide the collection of answers from
// end-users. Questionnaires provide detailed control over order, presentation,
// phraseology and grouping to allow coherent, consistent data collection.
type QuestionnaireEnableWhen struct {
	// Extensions for answerBoolean
	AnswerBoolean *Element `json:"_answerBoolean,omitempty"`

	// Extensions for answerDate
	AnswerDate *Element `json:"_answerDate,omitempty"`

	// Extensions for answerDateTime
	AnswerDateTime *Element `json:"_answerDateTime,omitempty"`

	// Extensions for answerDecimal
	AnswerDecimal *Element `json:"_answerDecimal,omitempty"`

	// Extensions for answerInteger
	AnswerInteger *Element `json:"_answerInteger,omitempty"`

	// Extensions for answerString
	AnswerString *Element `json:"_answerString,omitempty"`

	// Extensions for answerTime
	AnswerTime *Element `json:"_answerTime,omitempty"`

	// Extensions for answerUri
	AnswerUri *Element `json:"_answerUri,omitempty"`

	// Extensions for operator
	Operator *Element `json:"_operator,omitempty"`

	// Extensions for question
	Question *Element `json:"_question,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerAttachment *Attachment `json:"answerAttachment,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerBoolean_2 *bool `json:"answerBoolean,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerCoding *Coding `json:"answerCoding,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerDate_2 *string `json:"answerDate,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerDateTime_2 *string `json:"answerDateTime,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerDecimal_2 *float64 `json:"answerDecimal,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerInteger_2 *float64 `json:"answerInteger,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerQuantity *Quantity `json:"answerQuantity,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerReference *Reference `json:"answerReference,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerString_2 *string `json:"answerString,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerTime_2 *string `json:"answerTime,omitempty"`

	// A value that the referenced question is tested using the specified operator in
	// order for the item to be enabled.  If there are multiple answers, a match on
	// any of the answers suffices.  If different behavior is desired (all must match,
	// at least 2 must match, etc.), consider using the enableWhenExpression
	// extension.
	AnswerUri_2 *string `json:"answerUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Specifies the criteria by which the question is enabled.
	Operator_2 *Code `json:"operator,omitempty"`

	// The linkId for the question whose answer (or lack of answer) governs whether
	// this item is enabled.
	Question_2 *String `json:"question,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionnaireEnableWhen) UnmarshalJSON(value []byte) error {
	type Plain QuestionnaireEnableWhen
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AnswerDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.AnswerDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AnswerDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.AnswerDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.AnswerDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AnswerDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.AnswerString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AnswerString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AnswerString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.AnswerTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.AnswerTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AnswerTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.AnswerUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.AnswerUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AnswerUri_2", `^\S*$`)
		}
	}
	*j = QuestionnaireEnableWhen(plain)
	return nil
}

// A structured set of questions intended to guide the collection of answers from
// end-users. Questionnaires provide detailed control over order, presentation,
// phraseology and grouping to allow coherent, consistent data collection.
type QuestionnaireInitial struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The actual value to for an initial answer.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The actual value to for an initial answer.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The actual value to for an initial answer.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The actual value to for an initial answer.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The actual value to for an initial answer.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The actual value to for an initial answer.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The actual value to for an initial answer.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The actual value to for an initial answer.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The actual value to for an initial answer.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The actual value to for an initial answer.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The actual value to for an initial answer.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The actual value to for an initial answer.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionnaireInitial) UnmarshalJSON(value []byte) error {
	type Plain QuestionnaireInitial
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = QuestionnaireInitial(plain)
	return nil
}

// A structured set of questions intended to guide the collection of answers from
// end-users. Questionnaires provide detailed control over order, presentation,
// phraseology and grouping to allow coherent, consistent data collection.
type QuestionnaireItem struct {
	// Extensions for answerConstraint
	AnswerConstraint *Element `json:"_answerConstraint,omitempty"`

	// Extensions for definition
	Definition []Element `json:"_definition,omitempty"`

	// Extensions for disabledDisplay
	DisabledDisplay *Element `json:"_disabledDisplay,omitempty"`

	// Extensions for enableBehavior
	EnableBehavior *Element `json:"_enableBehavior,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for maxLength
	MaxLength *Element `json:"_maxLength,omitempty"`

	// Extensions for prefix
	Prefix *Element `json:"_prefix,omitempty"`

	// Extensions for readOnly
	ReadOnly *Element `json:"_readOnly,omitempty"`

	// Extensions for repeats
	Repeats *Element `json:"_repeats,omitempty"`

	// Extensions for required
	Required *Element `json:"_required,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// For items that have a defined set of allowed answers (via answerOption or
	// answerValueSet), indicates whether values *other* than those specified can be
	// selected.
	AnswerConstraint_2 *Code `json:"answerConstraint,omitempty"`

	// One of the permitted answers for the question.
	AnswerOption []QuestionnaireAnswerOption `json:"answerOption,omitempty"`

	// A reference to a value set containing a list of values representing permitted
	// answers for a question.
	AnswerValueSet *Canonical `json:"answerValueSet,omitempty"`

	// A terminology code that corresponds to this group or question (e.g. a code from
	// LOINC, which defines many questions and answers).
	Code []Coding `json:"code,omitempty"`

	// This element is a URI that refers to an
	// [ElementDefinition](elementdefinition.html) or to an
	// [ObservationDefinition](observationdefinition.html) that provides information
	// about this item, including information that might otherwise be included in the
	// instance of the Questionnaire resource. A detailed description of the
	// construction of the URI is shown in [Comments](questionnaire.html#definition),
	// below.
	Definition_2 []Uri `json:"definition,omitempty"`

	// Indicates if and how items that are disabled (because enableWhen evaluates to
	// 'false') should be displayed.
	DisabledDisplay_2 *Code `json:"disabledDisplay,omitempty"`

	// Controls how multiple enableWhen values are interpreted -  whether all or any
	// must be true.
	EnableBehavior_2 *Code `json:"enableBehavior,omitempty"`

	// A constraint indicating that this item should only be enabled (displayed/allow
	// answers to be captured) when the specified condition is true.
	EnableWhen []QuestionnaireEnableWhen `json:"enableWhen,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// One or more values that should be pre-populated in the answer when initially
	// rendering the questionnaire for user input.
	Initial []QuestionnaireInitial `json:"initial,omitempty"`

	// Text, questions and other groups to be nested beneath a question or group.
	Item []QuestionnaireItem `json:"item,omitempty"`

	// An identifier that is unique within the Questionnaire allowing linkage to the
	// equivalent item in a QuestionnaireResponse resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// The maximum number of characters that are permitted in the answer to be
	// considered a "valid" QuestionnaireResponse.
	MaxLength_2 *Integer `json:"maxLength,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A short label for a particular group, question or set of display text within
	// the questionnaire used for reference by the individual completing the
	// questionnaire.
	Prefix_2 *String `json:"prefix,omitempty"`

	// An indication, when true, that the value cannot be changed by a human
	// respondent to the Questionnaire.
	ReadOnly_2 *Boolean `json:"readOnly,omitempty"`

	// An indication, if true, that a QuestionnaireResponse for this item may include
	// multiple answers associated with a single instance of this item (for
	// question-type items) or multiple repetitions of the item (for group-type
	// items).
	Repeats_2 *Boolean `json:"repeats,omitempty"`

	// An indication, if true, that the item must be present in a "completed"
	// QuestionnaireResponse.  If false, the item may be skipped when answering the
	// questionnaire.
	Required_2 *Boolean `json:"required,omitempty"`

	// The name of a section, the text of a question or text content for a display
	// item.
	Text_2 *String `json:"text,omitempty"`

	// The type of questionnaire item this is - whether text for display, a grouping
	// of other items or a particular type of data to be captured (string, integer,
	// Coding, etc.).
	Type_2 *Code `json:"type,omitempty"`
}

// A structured set of questions and their answers. The questions are ordered and
// grouped into coherent subsets, corresponding to the structure of the grouping of
// the questionnaire being responded to.
type QuestionnaireResponse struct {
	// Extensions for authored
	Authored *Element `json:"_authored,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The individual or device that received the answers to the questions in the
	// QuestionnaireResponse and recorded them in the system.
	Author *Reference `json:"author,omitempty"`

	// The date and/or time that this questionnaire response was last modified by the
	// user - e.g. changing answers or revising status.
	Authored_2 *DateTime `json:"authored,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this
	// questionnaire response.  For example, a ServiceRequest seeking an intake
	// assessment or a decision support recommendation to assess for post-partum
	// depression.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []QuestionnaireResponseContainedElem `json:"contained,omitempty"`

	// The Encounter during which this questionnaire response was created or to which
	// the creation of this record is tightly associated.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this questionnaire response by the performer
	// and/or other systems.  These identifiers remain constant as the resource is
	// updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A group or question item from the original questionnaire for which answers are
	// provided.
	Item []QuestionnaireResponseItem `json:"item,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A procedure or observation that this questionnaire was performed as part of the
	// execution of.  For example, the surgery a checklist was executed as part of.
	PartOf []Reference `json:"partOf,omitempty"`

	// The Questionnaire that defines and organizes the questions for which answers
	// are being provided.
	Questionnaire Canonical `json:"questionnaire"`

	// This is a QuestionnaireResponse resource
	ResourceType interface{} `json:"resourceType"`

	// The individual or device that answered the questions about the subject.
	Source *Reference `json:"source,omitempty"`

	// The current state of the questionnaire response.
	Status_2 *Code `json:"status,omitempty"`

	// The subject of the questionnaire response.  This could be a patient,
	// organization, practitioner, device, etc.  This is who/what the answers apply
	// to, but is not necessarily the source of information.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A structured set of questions and their answers. The questions are ordered and
// grouped into coherent subsets, corresponding to the structure of the grouping of
// the questionnaire being responded to.
type QuestionnaireResponseAnswer struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Nested groups and/or questions found within this particular answer.
	Item []QuestionnaireResponseItem `json:"item,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The answer (or one of the answers) provided by the respondent to the question.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionnaireResponseAnswer) UnmarshalJSON(value []byte) error {
	type Plain QuestionnaireResponseAnswer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = QuestionnaireResponseAnswer(plain)
	return nil
}

type QuestionnaireResponseContainedElem interface{}

// A structured set of questions and their answers. The questions are ordered and
// grouped into coherent subsets, corresponding to the structure of the grouping of
// the questionnaire being responded to.
type QuestionnaireResponseItem struct {
	// Extensions for definition
	Definition []Element `json:"_definition,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// The respondent's answer(s) to the question.
	Answer []QuestionnaireResponseAnswer `json:"answer,omitempty"`

	// A reference to an [ElementDefinition](elementdefinition.html) that provides the
	// details for the item.
	Definition_2 []Uri `json:"definition,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Sub-questions, sub-groups or display items nested beneath a group.
	Item []QuestionnaireResponseItem `json:"item,omitempty"`

	// The item from the Questionnaire that corresponds to this item in the
	// QuestionnaireResponse resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Text that is displayed above the contents of the group or as the text of the
	// question being answered.
	Text_2 *String `json:"text,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionnaireResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["questionnaire"]; raw != nil && !ok {
		return fmt.Errorf("field questionnaire in QuestionnaireResponse: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in QuestionnaireResponse: required")
	}
	type Plain QuestionnaireResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = QuestionnaireResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Questionnaire) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Questionnaire: required")
	}
	type Plain Questionnaire
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Questionnaire(plain)
	return nil
}

// A set of ordered Quantities defined by a low and high limit.
type Range struct {
	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The high limit. The boundary is inclusive.
	High *Quantity `json:"high,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The low limit. The boundary is inclusive.
	Low *Quantity `json:"low,omitempty"`
}

// A relationship of two Quantity values - expressed as a numerator and a
// denominator.
type Ratio struct {
	// The value of the denominator.
	Denominator *Quantity `json:"denominator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The value of the numerator.
	Numerator *Quantity `json:"numerator,omitempty"`
}

// A range of ratios expressed as a low and high numerator and a denominator.
type RatioRange struct {
	// The value of the denominator.
	Denominator *Quantity `json:"denominator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The value of the high limit numerator.
	HighNumerator *Quantity `json:"highNumerator,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The value of the low limit numerator.
	LowNumerator *Quantity `json:"lowNumerator,omitempty"`
}

// A reference from one resource to another.
type Reference struct {
	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for reference
	Reference *Element `json:"_reference,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Plain text narrative that identifies the resource in addition to the resource
	// reference.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier for the target resource. This is used when there is no way to
	// reference the other resource directly, either because the entity it represents
	// is not available through a FHIR server, or because there is no way for the
	// author of the resource to convert a known identifier to an actual location.
	// There is no requirement that a Reference.identifier point to something that is
	// actually exposed as a FHIR instance, but it SHALL point to a business concept
	// that would be expected to be exposed as a FHIR instance, and that instance
	// would need to be of a FHIR resource type allowed by the reference.
	Identifier *Identifier `json:"identifier,omitempty"`

	// A reference to a location at which the other resource is found. The reference
	// may be a relative reference, in which case it is relative to the service base
	// URL, or an absolute URL that resolves to the location where the resource is
	// found. The reference may be version specific or not. If the reference is not to
	// a FHIR RESTful server, then it should be assumed to be version specific.
	// Internal fragment references (start with '#') refer to contained resources.
	Reference_2 *String `json:"reference,omitempty"`

	// The expected type of the target of the reference. If both Reference.type and
	// Reference.reference are populated and Reference.reference is a FHIR URL, both
	// SHALL be consistent.
	//
	// The type is the Canonical URL of Resource Definition that is the type this
	// reference refers to. References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to
	// http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only allowed
	// for logical models (and can only be used in references in logical models, not
	// resources).
	Type_2 *Uri `json:"type,omitempty"`
}

// Regulatory approval, clearance or licensing related to a regulated product,
// treatment, facility or activity that is cited in a guidance, regulation, rule or
// legislative act. An example is Market Authorization relating to a Medicinal
// Product.
type RegulatedAuthorization struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for statusDate
	StatusDate *Element `json:"_statusDate,omitempty"`

	// Additional information or supporting documentation about the authorization.
	AttachedDocument []Reference `json:"attachedDocument,omitempty"`

	// The legal or regulatory framework against which this authorization is granted,
	// or other reasons for it.
	Basis []CodeableConcept `json:"basis,omitempty"`

	// The case or regulatory procedure for granting or amending a regulated
	// authorization. An authorization is granted in response to
	// submissions/applications by those seeking authorization. A case is the
	// administrative process that deals with the application(s) that relate to this
	// and assesses them. Note: This area is subject to ongoing review and the
	// workgroup is seeking implementer feedback on its use (see link at bottom of
	// page).
	Case *RegulatedAuthorizationCase `json:"case,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []RegulatedAuthorizationContainedElem `json:"contained,omitempty"`

	// General textual supporting information.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The organization that has been granted this authorization, by some
	// authoritative body (the 'regulator').
	Holder *Reference `json:"holder,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifier for the authorization, typically assigned by the
	// authorizing body.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Condition for which the use of the regulated product applies.
	Indication []CodeableReference `json:"indication,omitempty"`

	// The intended use of the product, e.g. prevention, treatment, diagnosis.
	IntendedUse *CodeableConcept `json:"intendedUse,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The territory (e.g., country, jurisdiction etc.) in which the authorization has
	// been granted.
	Region []CodeableConcept `json:"region,omitempty"`

	// The regulatory authority or authorizing body granting the authorization. For
	// example, European Medicines Agency (EMA), Food and Drug Administration (FDA),
	// Health Canada (HC), etc.
	Regulator *Reference `json:"regulator,omitempty"`

	// This is a RegulatedAuthorization resource
	ResourceType interface{} `json:"resourceType"`

	// The status that is authorised e.g. approved. Intermediate states and actions
	// can be tracked with cases and applications.
	Status *CodeableConcept `json:"status,omitempty"`

	// The date at which the current status was assigned.
	StatusDate_2 *DateTime `json:"statusDate,omitempty"`

	// The product type, treatment, facility or activity that is being authorized.
	Subject []Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Overall type of this authorization, for example drug marketing approval, orphan
	// drug designation.
	Type *CodeableConcept `json:"type,omitempty"`

	// The time period in which the regulatory approval, clearance or licensing is in
	// effect. As an example, a Marketing Authorization includes the date of
	// authorization and/or an expiration date.
	ValidityPeriod *Period `json:"validityPeriod,omitempty"`
}

// Regulatory approval, clearance or licensing related to a regulated product,
// treatment, facility or activity that is cited in a guidance, regulation, rule or
// legislative act. An example is Market Authorization relating to a Medicinal
// Product.
type RegulatedAuthorizationCase struct {
	// Extensions for dateDateTime
	DateDateTime *Element `json:"_dateDateTime,omitempty"`

	// A regulatory submission from an organization to a regulator, as part of an
	// assessing case. Multiple applications may occur over time, with more or
	// different information to support or modify the submission or the authorization.
	// The applications can be considered as steps within the longer running case or
	// procedure for this authorization process.
	Application []RegulatedAuthorizationCase `json:"application,omitempty"`

	// Relevant date for this case.
	DateDateTime_2 *string `json:"dateDateTime,omitempty"`

	// Relevant date for this case.
	DatePeriod *Period `json:"datePeriod,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifier by which this case can be referenced.
	Identifier *Identifier `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The status associated with the case.
	Status *CodeableConcept `json:"status,omitempty"`

	// The defining type of case.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegulatedAuthorizationCase) UnmarshalJSON(value []byte) error {
	type Plain RegulatedAuthorizationCase
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DateDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.DateDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DateDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = RegulatedAuthorizationCase(plain)
	return nil
}

type RegulatedAuthorizationContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegulatedAuthorization) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in RegulatedAuthorization: required")
	}
	type Plain RegulatedAuthorization
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RegulatedAuthorization(plain)
	return nil
}

// Related artifacts such as dependencies, components, additional documentation,
// justification, or bibliographic references.
type RelatedArtifact struct {
	// Extensions for artifactCanonical
	ArtifactCanonical *Element `json:"_artifactCanonical,omitempty"`

	// Extensions for artifactMarkdown
	ArtifactMarkdown *Element `json:"_artifactMarkdown,omitempty"`

	// Extensions for citation
	Citation *Element `json:"_citation,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for label
	Label *Element `json:"_label,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// The related artifact represented as a canonical or direct reference to a FHIR
	// resource, an Attachment, or directly inline as markdown.
	ArtifactAttachment *Attachment `json:"artifactAttachment,omitempty"`

	// The related artifact represented as a canonical or direct reference to a FHIR
	// resource, an Attachment, or directly inline as markdown.
	ArtifactCanonical_2 *string `json:"artifactCanonical,omitempty"`

	// The related artifact represented as a canonical or direct reference to a FHIR
	// resource, an Attachment, or directly inline as markdown.
	ArtifactMarkdown_2 *string `json:"artifactMarkdown,omitempty"`

	// The related artifact represented as a canonical or direct reference to a FHIR
	// resource, an Attachment, or directly inline as markdown.
	ArtifactReference *Reference `json:"artifactReference,omitempty"`

	// Deprecated in favor of the new artifact[x] element. A bibliographic citation
	// for the related artifact. This text SHOULD be formatted according to an
	// accepted citation format.
	Citation_2 *Markdown `json:"citation,omitempty"`

	// A brief description of the document or knowledge resource being referenced,
	// suitable for display to a consumer.
	Display_2 *String `json:"display,omitempty"`

	// Deprecated in favor of the new artifact[x] element. The document being
	// referenced, represented as an attachment. This is exclusive with the resource
	// element.
	Document *Attachment `json:"document,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A short label that can be used to reference the citation from elsewhere in the
	// containing artifact, such as a footnote index.
	Label_2 *String `json:"label,omitempty"`

	// Deprecated in favor of the new artifact[x] element. The related artifact, such
	// as a library, value set, profile, or other knowledge resource.
	Resource *Canonical `json:"resource,omitempty"`

	// Deprecated in favor of the new artifact[x] element. The related artifact, if
	// the artifact is not a canonical resource, or a resource reference to a
	// canonical resource.
	ResourceReference *Reference `json:"resourceReference,omitempty"`

	// The type of relationship to the related artifact.
	Type_2 *RelatedArtifactType_2 `json:"type,omitempty"`
}

type RelatedArtifactType_2 string

const RelatedArtifactType_2_Citation RelatedArtifactType_2 = "citation"
const RelatedArtifactType_2_ComposedOf RelatedArtifactType_2 = "composed-of"
const RelatedArtifactType_2_DependsOn RelatedArtifactType_2 = "depends-on"
const RelatedArtifactType_2_DerivedFrom RelatedArtifactType_2 = "derived-from"
const RelatedArtifactType_2_Documentation RelatedArtifactType_2 = "documentation"
const RelatedArtifactType_2_Justification RelatedArtifactType_2 = "justification"
const RelatedArtifactType_2_PartOf RelatedArtifactType_2 = "part-of"
const RelatedArtifactType_2_Predecessor RelatedArtifactType_2 = "predecessor"
const RelatedArtifactType_2_Successor RelatedArtifactType_2 = "successor"

var enumValues_RelatedArtifactType_2 = []interface{}{
	"documentation",
	"justification",
	"citation",
	"predecessor",
	"successor",
	"derived-from",
	"depends-on",
	"composed-of",
	"part-of",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelatedArtifactType_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RelatedArtifactType_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RelatedArtifactType_2, v)
	}
	*j = RelatedArtifactType_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelatedArtifact) UnmarshalJSON(value []byte) error {
	type Plain RelatedArtifact
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ArtifactCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ArtifactCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ArtifactCanonical_2", `^\S*$`)
		}
	}
	if plain.ArtifactMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ArtifactMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ArtifactMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	*j = RelatedArtifact(plain)
	return nil
}

// Information about a person that is involved in a patient's health or the care
// for a patient, but who is not the primary target of healthcare.
type RelatedPerson struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for birthDate
	BirthDate *Element `json:"_birthDate,omitempty"`

	// Extensions for gender
	Gender *Element `json:"_gender,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Whether this related person record is in active use.
	Active_2 *Boolean `json:"active,omitempty"`

	// Address where the related person can be contacted or visited.
	Address []Address `json:"address,omitempty"`

	// The date on which the related person was born.
	BirthDate_2 *Date `json:"birthDate,omitempty"`

	// A language which may be used to communicate with the related person about the
	// patient's health.
	Communication []RelatedPersonCommunication `json:"communication,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []RelatedPersonContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Administrative Gender - the gender that the person is considered to have for
	// administration and record keeping purposes.
	Gender_2 *Code `json:"gender,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier for a person within a particular scope.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name associated with the person.
	Name []HumanName `json:"name,omitempty"`

	// The patient this person is related to.
	Patient Reference `json:"patient"`

	// The period of time during which this relationship is or was active. If there
	// are no dates defined, then the interval is unknown.
	Period *Period `json:"period,omitempty"`

	// Image of the person.
	Photo []Attachment `json:"photo,omitempty"`

	// The nature of the personal relationship between the related person and the
	// patient.
	Relationship []CodeableConcept `json:"relationship,omitempty"`

	// This is a RelatedPerson resource
	ResourceType interface{} `json:"resourceType"`

	// The nature of the functional relationship between the patient and the related
	// person.
	Role []CodeableConcept `json:"role,omitempty"`

	// A contact detail for the person, e.g. a telephone number or an email address.
	Telecom []ContactPoint `json:"telecom,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// Information about a person that is involved in a patient's health or the care
// for a patient, but who is not the primary target of healthcare.
type RelatedPersonCommunication struct {
	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language which may be used to communicate with the individual.
	Language CodeableConcept `json:"language"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates whether or not the related person prefers this language (over other
	// languages he or she masters up a certain level).
	Preferred_2 *Boolean `json:"preferred,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelatedPersonCommunication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["language"]; raw != nil && !ok {
		return fmt.Errorf("field language in RelatedPersonCommunication: required")
	}
	type Plain RelatedPersonCommunication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RelatedPersonCommunication(plain)
	return nil
}

type RelatedPersonContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelatedPerson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in RelatedPerson: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in RelatedPerson: required")
	}
	type Plain RelatedPerson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RelatedPerson(plain)
	return nil
}

// RelativeTime expresses a time or time period as relative to the time of an event
// defined in data types other than dateTime.
type RelativeTime struct {
	// Extensions for contextPath
	ContextPath *Element `json:"_contextPath,omitempty"`

	// Extensions for text
	Text *Element `json:"_text,omitempty"`

	// Coded representation of the event used as a base point (reference point) in
	// time.
	ContextCode *CodeableConcept `json:"contextCode,omitempty"`

	// The type of event used as a base point.  Instances of this definition will
	// establish the context for evaluating the path to determine the base time for
	// the offset.
	ContextDefinition *Canonical `json:"contextDefinition,omitempty"`

	// Path to the element defining the basis for the relative time. Any valid
	// FHIRPath expression.
	ContextPath_2 *String `json:"contextPath,omitempty"`

	// The specific event occurrence or resource context used as a base point
	// (reference point) in time.  This establishes the context in which the 'path' is
	// evaluated.
	ContextReference *Reference `json:"contextReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An offset or offset range before (negative values) or after (positive values)
	// the event. Range is limited to time-valued quantities (Durations).
	OffsetDuration *Duration `json:"offsetDuration,omitempty"`

	// An offset or offset range before (negative values) or after (positive values)
	// the event. Range is limited to time-valued quantities (Durations).
	OffsetRange *Range `json:"offsetRange,omitempty"`

	// Free-text (human-readable) description.
	Text_2 *String `json:"text,omitempty"`
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestration struct {
	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for instantiatesCanonical
	InstantiatesCanonical []Element `json:"_instantiatesCanonical,omitempty"`

	// Extensions for instantiatesUri
	InstantiatesUri []Element `json:"_instantiatesUri,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The actions, if any, produced by the evaluation of the artifact.
	Action []RequestOrchestrationAction `json:"action,omitempty"`

	// Provides a reference to the author of the request orchestration.
	Author *Reference `json:"author,omitempty"`

	// Indicates when the request orchestration was created.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// A plan, proposal or order that is fulfilled in whole or in part by this
	// request.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// A code that identifies what the overall request orchestration is.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []RequestOrchestrationContainedElem `json:"contained,omitempty"`

	// Describes the context of the request orchestration, if any.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Goals that are intended to be achieved by following the requests in this
	// RequestOrchestration.
	Goal []Reference `json:"goal,omitempty"`

	// A shared identifier common to multiple independent Request instances that were
	// activated/authorized more or less simultaneously by a single author.  The
	// presence of the same identifier on each request ties those requests together
	// and may have business ramifications in terms of reporting of results, billing,
	// etc.  E.g. a requisition number shared by a set of lab tests ordered together,
	// or a prescription number shared by all meds ordered at one time.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Allows a service to provide a unique, business identifier for the request.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A canonical URL referencing a FHIR-defined protocol, guideline, orderset or
	// other definition that is adhered to in whole or in part by this request.
	InstantiatesCanonical_2 []Canonical `json:"instantiatesCanonical,omitempty"`

	// A URL referencing an externally defined protocol, guideline, orderset or other
	// definition that is adhered to in whole or in part by this request.
	InstantiatesUri_2 []Uri `json:"instantiatesUri,omitempty"`

	// Indicates the level of authority/intentionality associated with the request and
	// where the request fits into the workflow chain.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Provides a mechanism to communicate additional information about the response.
	Note []Annotation `json:"note,omitempty"`

	// Indicates how quickly the request should be addressed with respect to other
	// requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// Describes the reason for the request orchestration in coded or textual form.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Completed or terminated request(s) whose function is taken by this new request.
	Replaces []Reference `json:"replaces,omitempty"`

	// This is a RequestOrchestration resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of the request. For request orchestrations, the status
	// reflects the status of all the requests in the orchestration.
	Status_2 *Code `json:"status,omitempty"`

	// The subject for which the request orchestration was created.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationAction struct {
	// Extensions for applicabilityBehavior
	ApplicabilityBehavior *Element `json:"_applicabilityBehavior,omitempty"`

	// Extensions for cardinalityBehavior
	CardinalityBehavior *Element `json:"_cardinalityBehavior,omitempty"`

	// Extensions for definitionCanonical
	DefinitionCanonical *Element `json:"_definitionCanonical,omitempty"`

	// Extensions for definitionUri
	DefinitionUri *Element `json:"_definitionUri,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for groupingBehavior
	GroupingBehavior *Element `json:"_groupingBehavior,omitempty"`

	// Extensions for linkId
	LinkID *Element `json:"_linkId,omitempty"`

	// Extensions for precheckBehavior
	PrecheckBehavior *Element `json:"_precheckBehavior,omitempty"`

	// Extensions for prefix
	Prefix *Element `json:"_prefix,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for requiredBehavior
	RequiredBehavior *Element `json:"_requiredBehavior,omitempty"`

	// Extensions for selectionBehavior
	SelectionBehavior *Element `json:"_selectionBehavior,omitempty"`

	// Extensions for textEquivalent
	TextEquivalent *Element `json:"_textEquivalent,omitempty"`

	// Extensions for timingDateTime
	TimingDateTime *Element `json:"_timingDateTime,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Sub actions.
	Action []RequestOrchestrationAction `json:"action,omitempty"`

	// All - meaning the applicability of each child action is evaluated
	// independently; if a child action is applicable according to the applicability
	// criteria, it is applied. Any - meaning that each child action is evaluated in
	// order, and the first action that returns an applicability of true will be
	// applied, and processing of the parent action will stop. If not specified, the
	// default behavior of All is used.
	ApplicabilityBehavior_2 *Code `json:"applicabilityBehavior,omitempty"`

	// Defines whether the action can be selected multiple times.
	CardinalityBehavior_2 *Code `json:"cardinalityBehavior,omitempty"`

	// A code that provides meaning for the action or action group. For example, a
	// section may have a LOINC code for a section of a documentation template.
	Code []CodeableConcept `json:"code,omitempty"`

	// An expression that describes applicability criteria, or start/stop conditions
	// for the action.
	Condition []RequestOrchestrationCondition `json:"condition,omitempty"`

	// A reference to an ActivityDefinition that describes the action to be taken in
	// detail, a Measure that specifies a measure to be evaluated, a MessageDefinition
	// that specifies a message to be sent, a PlanDefinition that describes a series
	// of actions to be taken, a Questionnaire that should be filled out, a
	// SpecimenDefinition describing a specimen to be collected, an
	// ObservationDefinition that specifies what observation should be captured, or an
	// OperationDefinition that specifies what operation should be invoked. When the
	// value is a uri, it is intended to be a reference to non-FHIR content that
	// characterizes the action to be performed. This option is allowed to enable the
	// PlanDefinition to be used to provide semi-structured representation, when the
	// guidance is not computable, but there is still value in elaborating the overall
	// structure with a PlanDefinition. The intended behavior when a definitionUri is
	// realized as part of an apply is that it is copied to the resulting
	// RequestOrchestration so that it is available to the consuming system. How that
	// system interprets that uri is not specified.
	DefinitionCanonical_2 *string `json:"definitionCanonical,omitempty"`

	// A reference to an ActivityDefinition that describes the action to be taken in
	// detail, a Measure that specifies a measure to be evaluated, a MessageDefinition
	// that specifies a message to be sent, a PlanDefinition that describes a series
	// of actions to be taken, a Questionnaire that should be filled out, a
	// SpecimenDefinition describing a specimen to be collected, an
	// ObservationDefinition that specifies what observation should be captured, or an
	// OperationDefinition that specifies what operation should be invoked. When the
	// value is a uri, it is intended to be a reference to non-FHIR content that
	// characterizes the action to be performed. This option is allowed to enable the
	// PlanDefinition to be used to provide semi-structured representation, when the
	// guidance is not computable, but there is still value in elaborating the overall
	// structure with a PlanDefinition. The intended behavior when a definitionUri is
	// realized as part of an apply is that it is copied to the resulting
	// RequestOrchestration so that it is available to the consuming system. How that
	// system interprets that uri is not specified.
	DefinitionUri_2 *string `json:"definitionUri,omitempty"`

	// A short description of the action used to provide a summary to display to the
	// user.
	Description_2 *Markdown `json:"description,omitempty"`

	// Didactic or other informational resources associated with the action that can
	// be provided to the CDS recipient. Information resources can include inline text
	// commentary and links to web resources.
	Documentation []RelatedArtifact `json:"documentation,omitempty"`

	// Customizations that should be applied to the statically defined resource. For
	// example, if the dosage of a medication must be computed based on the patient's
	// weight, a customization would be used to specify an expression that calculated
	// the weight, and the path on the resource that would contain the result.
	DynamicValue []RequestOrchestrationDynamicValue `json:"dynamicValue,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Goals that are intended to be achieved by following the requests in this
	// action.
	Goal []Reference `json:"goal,omitempty"`

	// Defines the grouping behavior for the action and its children.
	GroupingBehavior_2 *Code `json:"groupingBehavior,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Defines input data requirements for the action.
	Input []RequestOrchestrationInput `json:"input,omitempty"`

	// The linkId of the action from the PlanDefinition that corresponds to this
	// action in the RequestOrchestration resource.
	LinkID_2 *String `json:"linkId,omitempty"`

	// Identifies the facility where the action will occur; e.g. home, hospital,
	// specific clinic, etc.
	Location *CodeableReference `json:"location,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Defines the outputs of the action, if any.
	Output []RequestOrchestrationOutput `json:"output,omitempty"`

	// The participant that should perform or be responsible for this action.
	Participant []RequestOrchestrationParticipant `json:"participant,omitempty"`

	// Defines whether the action should usually be preselected.
	PrecheckBehavior_2 *Code `json:"precheckBehavior,omitempty"`

	// A user-visible prefix for the action. For example a section or item numbering
	// such as 1. or A.
	Prefix_2 *String `json:"prefix,omitempty"`

	// Indicates how quickly the action should be addressed with respect to other
	// actions.
	Priority_2 *Code `json:"priority,omitempty"`

	// A relationship to another action such as "before" or "30-60 minutes after start
	// of".
	RelatedAction []RequestOrchestrationRelatedAction `json:"relatedAction,omitempty"`

	// Defines expectations around whether an action is required.
	RequiredBehavior_2 *Code `json:"requiredBehavior,omitempty"`

	// The resource that is the target of the action (e.g. CommunicationRequest).
	Resource *Reference `json:"resource,omitempty"`

	// Defines the selection behavior for the action and its children.
	SelectionBehavior_2 *Code `json:"selectionBehavior,omitempty"`

	// A text equivalent of the action to be performed. This provides a
	// human-interpretable description of the action when the definition is consumed
	// by a system that might not be capable of interpreting it dynamically.
	TextEquivalent_2 *Markdown `json:"textEquivalent,omitempty"`

	// An optional value describing when the action should be performed.
	TimingAge *Age `json:"timingAge,omitempty"`

	// An optional value describing when the action should be performed.
	TimingDateTime_2 *string `json:"timingDateTime,omitempty"`

	// An optional value describing when the action should be performed.
	TimingDuration *Duration `json:"timingDuration,omitempty"`

	// An optional value describing when the action should be performed.
	TimingPeriod *Period `json:"timingPeriod,omitempty"`

	// An optional value describing when the action should be performed.
	TimingRange *Range `json:"timingRange,omitempty"`

	// An optional value describing when the action should be performed.
	TimingRelativeTime *RelativeTime `json:"timingRelativeTime,omitempty"`

	// An optional value describing when the action should be performed.
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// The title of the action displayed to a user.
	Title_2 *String `json:"title,omitempty"`

	// A reference to a StructureMap resource that defines a transform that can be
	// executed to produce the intent resource using the ActivityDefinition instance
	// as the input.
	Transform *Canonical `json:"transform,omitempty"`

	// The type of action to perform (create, update, remove).
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestOrchestrationAction) UnmarshalJSON(value []byte) error {
	type Plain RequestOrchestrationAction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DefinitionCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefinitionCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefinitionCanonical_2", `^\S*$`)
		}
	}
	if plain.DefinitionUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DefinitionUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DefinitionUri_2", `^\S*$`)
		}
	}
	if plain.TimingDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimingDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = RequestOrchestrationAction(plain)
	return nil
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationCondition struct {
	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// An expression that returns true or false, indicating whether or not the
	// condition is satisfied.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The kind of condition.
	Kind_2 *Code `json:"kind,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type RequestOrchestrationContainedElem interface{}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationDynamicValue struct {
	// Extensions for path
	Path *Element `json:"_path,omitempty"`

	// An expression specifying the value of the customized element.
	Expression *Expression `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The path to the element to be customized. This is the path on the resource that
	// will hold the result of the calculation defined by the expression. The
	// specified path SHALL be a FHIRPath resolvable on the specified target type of
	// the ActivityDefinition, and SHALL consist only of identifiers, constant
	// indexers, and a restricted subset of functions. The path is allowed to contain
	// qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	Path_2 *String `json:"path,omitempty"`
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationInput struct {
	// Extensions for relatedData
	RelatedData *Element `json:"_relatedData,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Points to an existing input or output element that provides data to this input.
	RelatedData_2 *ID `json:"relatedData,omitempty"`

	// Defines the data that is to be provided as input to the action.
	Requirement *DataRequirement `json:"requirement,omitempty"`

	// A human-readable label for the data requirement used to label data flows in
	// BPMN or similar diagrams. Also provides a human readable label when rendering
	// the data requirement that conveys its purpose to human readers.
	Title_2 *String `json:"title,omitempty"`
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationOutput struct {
	// Extensions for relatedData
	RelatedData *Element `json:"_relatedData,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Points to an existing input or output element that is results as output from
	// the action.
	RelatedData_2 *String `json:"relatedData,omitempty"`

	// Defines the data that results as output from the action.
	Requirement *DataRequirement `json:"requirement,omitempty"`

	// A human-readable label for the data requirement used to label data flows in
	// BPMN or similar diagrams. Also provides a human readable label when rendering
	// the data requirement that conveys its purpose to human readers.
	Title_2 *String `json:"title,omitempty"`
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationParticipant struct {
	// Extensions for actorCanonical
	ActorCanonical *Element `json:"_actorCanonical,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// A reference to the actual participant.
	ActorCanonical_2 *string `json:"actorCanonical,omitempty"`

	// A reference to the actual participant.
	ActorReference *Reference `json:"actorReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Indicates how the actor will be involved in the action - author, reviewer,
	// witness, etc.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The role the participant should play in performing the described action.
	Role *CodeableConcept `json:"role,omitempty"`

	// The type of participant in the action.
	Type_2 *Code `json:"type,omitempty"`

	// The type of participant in the action.
	TypeCanonical *Canonical `json:"typeCanonical,omitempty"`

	// The type of participant in the action.
	TypeReference *Reference `json:"typeReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestOrchestrationParticipant) UnmarshalJSON(value []byte) error {
	type Plain RequestOrchestrationParticipant
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ActorCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ActorCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ActorCanonical_2", `^\S*$`)
		}
	}
	*j = RequestOrchestrationParticipant(plain)
	return nil
}

// A set of related requests that can be used to capture intended activities that
// have inter-dependencies such as "give this medication after that one".
type RequestOrchestrationRelatedAction struct {
	// Extensions for endRelationship
	EndRelationship *Element `json:"_endRelationship,omitempty"`

	// Extensions for relationship
	Relationship *Element `json:"_relationship,omitempty"`

	// Extensions for targetId
	TargetID *Element `json:"_targetId,omitempty"`

	// The relationship of the end of this action to the related action.
	EndRelationship_2 *Code `json:"endRelationship,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A duration or range of durations to apply to the relationship. For example,
	// 30-60 minutes before.
	OffsetDuration *Duration `json:"offsetDuration,omitempty"`

	// A duration or range of durations to apply to the relationship. For example,
	// 30-60 minutes before.
	OffsetRange *Range `json:"offsetRange,omitempty"`

	// The relationship of this action to the related action.
	Relationship_2 *Code `json:"relationship,omitempty"`

	// The element id of the target related action.
	TargetID_2 *ID `json:"targetId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestOrchestration) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in RequestOrchestration: required")
	}
	type Plain RequestOrchestration
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RequestOrchestration(plain)
	return nil
}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type Requirements struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for reference
	Reference []Element `json:"_reference,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// An actor these requirements are in regard to.
	Actor []RequirementsActor `json:"actor,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []RequirementsContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the Requirements and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the Requirements.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the Requirements was published. The date
	// must change when the business version changes and it must change if the status
	// code changes. In addition, it should change when the substantive content of the
	// Requirements changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// Another set of Requirements that this set of Requirements builds on and
	// updates.
	DerivedFrom []Canonical `json:"derivedFrom,omitempty"`

	// A free text natural language description of the requirements.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this Requirements is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this Requirements when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Points to requirements defined elsewhere that have the same force as if they
	// were defined in this instance.
	Imports []RequirementsImports `json:"imports,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the Requirements. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the Requirements.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this Requirements is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// A reference to another artifact that created this set of requirements. This
	// could be a profile, etc., or external regulation, or business requirements
	// expressed elsewhere. This URI is intended to point to a specific web page for
	// an artifact, not a canonical URL.  If pointing to HL7 specifications, it is
	// best to point to the version-specific URL.
	Reference_2 []Url `json:"reference,omitempty"`

	// This is a Requirements resource
	ResourceType interface{} `json:"resourceType"`

	// The actual statement of conformance requirement.
	Statement []RequirementsStatement `json:"statement,omitempty"`

	// The status of this Requirements. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the Requirements.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this Requirements when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this Requirements is (or will be)
	// published. This URL can be the target of a canonical reference. It SHALL remain
	// the same when the Requirements is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate Requirements
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the Requirements when
	// it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the Requirements author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type RequirementsActor struct {
	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A unique string used to reference the actor from specific requirements.
	Key_2 *ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical for an actor relevant to some of the requirements.
	Reference Canonical `json:"reference"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequirementsActor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in RequirementsActor: required")
	}
	type Plain RequirementsActor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RequirementsActor(plain)
	return nil
}

type RequirementsContainedElem interface{}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type RequirementsDerivedFrom struct {
	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The key, either within this resource or the specified Requirements resource
	// this statement is derivedFrom.
	Key_2 *ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical of the Requirements instance this statement is derivedFrom.
	Reference *Canonical `json:"reference,omitempty"`
}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type RequirementsImports struct {
	// Extensions for key
	Key []Element `json:"_key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The key of a statement to treat as part of the set of requirements defined in
	// this instance.
	Key_2 []ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical for the Requirements resource to import statements from.
	Reference Canonical `json:"reference"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequirementsImports) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in RequirementsImports: required")
	}
	type Plain RequirementsImports
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RequirementsImports(plain)
	return nil
}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type RequirementsPartOf struct {
	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The key, either within this resource or the specified Requirements resource
	// this statement is a part of.
	Key_2 *ID `json:"key,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical of the Requirements instance this statement is a part of.
	Reference *Canonical `json:"reference,omitempty"`
}

// A set of requirements - a list of features or behaviors of designed systems that
// are necessary to achieve organizational or regulatory goals.
type RequirementsStatement struct {
	// Extensions for actor
	Actor []Element `json:"_actor,omitempty"`

	// Extensions for conditionality
	Conditionality *Element `json:"_conditionality,omitempty"`

	// Extensions for conformance
	Conformance []Element `json:"_conformance,omitempty"`

	// Extensions for key
	Key *Element `json:"_key,omitempty"`

	// Extensions for label
	Label *Element `json:"_label,omitempty"`

	// Extensions for reference
	Reference []Element `json:"_reference,omitempty"`

	// Extensions for requirement
	Requirement *Element `json:"_requirement,omitempty"`

	// Extensions for satisfiedBy
	SatisfiedBy []Element `json:"_satisfiedBy,omitempty"`

	// A reference to the key of an actor listed in Requirements.actor that is
	// relevant to this requirement statement.
	Actor_2 []ID `json:"actor,omitempty"`

	// Categorization might be done automatically (inferred by code) or manually by
	// user assertion. The absence of a category may limit the ability to determine
	// when the element should be handled, so strong consideration should be given to
	// how systems will be able to determine category values for legacy data and how
	// data that cannot be categorized will be handled. As well, some categories might
	// not be mutually exclusive, so systems should prepare for multiple declared
	// categories - even within a single category 'axis'.
	Category []Coding `json:"category,omitempty"`

	// This boolean flag is set to true of the text of the requirement is conditional
	// on something e.g. it includes language like 'if x then y'. This conditionality
	// flag is introduced for purposes of filtering and colour highlighting etc.
	Conditionality_2 *Boolean `json:"conditionality,omitempty"`

	// A short human usable label for this statement.
	Conformance_2 []Code `json:"conformance,omitempty"`

	// Indicates that this statement is refining, tightening, or establishing more
	// context for the referenced requirement/statement.
	DerivedFrom *RequirementsDerivedFrom `json:"derivedFrom,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Key that identifies this statement (unique within this resource).
	Key_2 *ID `json:"key,omitempty"`

	// A short human usable label for this statement.
	Label_2 *String `json:"label,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Identifies a higher-level requirement or statement which this referencing
	// statement is a logical sub-requirement of.  I.e. This statement is a necessary
	// step to achieving the referenced requirement/statement.
	PartOf *RequirementsPartOf `json:"partOf,omitempty"`

	// A reference to another artifact that created this requirement. This could be a
	// profile, etc., or external regulation, or business requirements expressed
	// elsewhere. This URI is intended to point to a specific web page for an
	// artifact, not a canonical URL.  If pointing to HL7 specifications, it is best
	// to point to the version-specific URL.
	Reference_2 []Url `json:"reference,omitempty"`

	// The actual requirement for human consumption.
	Requirement_2 *Markdown `json:"requirement,omitempty"`

	// A reference to another artifact that satisfies this requirement. This could be
	// a profile, extension, or an element in one of those, or a CapabilityStatement,
	// OperationDefinition, SearchParameter, CodeSystem(/code), ValueSet, Library etc.
	SatisfiedBy_2 []Url `json:"satisfiedBy,omitempty"`

	// Who asked for this statement to be a requirement. By default, it's assumed that
	// the publisher knows who it is if it matters.
	Source []Reference `json:"source,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Requirements) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Requirements: required")
	}
	type Plain Requirements
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = Requirements(plain)
	return nil
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudy struct {
	// Extensions for citeAs
	CiteAs *Element `json:"_citeAs,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for descriptionSummary
	DescriptionSummary *Element `json:"_descriptionSummary,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Sponsors, collaborators, and other parties.
	AssociatedParty []ResearchStudyAssociatedParty `json:"associatedParty,omitempty"`

	// Display of the bibliographic citation of this ResearchStudy.
	CiteAs_2 *Markdown `json:"citeAs,omitempty"`

	// Additional grouping mechanism or categorization of a research study. Example:
	// FDA regulated device, FDA regulated drug, MPG Paragraph 23b (a German legal
	// requirement), IRB-exempt, etc. Implementation Note: do not use the classifier
	// element to support existing semantics that are already supported thru explicit
	// elements in the resource.
	Classifier []CodeableConcept `json:"classifier,omitempty"`

	// Describes an expected event or sequence of events for one of the subjects of a
	// study. E.g. for a living subject: exposure to drug A, wash-out, exposure to
	// drug B, wash-out, follow-up. E.g. for a stability study: {store sample from lot
	// A at 25 degrees for 1 month}, {store sample from lot A at 40 degrees for 1
	// month}.
	ComparisonGroup []ResearchStudyComparisonGroup `json:"comparisonGroup,omitempty"`

	// The condition that is the focus of the study. For example, In a study to
	// examine risk factors for Lupus, might have as an inclusion criterion "healthy
	// volunteer", but the target condition code would be a Lupus SNOMED code.
	Condition []CodeableConcept `json:"condition,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ResearchStudyContainedElem `json:"contained,omitempty"`

	// The date (and optionally time) when the ResearchStudy Resource was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the ResearchStudy Resource changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A detailed and human-readable narrative of the study. E.g., study abstract.
	Description_2 *Markdown `json:"description,omitempty"`

	// A brief text for explaining the study.
	DescriptionSummary_2 *Markdown `json:"descriptionSummary,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The medication(s), food(s), therapy(ies), device(s) or other concerns or
	// interventions that the study is seeking to gain more information about.
	Focus []CodeableReference `json:"focus,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this research study by the sponsor or other systems.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Key terms to aid in searching for or filtering the study.
	Keyword []CodeableConcept `json:"keyword,omitempty"`

	// Additional names for the study.
	Label []ResearchStudyLabel `json:"label,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name for this study (computer friendly).
	Name_2 *String `json:"name,omitempty"`

	// Comments made about the study by the performer, subject or other participants.
	Note []Annotation `json:"note,omitempty"`

	// A goal that the study is aiming to achieve in terms of a scientific question to
	// be answered by the analysis of data collected during the study.
	Objective []ResearchStudyObjective `json:"objective,omitempty"`

	// A larger research study of which this particular study is a component or step.
	PartOf []Reference `json:"partOf,omitempty"`

	// Identifies the start date and the expected (or actual, depending on status) end
	// date for the study.
	Period *Period `json:"period,omitempty"`

	// The stage in the progression of a therapy from initial experimental use in
	// humans in clinical trials to post-market evaluation.
	Phase *CodeableConcept `json:"phase,omitempty"`

	// The type of study based upon the intent of the study activities. A
	// classification of the intent of the study.
	PrimaryPurposeType *CodeableConcept `json:"primaryPurposeType,omitempty"`

	// Status of study with time for that status.
	ProgressStatus []ResearchStudyProgressStatus `json:"progressStatus,omitempty"`

	// The set of steps expected to be performed as part of the execution of the
	// study.
	Protocol []Reference `json:"protocol,omitempty"`

	// Target or actual group of participants enrolled in study.
	Recruitment *ResearchStudyRecruitment `json:"recruitment,omitempty"`

	// A country, state or other area where the study is taking place rather than its
	// precise geographic location or address.
	Region []CodeableConcept `json:"region,omitempty"`

	// Relationships that this ResearchStudy has with other FHIR or non-FHIR resources
	// that already exist.
	RelatesTo []ResearchStudyRelatesTo `json:"relatesTo,omitempty"`

	// This is a ResearchStudy resource
	ResourceType interface{} `json:"resourceType"`

	// Link to one or more sets of results generated by the study. Could also link to
	// a research registry holding the results such as ClinicalTrials.gov.
	Result []Reference `json:"result,omitempty"`

	// A facility in which study activities are conducted.
	Site []Reference `json:"site,omitempty"`

	// The publication state of the resource (not of the study).
	Status_2 *Code `json:"status,omitempty"`

	// Codes categorizing the type of study such as investigational vs. observational,
	// type of blinding, type of randomization, safety vs. efficacy, etc.
	StudyDesign []CodeableConcept `json:"studyDesign,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The human readable name of the research study.
	Title_2 *String `json:"title,omitempty"`

	// Canonical identifier for this study resource, represented as a globally unique
	// URI.
	Url_2 *Uri `json:"url,omitempty"`

	// The business version for the study record.
	Version_2 *String `json:"version,omitempty"`

	// A description and/or code explaining the premature termination of the study.
	WhyStopped *CodeableConcept `json:"whyStopped,omitempty"`
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyAssociatedParty struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// A categorization other than role for the associated party.
	Classifier []CodeableConcept `json:"classifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of associated party.
	Name_2 *String `json:"name,omitempty"`

	// Individual or organization associated with study (use practitionerRole to
	// specify their organisation).
	Party *Reference `json:"party,omitempty"`

	// Identifies the start date and the end date of the associated party in the role.
	Period []Period `json:"period,omitempty"`

	// Type of association.
	Role CodeableConcept `json:"role"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchStudyAssociatedParty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in ResearchStudyAssociatedParty: required")
	}
	type Plain ResearchStudyAssociatedParty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchStudyAssociatedParty(plain)
	return nil
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyComparisonGroup struct {
	// Extensions for actualNumber
	ActualNumber *Element `json:"_actualNumber,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for targetNumber
	TargetNumber *Element `json:"_targetNumber,omitempty"`

	// Actual total number of participants enrolled in the comparison group.
	ActualNumber_2 *UnsignedInt `json:"actualNumber,omitempty"`

	// Description of the comparison Group.
	Description_2 *Markdown `json:"description,omitempty"`

	// Inclusion and exclusion criteria for the comparison group as a subset of the
	// eligibility for the overall study. The referenced Group Resource should have a
	// membership element value of either 'definitional' or 'conceptual'.
	Eligibility *Reference `json:"eligibility,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Group of participants who were enrolled in the comparison group as a subset of
	// those enrolled in the overall study. The referenced Group Resource should have
	// a membership element value of 'enumerated'.
	ObservedGroup *Reference `json:"observedGroup,omitempty"`

	// Estimated total number of participants to be enrolled in the comparison group.
	TargetNumber_2 *UnsignedInt `json:"targetNumber,omitempty"`
}

type ResearchStudyContainedElem interface{}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyEventHandling struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Text summary of event handling.
	Description_2 *Markdown `json:"description,omitempty"`

	// The event.
	Event *CodeableConcept `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The group that is affected by this event handling.
	Group *CodeableConcept `json:"group,omitempty"`

	// How the data is handled.
	Handling *CodeableConcept `json:"handling,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyLabel struct {
	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Used to express the specific language of the title.
	Language_2 *Code `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Kind of name.
	Type *CodeableConcept `json:"type,omitempty"`

	// The name.
	Value_2 *String `json:"value,omitempty"`
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyObjective struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Free text description of the objective of the study. This is what the study is
	// trying to achieve rather than how it is going to achieve it (see
	// ResearchStudy.description).
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Unique, human-readable label for this objective of the study.
	Name_2 *String `json:"name,omitempty"`

	// An "outcome measure", "endpoint", "effect measure" or "measure of effect" is a
	// specific measurement or observation used to quantify the effect of experimental
	// variables on the participants in a study, or for observational studies, to
	// describe patterns of diseases or traits or associations with exposures, risk
	// factors or treatment.
	OutcomeMeasure []ResearchStudyOutcomeMeasure `json:"outcomeMeasure,omitempty"`

	// The kind of study objective.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyOutcomeMeasure struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Comparison group for comparison.
	Comparator *Reference `json:"comparator,omitempty"`

	// Description of the outcome measure.
	Description_2 *Markdown `json:"description,omitempty"`

	// Definition of the outcome measure.
	Endpoint Reference `json:"endpoint"`

	// The planned statistical model for analysis of a single endpoint.
	EndpointAnalysisPlan *Reference `json:"endpointAnalysisPlan,omitempty"`

	// Handling of intercurrent event.
	EventHandling []ResearchStudyEventHandling `json:"eventHandling,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Comparison group of interest.
	Intervention *Reference `json:"intervention,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Label for the outcome measure.
	Name_2 *String `json:"name,omitempty"`

	// Population for this estimand.
	Population *Reference `json:"population,omitempty"`

	// Statistical measure for treatment effect estimate.
	SummaryMeasure *CodeableConcept `json:"summaryMeasure,omitempty"`

	// The kind of outcome measure.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchStudyOutcomeMeasure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field endpoint in ResearchStudyOutcomeMeasure: required")
	}
	type Plain ResearchStudyOutcomeMeasure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchStudyOutcomeMeasure(plain)
	return nil
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyProgressStatus struct {
	// Extensions for actual
	Actual *Element `json:"_actual,omitempty"`

	// An indication of whether or not the date is a known date when the state changed
	// or will change. A value of true indicates a known date. A value of false
	// indicates an estimated date.
	Actual_2 *Boolean `json:"actual,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Date range.
	Period *Period `json:"period,omitempty"`

	// Label for status or state (e.g. recruitment status).
	State CodeableConcept `json:"state"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchStudyProgressStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in ResearchStudyProgressStatus: required")
	}
	type Plain ResearchStudyProgressStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchStudyProgressStatus(plain)
	return nil
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyRecruitment struct {
	// Extensions for actualNumber
	ActualNumber *Element `json:"_actualNumber,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for targetNumber
	TargetNumber *Element `json:"_targetNumber,omitempty"`

	// Group of participants who were enrolled in study. The referenced Group Resource
	// should have a membership element value of 'enumerated'.
	ActualGroup *Reference `json:"actualGroup,omitempty"`

	// Actual total number of participants enrolled in study.
	ActualNumber_2 *UnsignedInt `json:"actualNumber,omitempty"`

	// Free text description of the recruitment of the study.
	Description_2 *Markdown `json:"description,omitempty"`

	// Inclusion and exclusion criteria. The referenced Group Resource should have a
	// membership element value of either 'definitional' or 'conceptual'.
	Eligibility *Reference `json:"eligibility,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Estimated total number of participants to be enrolled.
	TargetNumber_2 *UnsignedInt `json:"targetNumber,omitempty"`
}

// A research study is a scientific investigation designed to generate
// health-related knowledge. This can include clinical trials involving human
// participants (or animals in the case of veterinary clinical trials). These
// studies may be related to new ways to screen, prevent, diagnose, and treat
// disease. Research studies may also analyze data collected from individuals in
// the past (retrospective studies) or future (prospective studies) to understand
// specific outcomes or trends in particular populations.
type ResearchStudyRelatesTo struct {
	// Extensions for targetCanonical
	TargetCanonical *Element `json:"_targetCanonical,omitempty"`

	// Extensions for targetMarkdown
	TargetMarkdown *Element `json:"_targetMarkdown,omitempty"`

	// Extensions for targetUri
	TargetUri *Element `json:"_targetUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The artifact that is related to this ResearchStudy Resource.
	TargetAttachment *Attachment `json:"targetAttachment,omitempty"`

	// The artifact that is related to this ResearchStudy Resource.
	TargetCanonical_2 *string `json:"targetCanonical,omitempty"`

	// The artifact that is related to this ResearchStudy Resource.
	TargetMarkdown_2 *string `json:"targetMarkdown,omitempty"`

	// The artifact that is related to this ResearchStudy Resource.
	TargetReference *Reference `json:"targetReference,omitempty"`

	// The artifact that is related to this ResearchStudy Resource.
	TargetUri_2 *string `json:"targetUri,omitempty"`

	// The type of relationship to the related artifact.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchStudyRelatesTo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ResearchStudyRelatesTo: required")
	}
	type Plain ResearchStudyRelatesTo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TargetCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetCanonical_2", `^\S*$`)
		}
	}
	if plain.TargetMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.TargetMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.TargetUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.TargetUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TargetUri_2", `^\S*$`)
		}
	}
	*j = ResearchStudyRelatesTo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchStudy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ResearchStudy: required")
	}
	type Plain ResearchStudy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchStudy(plain)
	return nil
}

// A ResearchSubject is a participant or object which is the recipient of
// investigative activities in a research study.
type ResearchSubject struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A group to which the subject is assigned. This group assignment is used for
	// administration or analysis.
	ComparisonGroup []CodeableReference `json:"comparisonGroup,omitempty"`

	// Agreement to participate in a study as well as other research agreements, e.g.
	// to acknowledge additional risks, to agree to a protocol deviation, or to agree
	// to more invasive validation subsidies.
	Consent []Reference `json:"consent,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ResearchSubjectContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this research subject for a study.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The dates the subject began and ended their participation in the study.
	Period *Period `json:"period,omitempty"`

	// This is a ResearchSubject resource
	ResourceType interface{} `json:"resourceType"`

	// The publication state of the resource (not of the subject).
	Status_2 *Code `json:"status,omitempty"`

	// Reference to the study the subject is participating in.
	Study Reference `json:"study"`

	// The record of the person, animal or other entity involved in the study.
	Subject Reference `json:"subject"`

	// A significant event in the progress of a ResearchSubject.
	SubjectMilestone []ResearchSubjectSubjectMilestone `json:"subjectMilestone,omitempty"`

	// A duration in the lifecycle of the ResearchSubject within a ResearchStudy.
	SubjectState []ResearchSubjectSubjectState `json:"subjectState,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type ResearchSubjectContainedElem interface{}

// A ResearchSubject is a participant or object which is the recipient of
// investigative activities in a research study.
type ResearchSubjectSubjectMilestone struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// The date/time when this milestone event was completed.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A specific event in the research subject's journey through a research study.
	Milestone CodeableConcept `json:"milestone"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A rationale that provides additional clarification for the milestone that was
	// captured or documented.
	Reason []CodeableConcept `json:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchSubjectSubjectMilestone) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["milestone"]; raw != nil && !ok {
		return fmt.Errorf("field milestone in ResearchSubjectSubjectMilestone: required")
	}
	type Plain ResearchSubjectSubjectMilestone
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchSubjectSubjectMilestone(plain)
	return nil
}

// A ResearchSubject is a participant or object which is the recipient of
// investigative activities in a research study.
type ResearchSubjectSubjectState struct {
	// Extensions for endDate
	EndDate *Element `json:"_endDate,omitempty"`

	// Extensions for startDate
	StartDate *Element `json:"_startDate,omitempty"`

	// Identifies the aspect of the subject's journey that the state refers to.
	Code CodeableConcept `json:"code"`

	// The date a research subject exited or left the given state.
	EndDate_2 *DateTime `json:"endDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The reason for the state change. If coded it should follow the formal subject
	// state model.
	Reason *CodeableConcept `json:"reason,omitempty"`

	// The date a research subject entered the given state.
	StartDate_2 *DateTime `json:"startDate,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchSubjectSubjectState) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ResearchSubjectSubjectState: required")
	}
	type Plain ResearchSubjectSubjectState
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchSubjectSubjectState(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResearchSubject) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ResearchSubject: required")
	}
	if _, ok := raw["study"]; raw != nil && !ok {
		return fmt.Errorf("field study in ResearchSubject: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ResearchSubject: required")
	}
	type Plain ResearchSubject
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResearchSubject(plain)
	return nil
}

type ResourceList interface{}

// An assessment of the likely outcome(s) for a patient or other subject as well as
// the likelihood of each outcome.
type RiskAssessment struct {
	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for mitigation
	Mitigation *Element `json:"_mitigation,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A reference to the request that is fulfilled by this risk assessment.
	BasedOn *Reference `json:"basedOn,omitempty"`

	// Indicates the source data considered as part of the assessment (for example,
	// FamilyHistory, Observations, Procedures, Conditions, etc.).
	Basis []Reference `json:"basis,omitempty"`

	// The type of the risk assessment performed.
	Code *CodeableConcept `json:"code,omitempty"`

	// For assessments or prognosis specific to a particular condition, indicates the
	// condition being assessed.
	Condition *Reference `json:"condition,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []RiskAssessmentContainedElem `json:"contained,omitempty"`

	// The encounter where the assessment was performed.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifier assigned to the risk assessment.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// The algorithm, process or mechanism used to evaluate the risk.
	Method *CodeableConcept `json:"method,omitempty"`

	// A description of the steps that might be taken to reduce the identified
	// risk(s).
	Mitigation_2 *String `json:"mitigation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Additional comments about the risk assessment.
	Note []Annotation `json:"note,omitempty"`

	// The date (and possibly time) the risk assessment was performed.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The date (and possibly time) the risk assessment was performed.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// A reference to a resource that this risk assessment is part of, such as a
	// Procedure.
	Parent *Reference `json:"parent,omitempty"`

	// The provider, patient, related person, or software application that performed
	// the assessment.
	Performer *Reference `json:"performer,omitempty"`

	// Describes the expected outcome for the subject.
	Prediction []RiskAssessmentPrediction `json:"prediction,omitempty"`

	// The reason the risk assessment was performed.
	Reason []CodeableReference `json:"reason,omitempty"`

	// This is a RiskAssessment resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the RiskAssessment, using the same statuses as an Observation.
	Status_2 *Code `json:"status,omitempty"`

	// The patient or group the risk assessment applies to.
	Subject Reference `json:"subject"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type RiskAssessmentContainedElem interface{}

// An assessment of the likely outcome(s) for a patient or other subject as well as
// the likelihood of each outcome.
type RiskAssessmentPrediction struct {
	// Extensions for probabilityDecimal
	ProbabilityDecimal *Element `json:"_probabilityDecimal,omitempty"`

	// Extensions for rationale
	Rationale *Element `json:"_rationale,omitempty"`

	// Extensions for relativeRisk
	RelativeRisk *Element `json:"_relativeRisk,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// One of the potential outcomes for the patient (e.g. remission, death,  a
	// particular condition).
	Outcome *CodeableConcept `json:"outcome,omitempty"`

	// Indicates how likely the outcome is (in the specified timeframe). Range SHOULD
	// be expressed as a Quantity (with a unit of '%'), rather than as a decimal value
	// to make sure the percentage semantics are clear.
	ProbabilityDecimal_2 *float64 `json:"probabilityDecimal,omitempty"`

	// Indicates how likely the outcome is (in the specified timeframe). Range SHOULD
	// be expressed as a Quantity (with a unit of '%'), rather than as a decimal value
	// to make sure the percentage semantics are clear.
	ProbabilityQuantity *Quantity `json:"probabilityQuantity,omitempty"`

	// Indicates how likely the outcome is (in the specified timeframe). Range SHOULD
	// be expressed as a Quantity (with a unit of '%'), rather than as a decimal value
	// to make sure the percentage semantics are clear.
	ProbabilityRange *Range `json:"probabilityRange,omitempty"`

	// Indicates how likely the outcome is (in the specified timeframe), expressed as
	// a qualitative value (e.g. low, medium, or high).
	QualitativeRisk *CodeableConcept `json:"qualitativeRisk,omitempty"`

	// Additional information explaining the basis for the prediction.
	Rationale_2 *String `json:"rationale,omitempty"`

	// Indicates the risk for this particular subject (with their specific
	// characteristics) divided by the risk of the population in general.  (Numbers
	// greater than 1 = higher risk than the population, numbers less than 1 = lower
	// risk.).
	RelativeRisk_2 *Decimal `json:"relativeRisk,omitempty"`

	// Indicates the period of time or age range of the subject to which the specified
	// probability applies.
	WhenPeriod *Period `json:"whenPeriod,omitempty"`

	// Indicates the period of time or age range of the subject to which the specified
	// probability applies.
	WhenRange *Range `json:"whenRange,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RiskAssessment) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in RiskAssessment: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in RiskAssessment: required")
	}
	type Plain RiskAssessment
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = RiskAssessment(plain)
	return nil
}

// A series of measurements taken by a device, with upper and lower limits. There
// may be more than one dimension in the data.
type SampledData struct {
	// Extensions for data
	Data *Element `json:"_data,omitempty"`

	// Extensions for dimensions
	Dimensions *Element `json:"_dimensions,omitempty"`

	// Extensions for factor
	Factor *Element `json:"_factor,omitempty"`

	// Extensions for interval
	Interval *Element `json:"_interval,omitempty"`

	// Extensions for intervalUnit
	IntervalUnit *Element `json:"_intervalUnit,omitempty"`

	// Extensions for lowerLimit
	LowerLimit *Element `json:"_lowerLimit,omitempty"`

	// Extensions for offsets
	Offsets *Element `json:"_offsets,omitempty"`

	// Extensions for upperLimit
	UpperLimit *Element `json:"_upperLimit,omitempty"`

	// Reference to ConceptMap that defines the codes used in the data.
	CodeMap *Canonical `json:"codeMap,omitempty"`

	// A series of data points which are decimal values or codes separated by a single
	// space (character u20). The special codes "E" (error), "L" (below detection
	// limit) and "U" (above detection limit) are also defined for used in place of
	// decimal values.
	Data_2 *String `json:"data,omitempty"`

	// The number of sample points at each time point. If this value is greater than
	// one, then the dimensions will be interlaced - all the sample points for a point
	// in time will be recorded at once.
	Dimensions_2 *PositiveInt `json:"dimensions,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A correction factor that is applied to the sampled data points before they are
	// added to the origin.
	Factor_2 *Decimal `json:"factor,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Amount of intervalUnits between samples, e.g. milliseconds for time-based
	// sampling.
	Interval_2 *Decimal `json:"interval,omitempty"`

	// The measurement unit in which the sample interval is expressed.
	IntervalUnit_2 *Code `json:"intervalUnit,omitempty"`

	// The lower limit of detection of the measured points. This is needed if any of
	// the data points have the value "L" (lower than detection limit).
	LowerLimit_2 *Decimal `json:"lowerLimit,omitempty"`

	// A series of increasing decimal values separated by a single space (character
	// u20), which represent the offset from the logical start point. Offset values
	// may be negative. The units in which the offsets are expressed are found in
	// intervalUnit.  The absolute point at which the measurements begin SHALL be
	// conveyed outside the scope of this datatype, e.g. Observation.effectiveDateTime
	// for a timing offset.
	Offsets_2 *String `json:"offsets,omitempty"`

	// The base quantity that a measured value of zero represents. In addition, this
	// provides the units of the entire measurement series.
	Origin Quantity `json:"origin"`

	// The upper limit of detection of the measured points. This is needed if any of
	// the data points have the value "U" (higher than detection limit).
	UpperLimit_2 *Decimal `json:"upperLimit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SampledData) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["origin"]; raw != nil && !ok {
		return fmt.Errorf("field origin in SampledData: required")
	}
	type Plain SampledData
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SampledData(plain)
	return nil
}

// A container for slots of time that may be available for booking appointments.
type Schedule struct {
	// Extensions for active
	Active *Element `json:"_active,omitempty"`

	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Whether this schedule record is in active use or should not be used (such as
	// was entered in error).
	Active_2 *Boolean `json:"active,omitempty"`

	// Slots that reference this schedule resource provide the availability details to
	// these referenced resource(s).
	Actor []Reference `json:"actor"`

	// Comments on the availability to describe any extended information. Such as
	// custom constraints on the slots that may be associated.
	Comment_2 *Markdown `json:"comment,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ScheduleContainedElem `json:"contained,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// External Ids for this item.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Further description of the schedule as it would be presented to a consumer
	// while searching.
	Name_2 *String `json:"name,omitempty"`

	// The period of time that the slots that reference this Schedule resource cover
	// (even if none exist). These  cover the amount of time that an organization's
	// planning horizon; the interval for which they are currently accepting
	// appointments. This does not define a "template" for planning outside these
	// dates.
	PlanningHorizon *Period `json:"planningHorizon,omitempty"`

	// This is a Schedule resource
	ResourceType interface{} `json:"resourceType"`

	// A broad categorization of the service that is to be performed during this
	// appointment.
	ServiceCategory []CodeableConcept `json:"serviceCategory,omitempty"`

	// The specific service that is to be performed during this appointment.
	ServiceType []CodeableReference `json:"serviceType,omitempty"`

	// The specialty of a practitioner that would be required to perform the service
	// requested in this appointment.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type ScheduleContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Schedule) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in Schedule: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Schedule: required")
	}
	type Plain Schedule
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Schedule(plain)
	return nil
}

// A search parameter that defines a named search item that can be used to
// search/filter on a resource.
type SearchParameter struct {
	// Extensions for aliasCode
	AliasCode []Element `json:"_aliasCode,omitempty"`

	// Extensions for base
	Base []Element `json:"_base,omitempty"`

	// Extensions for chain
	Chain []Element `json:"_chain,omitempty"`

	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for comparator
	Comparator []Element `json:"_comparator,omitempty"`

	// Extensions for constraint
	Constraint *Element `json:"_constraint,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for expression
	Expression *Element `json:"_expression,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for modifier
	Modifier []Element `json:"_modifier,omitempty"`

	// Extensions for multipleAnd
	MultipleAnd *Element `json:"_multipleAnd,omitempty"`

	// Extensions for multipleOr
	MultipleOr *Element `json:"_multipleOr,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for processingMode
	ProcessingMode *Element `json:"_processingMode,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for target
	Target []Element `json:"_target,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Additional label that are recommended to be used in the URL or the parameter
	// name in a parameters resource for this search parameter. Typically used to
	// provide backwards-compatibility for renamed search parameters and translations
	// into localized languages.
	AliasCode_2 []Code `json:"aliasCode,omitempty"`

	// The base resource type(s) that this search parameter can be used against.
	Base_2 []Code `json:"base,omitempty"`

	// Contains the names of any search parameters which may be chained to the
	// containing search parameter. Chained parameters may be added to search
	// parameters of type reference and specify that resources will only be returned
	// if they contain a reference to a resource which matches the chained parameter
	// value. Values for this field should be drawn from SearchParameter.code for a
	// parameter on the target resource type.
	Chain_2 []String `json:"chain,omitempty"`

	// The label that is recommended to be used in the URL or the parameter name in a
	// parameters resource for this search parameter.  In some cases, servers may need
	// to use a different CapabilityStatement searchParam.name to differentiate
	// between multiple SearchParameters that happen to have the same code.
	Code_2 *Code `json:"code,omitempty"`

	// Comparators supported for the search parameter.
	Comparator_2 []Code `json:"comparator,omitempty"`

	// Used to define the parts of a composite search parameter.
	Component []SearchParameterComponent `json:"component,omitempty"`

	// FHIRPath expression that defines/sets a complex constraint for when this
	// SearchParameter is applicable.
	Constraint_2 *String `json:"constraint,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SearchParameterContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the search parameter and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the search parameter.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the search parameter was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the search parameter changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// Where this search parameter is originally defined. If a derivedFrom is
	// provided, then the details in the search parameter must be consistent with the
	// definition from which it is defined. i.e. the parameter should have the same
	// meaning, and (usually) the functionality should be a proper subset of the
	// underlying search parameter.
	DerivedFrom *Canonical `json:"derivedFrom,omitempty"`

	// And how it used.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this search parameter is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// A FHIRPath expression that returns a set of elements for the search parameter.
	Expression_2 *String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this search parameter when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// A modifier supported for the search parameter.
	Modifier_2 []Code `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether multiple parameters are allowed - e.g. more than one parameter with the
	// same name. The search matches if all the parameters match.
	MultipleAnd_2 *Boolean `json:"multipleAnd,omitempty"`

	// Whether multiple values are allowed for each time the parameter exists. Values
	// are separated by commas, and the parameter matches if any of the values match.
	MultipleOr_2 *Boolean `json:"multipleOr,omitempty"`

	// A natural language name identifying the search parameter. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// How the search parameter relates to the set of elements returned by evaluating
	// the expression query.
	ProcessingMode_2 *Code `json:"processingMode,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the search parameter.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this search parameter is needed and why it has been designed
	// as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a SearchParameter resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this search parameter. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// Types of resource (if a resource is referenced).
	Target_2 []Code `json:"target,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the search parameter.
	Title_2 *String `json:"title,omitempty"`

	// The type of value that a search parameter may contain, and how the content is
	// interpreted.
	Type_2 *Code `json:"type,omitempty"`

	// An absolute URI that is used to identify this search parameter when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this search parameter is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the search parameter is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate search parameter
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the search parameter
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the search parameter author and is not expected to
	// be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A search parameter that defines a named search item that can be used to
// search/filter on a resource.
type SearchParameterComponent struct {
	// Extensions for expression
	Expression *Element `json:"_expression,omitempty"`

	// The definition of the search parameter that describes this part.
	Definition Canonical `json:"definition"`

	// A sub-expression that defines how to extract values for this component from the
	// output of the main SearchParameter.expression.
	Expression_2 *String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SearchParameterComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["definition"]; raw != nil && !ok {
		return fmt.Errorf("field definition in SearchParameterComponent: required")
	}
	type Plain SearchParameterComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SearchParameterComponent(plain)
	return nil
}

type SearchParameterContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SearchParameter) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in SearchParameter: required")
	}
	type Plain SearchParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SearchParameter(plain)
	return nil
}

// A record of a request for service such as diagnostic investigations, treatments,
// or operations to be performed. When the ServiceRequest is active, it represents
// an authorization to perform the service.
type ServiceRequest struct {
	// Extensions for asNeeded
	AsNeeded *Element `json:"_asNeeded,omitempty"`

	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for occurrenceDateTime
	OccurrenceDateTime *Element `json:"_occurrenceDateTime,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Indicates that the service (e.g., procedure, lab test) should be performed when
	// needed (Boolean option).
	AsNeeded_2 *Boolean `json:"asNeeded,omitempty"`

	// Indicates specific criteria that need to be met to perform the service (e.g.,
	// lab results or symptoms).
	AsNeededFor []CodeableConcept `json:"asNeededFor,omitempty"`

	// When the request transitioned to being actionable.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// Plan/proposal/order fulfilled by this request.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Anatomic location where the procedure should be performed. This is the target
	// site.
	BodyStructure *CodeableReference `json:"bodyStructure,omitempty"`

	// A code that classifies the service for searching, sorting and display purposes
	// (e.g. "Surgical Procedure").
	Category []CodeableConcept `json:"category,omitempty"`

	// A code or reference that identifies a particular service (i.e., procedure,
	// diagnostic investigation, or panel of investigations) that has been requested.
	Code *CodeableReference `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ServiceRequestContainedElem `json:"contained,omitempty"`

	// Set this to true if the record is saying that the service/procedure should NOT
	// be performed.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// An encounter that provides additional information about the healthcare context
	// in which this request is made.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The actual focus of a service request when it is not the subject of record
	// representing something or someone associated with the subject such as a spouse,
	// parent, fetus, or donor. The focus of a service request could also be an
	// existing condition,  an intervention, the subject's diet,  another service
	// request on the subject,  or a body structure such as tumor or implanted device.
	Focus []Reference `json:"focus,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers assigned to this order instance by the orderer and/or the receiver
	// and/or order fulfiller.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Insurance plans, coverage extensions, pre-authorizations and/or
	// pre-determinations that may be needed for delivering the requested service.
	Insurance []Reference `json:"insurance,omitempty"`

	// Whether the request is a proposal, plan, an original order or a reflex order.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The preferred location(s) where the procedure should actually happen in coded
	// or free text form. E.g. at home or nursing day care center.
	Location []CodeableReference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Any other notes and comments made about the service request. For example,
	// internal billing notes.
	Note []Annotation `json:"note,omitempty"`

	// The date/time at which the requested service should occur.
	OccurrenceDateTime_2 *string `json:"occurrenceDateTime,omitempty"`

	// The date/time at which the requested service should occur.
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`

	// The date/time at which the requested service should occur.
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`

	// Additional details and instructions about how the services are to be delivered.
	// For example, an order for a urinary catheter may have an order detail for an
	// external or indwelling catheter, or an order for a bandage may require
	// additional instructions specifying how the bandage should be applied. Questions
	// or additional information to be gathered from a patient may be included here.
	OrderDetail []ServiceRequestOrderDetail `json:"orderDetail,omitempty"`

	// Instructions in terms that are understood by the patient or consumer.
	PatientInstruction []ServiceRequestPatientInstruction `json:"patientInstruction,omitempty"`

	// The desired performer for doing the requested service.  For example, the
	// surgeon, dermatopathologist, endoscopist, etc.
	Performer []Reference `json:"performer,omitempty"`

	// Desired type of performer for doing the requested service.
	PerformerType *CodeableConcept `json:"performerType,omitempty"`

	// Indicates how quickly the ServiceRequest should be addressed with respect to
	// other requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// An amount of service being requested.
	QuantityQuantity *Quantity `json:"quantityQuantity,omitempty"`

	// An amount of service being requested.
	QuantityRange *Range `json:"quantityRange,omitempty"`

	// An amount of service being requested.
	QuantityRatio *Ratio `json:"quantityRatio,omitempty"`

	// The reason or the indication for requesting the service (e.g., procedure, lab
	// test).
	Reason []CodeableReference `json:"reason,omitempty"`

	// Key events in the history of the request.
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`

	// The request takes the place of the referenced completed or terminated
	// request(s).
	Replaces []Reference `json:"replaces,omitempty"`

	// The individual who initiated the request and has responsibility for its
	// activation.
	Requester *Reference `json:"requester,omitempty"`

	// A shared identifier common to all service requests that were authorized more or
	// less simultaneously by a single author, representing the composite or group
	// identifier.
	Requisition *Identifier `json:"requisition,omitempty"`

	// This is a ServiceRequest resource
	ResourceType interface{} `json:"resourceType"`

	// One or more specimens that the laboratory procedure will use.
	Specimen []Reference `json:"specimen,omitempty"`

	// The status of the order.
	Status_2 *Code `json:"status,omitempty"`

	// Provides reason why the service request status is what it is. The statusReason
	// can be used to explain why a service request is suspended, cancelled, or on
	// hold, including administrative and clinical reasons.
	StatusReason []CodeableConcept `json:"statusReason,omitempty"`

	// On whom or what the service is to be performed. This is usually a human
	// patient, but can also be requested on animals, groups of humans or animals,
	// devices such as dialysis machines, or even locations (typically for
	// environmental scans).
	Subject Reference `json:"subject"`

	// Additional clinical information about the patient or specimen that may
	// influence the services or their interpretations. This information includes
	// diagnosis, clinical findings and other observations. In laboratory ordering
	// these are typically referred to as 'ask at order entry questions (AOEs).' This
	// includes observations explicitly requested by the producer (filler) to provide
	// context or supporting information needed to complete the order. For example,
	// reporting the amount of inspired oxygen for blood gas measurements.
	SupportingInfo []CodeableReference `json:"supportingInfo,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type ServiceRequestContainedElem interface{}

// A record of a request for service such as diagnostic investigations, treatments,
// or operations to be performed. When the ServiceRequest is active, it represents
// an authorization to perform the service.
type ServiceRequestOrderDetail struct {
	// Extensions for parameterFocusCanonical
	ParameterFocusCanonical *Element `json:"_parameterFocusCanonical,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The parameter details for the service being requested.
	Parameter []ServiceRequestParameter `json:"parameter"`

	// Indicates the context of the order details by reference.
	ParameterFocusCanonical_2 *string `json:"parameterFocusCanonical,omitempty"`

	// Indicates the context of the order details by reference.
	ParameterFocusCodeableConcept *CodeableConcept `json:"parameterFocusCodeableConcept,omitempty"`

	// Indicates the context of the order details by reference.
	ParameterFocusReference *Reference `json:"parameterFocusReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceRequestOrderDetail) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["parameter"]; raw != nil && !ok {
		return fmt.Errorf("field parameter in ServiceRequestOrderDetail: required")
	}
	type Plain ServiceRequestOrderDetail
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ParameterFocusCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ParameterFocusCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ParameterFocusCanonical_2", `^\S*$`)
		}
	}
	*j = ServiceRequestOrderDetail(plain)
	return nil
}

// A record of a request for service such as diagnostic investigations, treatments,
// or operations to be performed. When the ServiceRequest is active, it represents
// an authorization to perform the service.
type ServiceRequestParameter struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A value representing the additional detail or instructions for the order (e.g.,
	// catheter insertion, body elevation, descriptive device configuration and/or
	// setting instructions).
	Code CodeableConcept `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Indicates a value for the order detail.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Indicates a value for the order detail.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// Indicates a value for the order detail.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// Indicates a value for the order detail.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// Indicates a value for the order detail.
	ValueRange *Range `json:"valueRange,omitempty"`

	// Indicates a value for the order detail.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// Indicates a value for the order detail.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceRequestParameter) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ServiceRequestParameter: required")
	}
	type Plain ServiceRequestParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ServiceRequestParameter(plain)
	return nil
}

// A record of a request for service such as diagnostic investigations, treatments,
// or operations to be performed. When the ServiceRequest is active, it represents
// an authorization to perform the service.
type ServiceRequestPatientInstruction struct {
	// Extensions for instructionMarkdown
	InstructionMarkdown *Element `json:"_instructionMarkdown,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Instructions in terms that are understood by the patient or consumer.
	InstructionMarkdown_2 *string `json:"instructionMarkdown,omitempty"`

	// Instructions in terms that are understood by the patient or consumer.
	InstructionReference *Reference `json:"instructionReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceRequestPatientInstruction) UnmarshalJSON(value []byte) error {
	type Plain ServiceRequestPatientInstruction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.InstructionMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.InstructionMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "InstructionMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	*j = ServiceRequestPatientInstruction(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ServiceRequest: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ServiceRequest: required")
	}
	type Plain ServiceRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OccurrenceDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.OccurrenceDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "OccurrenceDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = ServiceRequest(plain)
	return nil
}

// A signature along with supporting context. The signature may be a digital
// signature that is cryptographic in nature, or some other signature acceptable to
// the domain. This other signature may be as simple as a graphical image
// representing a hand-written signature, or a signature ceremony Different
// signature approaches have different utilities.
type Signature struct {
	// Extensions for data
	Data *Element `json:"_data,omitempty"`

	// Extensions for sigFormat
	SigFormat *Element `json:"_sigFormat,omitempty"`

	// Extensions for targetFormat
	TargetFormat *Element `json:"_targetFormat,omitempty"`

	// Extensions for when
	When *Element `json:"_when,omitempty"`

	// The base64 encoding of the Signature content. When signature is not recorded
	// electronically this element would be empty.
	Data_2 *Base64Binary `json:"data,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A reference to an application-usable description of the identity that is
	// represented by the signature.
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`

	// A mime type that indicates the technical format of the signature. Important
	// mime types are application/signature+xml for X ML DigSig, application/jose for
	// JWS, and image/* for a graphical image of a signature, etc.
	SigFormat_2 *Code `json:"sigFormat,omitempty"`

	// A mime type that indicates the technical format of the target resources signed
	// by the signature.
	TargetFormat_2 *Code `json:"targetFormat,omitempty"`

	// An indication of the reason that the entity signed this document. This may be
	// explicitly included as part of the signature information and can be used when
	// determining accountability for various actions concerning the document.
	Type []Coding `json:"type,omitempty"`

	// When the digital signature was signed.
	When_2 *Instant `json:"when,omitempty"`

	// A reference to an application-usable description of the identity that signed
	// (e.g. the signature used their private key).
	Who *Reference `json:"who,omitempty"`
}

// A slot of time on a schedule that may be available for booking appointments.
type Slot struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for end
	End *Element `json:"_end,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for overbooked
	Overbooked *Element `json:"_overbooked,omitempty"`

	// Extensions for start
	Start *Element `json:"_start,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The style of appointment or patient that may be booked in the slot (not service
	// type).
	AppointmentType []CodeableConcept `json:"appointmentType,omitempty"`

	// Comments on the slot to describe any extended information. Such as custom
	// constraints on the slot.
	Comment_2 *String `json:"comment,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SlotContainedElem `json:"contained,omitempty"`

	// Date/Time that the slot is to conclude.
	End_2 *Instant `json:"end,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// External Ids for this item.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// This slot has already been overbooked, appointments are unlikely to be accepted
	// for this time.
	Overbooked_2 *Boolean `json:"overbooked,omitempty"`

	// This is a Slot resource
	ResourceType interface{} `json:"resourceType"`

	// The schedule resource that this slot defines an interval of status information.
	Schedule Reference `json:"schedule"`

	// A broad categorization of the service that is to be performed during this
	// appointment.
	ServiceCategory []CodeableConcept `json:"serviceCategory,omitempty"`

	// The type of appointments that can be booked into this slot (ideally this would
	// be an identifiable service - which is at a location, rather than the location
	// itself). If provided then this overrides the value provided on the Schedule
	// resource.
	ServiceType []CodeableReference `json:"serviceType,omitempty"`

	// The specialty of a practitioner that would be required to perform the service
	// requested in this appointment.
	Specialty []CodeableConcept `json:"specialty,omitempty"`

	// Date/Time that the slot is to begin.
	Start_2 *Instant `json:"start,omitempty"`

	// busy | free | busy-unavailable | busy-tentative | entered-in-error.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type SlotContainedElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Slot) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Slot: required")
	}
	if _, ok := raw["schedule"]; raw != nil && !ok {
		return fmt.Errorf("field schedule in Slot: required")
	}
	type Plain Slot
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Slot(plain)
	return nil
}

// A sample to be used for analysis.
type Specimen struct {
	// Extensions for combined
	Combined *Element `json:"_combined,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for receivedTime
	ReceivedTime *Element `json:"_receivedTime,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Details concerning the specimen collection.
	Collection *SpecimenCollection `json:"collection,omitempty"`

	// This element signifies if the specimen is part of a group or pooled.
	Combined_2 *Code `json:"combined,omitempty"`

	// A mode or state of being that describes the nature of the specimen.
	Condition []CodeableConcept `json:"condition,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SpecimenContainedElem `json:"contained,omitempty"`

	// The container holding the specimen.  The recursive nature of containers; i.e.
	// blood in tube in tray in rack is not addressed here.
	Container []SpecimenContainer `json:"container,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A physical feature or landmark on a specimen, highlighted for context by the
	// collector of the specimen (e.g. surgeon), that identifies the type of feature
	// as well as its meaning (e.g. the red ink indicating the resection margin of the
	// right lobe of the excised prostate tissue or wire loop at radiologically
	// suspected tumor location).
	Feature []SpecimenFeature `json:"feature,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifiers used for specimen identification. These could include but are not
	// limited to identifiers generated upon collection, accessioning, or other
	// reasons for labeling a specimen.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// To communicate any details or issues about the specimen or during the specimen
	// collection. (for example: broken vial, sent with patient, frozen).
	Note []Annotation `json:"note,omitempty"`

	// Reference to the parent (source) specimen which is used when the specimen was
	// either derived from or a component of another specimen.
	Parent []Reference `json:"parent,omitempty"`

	// Details concerning processing and processing steps for the specimen.
	Processing []SpecimenProcessing `json:"processing,omitempty"`

	// Time when specimen is received by the testing laboratory for processing or
	// testing.
	ReceivedTime_2 *DateTime `json:"receivedTime,omitempty"`

	// Details concerning a service request that required a specimen to be collected.
	Request []Reference `json:"request,omitempty"`

	// This is a Specimen resource
	ResourceType interface{} `json:"resourceType"`

	// The role or reason for the specimen in the testing workflow.
	Role []CodeableConcept `json:"role,omitempty"`

	// The availability of the specimen.
	Status_2 *Code `json:"status,omitempty"`

	// Where the specimen came from. This may be from patient(s), from a location
	// (e.g., the source of an environmental sample), or a sampling of a substance, a
	// biologically-derived product, or a device.
	Subject *Reference `json:"subject,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The kind of material that forms the specimen.
	Type *CodeableConcept `json:"type,omitempty"`
}

// A sample to be used for analysis.
type SpecimenCollection struct {
	// Extensions for collectedDateTime
	CollectedDateTime *Element `json:"_collectedDateTime,omitempty"`

	// Extensions for deviceCanonical
	DeviceCanonical *Element `json:"_deviceCanonical,omitempty"`

	// Anatomical location from which the specimen was collected (if subject is a
	// patient). This is the target site.  This element is not used for environmental
	// specimens.
	BodySite *CodeableReference `json:"bodySite,omitempty"`

	// Time when specimen was collected from subject - the physiologically relevant
	// time.
	CollectedDateTime_2 *string `json:"collectedDateTime,omitempty"`

	// Time when specimen was collected from subject - the physiologically relevant
	// time.
	CollectedPeriod *Period `json:"collectedPeriod,omitempty"`

	// Person who collected the specimen.
	Collector *Reference `json:"collector,omitempty"`

	// A coded value specifying the device that is used to perform the procedure.
	DeviceCanonical_2 *string `json:"deviceCanonical,omitempty"`

	// A coded value specifying the device that is used to perform the procedure.
	DeviceCodeableConcept *CodeableConcept `json:"deviceCodeableConcept,omitempty"`

	// A coded value specifying the device that is used to perform the procedure.
	DeviceReference *Reference `json:"deviceReference,omitempty"`

	// The span of time over which the collection of a specimen occurred.
	Duration *Duration `json:"duration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Abstinence or reduction from some or all food, drink, or both, for a period of
	// time prior to sample collection.
	FastingStatusCodeableConcept *CodeableConcept `json:"fastingStatusCodeableConcept,omitempty"`

	// Abstinence or reduction from some or all food, drink, or both, for a period of
	// time prior to sample collection.
	FastingStatusDuration *Duration `json:"fastingStatusDuration,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A coded value specifying the technique that is used to perform the procedure.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The procedure event during which the specimen was collected (e.g. the surgery
	// leading to the collection of a pathology sample).
	Procedure *Reference `json:"procedure,omitempty"`

	// The quantity of specimen collected; for instance the volume of a blood sample,
	// or the physical measurement of an anatomic pathology sample.
	Quantity *Quantity `json:"quantity,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenCollection) UnmarshalJSON(value []byte) error {
	type Plain SpecimenCollection
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CollectedDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.CollectedDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CollectedDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.DeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeviceCanonical_2", `^\S*$`)
		}
	}
	*j = SpecimenCollection(plain)
	return nil
}

type SpecimenContainedElem interface{}

// A sample to be used for analysis.
type SpecimenContainer struct {
	// Extensions for deviceCanonical
	DeviceCanonical *Element `json:"_deviceCanonical,omitempty"`

	// The device resource for the the container holding the specimen. If the
	// container is in a holder then the referenced device will point to a parent
	// device.
	DeviceCanonical_2 *string `json:"deviceCanonical,omitempty"`

	// The device resource for the the container holding the specimen. If the
	// container is in a holder then the referenced device will point to a parent
	// device.
	DeviceCodeableConcept *CodeableConcept `json:"deviceCodeableConcept,omitempty"`

	// The device resource for the the container holding the specimen. If the
	// container is in a holder then the referenced device will point to a parent
	// device.
	DeviceReference *Reference `json:"deviceReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The quantity of specimen in the container; may be volume, dimensions, or other
	// appropriate measurements, depending on the specimen type.
	SpecimenQuantity *Quantity `json:"specimenQuantity,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenContainer) UnmarshalJSON(value []byte) error {
	type Plain SpecimenContainer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeviceCanonical_2", `^\S*$`)
		}
	}
	*j = SpecimenContainer(plain)
	return nil
}

// A kind of specimen with associated set of requirements.
type SpecimenDefinition struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for derivedFromUri
	DerivedFromUri []Element `json:"_derivedFromUri,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for timeAspect
	TimeAspect *Element `json:"_timeAspect,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the asset content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the {{title}}.
	Author []ContactDetail `json:"author,omitempty"`

	// The action to be performed for collecting the specimen.
	Collection []CodeableConcept `json:"collection,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SpecimenDefinitionContainedElem `json:"contained,omitempty"`

	// Copyright statement relating to the SpecimenDefinition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the SpecimenDefinition.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// For draft definitions, indicates the date of initial creation. For active
	// definitions, represents the date of activation. For withdrawn definitions,
	// indicates the date of withdrawal.
	Date_2 *DateTime `json:"date,omitempty"`

	// The canonical URL pointing to another FHIR-defined SpecimenDefinition that is
	// adhered to in whole or in part by this definition.
	DerivedFromCanonical []Canonical `json:"derivedFromCanonical,omitempty"`

	// The URL pointing to an externally-defined type of specimen, guideline or other
	// definition that is adhered to in whole or in part by this definition.
	DerivedFromUri_2 []Uri `json:"derivedFromUri,omitempty"`

	// A free text natural language description of the SpecimenDefinition from the
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the {{title}}.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the SpecimenDefinition content was or is planned to be
	// effective.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the {{title}} for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A flag to indicate that this SpecimenDefinition is not authored for  genuine
	// usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A business identifier assigned to this SpecimenDefinition.
	Identifier *Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A jurisdiction in which the SpecimenDefinition is intended to be used.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the asset content was last reviewed. Review happens
	// periodically after that, but doesn't change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the {{title}}. This name should be usable
	// as an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// Preparation of the patient for specimen collection.
	PatientPreparation []CodeableConcept `json:"patientPreparation,omitempty"`

	// Helps establish the "authority/credibility" of the SpecimenDefinition. May also
	// allow for contact.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explains why this SpecimeDefinition is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a SpecimenDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the {{title}}.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The current state of theSpecimenDefinition.
	Status_2 *Code `json:"status,omitempty"`

	// A code or group definition that describes the intended subject  from which this
	// kind of specimen is to be collected.
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`

	// A code or group definition that describes the intended subject  from which this
	// kind of specimen is to be collected.
	SubjectReference *Reference `json:"subjectReference,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// Time aspect of specimen collection (duration or offset).
	TimeAspect_2 *String `json:"timeAspect,omitempty"`

	// A short, descriptive, user-friendly title for the SpecimenDefinition.
	Title_2 *String `json:"title,omitempty"`

	// Descriptive topics related to the content of the {{title}}. Topics provide a
	// high-level categorization as well as keywords for the {{title}} that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// The kind of material to be collected.
	TypeCollected *CodeableConcept `json:"typeCollected,omitempty"`

	// Specimen conditioned in a container as expected by the testing laboratory.
	TypeTested []SpecimenDefinitionTypeTested `json:"typeTested,omitempty"`

	// An absolute URL that is used to identify this SpecimenDefinition when it is
	// referenced in a specification, model, design or an instance. This SHALL be a
	// URL, SHOULD be globally unique, and SHOULD be an address at which this
	// SpecimenDefinition is (or will be) published. The URL SHOULD include the major
	// version of the SpecimenDefinition. For more information see Technical and
	// Business Versions.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These terms may be used to assist with indexing and searching
	// of specimen definitions.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the SpecimenDefinition
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the SpecimenDefinition author and is not expected to
	// be globally unique.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A kind of specimen with associated set of requirements.
type SpecimenDefinitionAdditive struct {
	// Substance introduced in the kind of container to preserve, maintain or enhance
	// the specimen. Examples: Formalin, Citrate, EDTA.
	AdditiveCodeableConcept *CodeableConcept `json:"additiveCodeableConcept,omitempty"`

	// Substance introduced in the kind of container to preserve, maintain or enhance
	// the specimen. Examples: Formalin, Citrate, EDTA.
	AdditiveReference *Reference `json:"additiveReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type SpecimenDefinitionContainedElem interface{}

// A kind of specimen with associated set of requirements.
type SpecimenDefinitionContainer struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for minimumVolumeString
	MinimumVolumeString *Element `json:"_minimumVolumeString,omitempty"`

	// Extensions for preparation
	Preparation *Element `json:"_preparation,omitempty"`

	// Substance introduced in the kind of container to preserve, maintain or enhance
	// the specimen. Examples: Formalin, Citrate, EDTA.
	Additive []SpecimenDefinitionAdditive `json:"additive,omitempty"`

	// Color of container cap.
	Cap *CodeableConcept `json:"cap,omitempty"`

	// The capacity (volume or other measure) of this kind of container.
	Capacity *Quantity `json:"capacity,omitempty"`

	// The textual description of the kind of container.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The type of material of the container.
	Material *CodeableConcept `json:"material,omitempty"`

	// The minimum volume to be conditioned in the container.
	MinimumVolumeQuantity *Quantity `json:"minimumVolumeQuantity,omitempty"`

	// The minimum volume to be conditioned in the container.
	MinimumVolumeString_2 *string `json:"minimumVolumeString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Special processing that should be applied to the container for this kind of
	// specimen.
	Preparation_2 *Markdown `json:"preparation,omitempty"`

	// The type of container used to contain this kind of specimen.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenDefinitionContainer) UnmarshalJSON(value []byte) error {
	type Plain SpecimenDefinitionContainer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MinimumVolumeString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.MinimumVolumeString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinimumVolumeString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SpecimenDefinitionContainer(plain)
	return nil
}

// A kind of specimen with associated set of requirements.
type SpecimenDefinitionHandling struct {
	// Extensions for instruction
	Instruction *Element `json:"_instruction,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Additional textual instructions for the preservation or transport of the
	// specimen. For instance, 'Protect from light exposure'.
	Instruction_2 *Markdown `json:"instruction,omitempty"`

	// The maximum time interval of preservation of the specimen with these
	// conditions.
	MaxDuration *Duration `json:"maxDuration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// It qualifies the interval of temperature, which characterizes an occurrence of
	// handling. Conditions that are not related to temperature may be handled in the
	// instruction element.
	TemperatureQualifier *CodeableConcept `json:"temperatureQualifier,omitempty"`

	// The temperature interval for this set of handling instructions.
	TemperatureRange *Range `json:"temperatureRange,omitempty"`
}

// A kind of specimen with associated set of requirements.
type SpecimenDefinitionTypeTested struct {
	// Extensions for isDerived
	IsDerived *Element `json:"_isDerived,omitempty"`

	// Extensions for preference
	Preference *Element `json:"_preference,omitempty"`

	// Extensions for requirement
	Requirement *Element `json:"_requirement,omitempty"`

	// Extensions for singleUse
	SingleUse *Element `json:"_singleUse,omitempty"`

	// The specimen's container.
	Container *SpecimenDefinitionContainer `json:"container,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Set of instructions for preservation/transport of the specimen at a defined
	// temperature interval, prior the testing process.
	Handling []SpecimenDefinitionHandling `json:"handling,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Primary of secondary specimen.
	IsDerived_2 *Boolean `json:"isDerived,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The preference for this type of conditioned specimen.
	Preference_2 *Code `json:"preference,omitempty"`

	// Criterion for rejection of the specimen in its container by the laboratory.
	RejectionCriterion []CodeableConcept `json:"rejectionCriterion,omitempty"`

	// Requirements for delivery and special handling of this kind of conditioned
	// specimen.
	Requirement_2 *Markdown `json:"requirement,omitempty"`

	// The usual time that a specimen of this kind is retained after the ordered tests
	// are completed, for the purpose of additional testing.
	RetentionTime *Duration `json:"retentionTime,omitempty"`

	// Specimen can be used by only one test or panel if the value is "true".
	SingleUse_2 *Boolean `json:"singleUse,omitempty"`

	// Where the specimen will be tested: e.g., lab, sector, device or any combination
	// of these.
	TestingDestination []CodeableConcept `json:"testingDestination,omitempty"`

	// The kind of specimen conditioned for testing expected by lab.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in SpecimenDefinition: required")
	}
	type Plain SpecimenDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SpecimenDefinition(plain)
	return nil
}

// A sample to be used for analysis.
type SpecimenFeature struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Description of the feature of the specimen.
	Description_2 *String `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The landmark or feature being highlighted.
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenFeature) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SpecimenFeature: required")
	}
	type Plain SpecimenFeature
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SpecimenFeature(plain)
	return nil
}

// A sample to be used for analysis.
type SpecimenProcessing struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for deviceCanonical
	DeviceCanonical *Element `json:"_deviceCanonical,omitempty"`

	// Extensions for timeDateTime
	TimeDateTime *Element `json:"_timeDateTime,omitempty"`

	// Material used in the processing step.
	Additive []CodeableReference `json:"additive,omitempty"`

	// Textual description of procedure.
	Description_2 *String `json:"description,omitempty"`

	// The device used in the processing of the specimen.
	DeviceCanonical_2 *string `json:"deviceCanonical,omitempty"`

	// The device used in the processing of the specimen.
	DeviceCodeableConcept *CodeableConcept `json:"deviceCodeableConcept,omitempty"`

	// The device used in the processing of the specimen.
	DeviceReference *Reference `json:"deviceReference,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A coded value specifying the method used to process the specimen.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The performer of the processing of the specimen.
	Performer *Reference `json:"performer,omitempty"`

	// A record of the time or period when the specimen processing occurred.  For
	// example the time of sample fixation or the period of time the sample was in
	// formalin.
	TimeDateTime_2 *string `json:"timeDateTime,omitempty"`

	// A record of the time or period when the specimen processing occurred.  For
	// example the time of sample fixation or the period of time the sample was in
	// formalin.
	TimeDuration *Duration `json:"timeDuration,omitempty"`

	// A record of the time or period when the specimen processing occurred.  For
	// example the time of sample fixation or the period of time the sample was in
	// formalin.
	TimePeriod *Period `json:"timePeriod,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecimenProcessing) UnmarshalJSON(value []byte) error {
	type Plain SpecimenProcessing
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DeviceCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.DeviceCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DeviceCanonical_2", `^\S*$`)
		}
	}
	if plain.TimeDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimeDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimeDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = SpecimenProcessing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Specimen) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Specimen: required")
	}
	type Plain Specimen
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Specimen(plain)
	return nil
}

// A sequence of Unicode characters
type String string

// UnmarshalJSON implements json.Unmarshaler.
func (j *String) UnmarshalJSON(value []byte) error {
	type Plain String
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^^[\s\S]+$$`)
	}
	*j = String(plain)
	return nil
}

// A definition of a FHIR structure. This resource is used to describe the
// underlying resources, data types defined in FHIR, and also for describing
// extensions and constraints on resources and data types.
type StructureDefinition struct {
	// Extensions for abstract
	Abstract *Element `json:"_abstract,omitempty"`

	// Extensions for contextInvariant
	ContextInvariant []Element `json:"_contextInvariant,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for derivation
	Derivation *Element `json:"_derivation,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for fhirVersion
	FhirVersion *Element `json:"_fhirVersion,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Whether structure this definition describes is abstract or not  - that is,
	// whether the structure is not intended to be instantiated. For Resources and
	// Data types, abstract types will never be exchanged  between systems.
	Abstract_2 *Boolean `json:"abstract,omitempty"`

	// An absolute URI that is the base structure from which this type is derived,
	// either by specialization or constraint.
	BaseDefinition *Canonical `json:"baseDefinition,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []StructureDefinitionContainedElem `json:"contained,omitempty"`

	// Identifies the types of resource or data type elements to which the extension
	// can be applied. For more guidance on using the 'context' element, see the
	// [defining extensions page](defining-extensions.html#context).
	Context []StructureDefinitionContext `json:"context,omitempty"`

	// A set of rules as FHIRPath Invariants about when the extension can be used
	// (e.g. co-occurrence variants for the extension). All the rules must be true.
	ContextInvariant_2 []String `json:"contextInvariant,omitempty"`

	// A copyright statement relating to the structure definition and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the structure definition.
	// The short copyright declaration (e.g. (c) '2015+ xyz organization') should be
	// sent in the copyrightLabel element without the copyright prefix (i.e., do not
	// include '(c)' or the symbol).
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the structure definition was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the structure definition changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// How the type relates to the baseDefinition.
	Derivation_2 *Code `json:"derivation,omitempty"`

	// A free text natural language description of the structure definition from a
	// consumer's perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A differential view is expressed relative to the base StructureDefinition - a
	// statement of differences that it applies.
	Differential *StructureDefinitionDifferential `json:"differential,omitempty"`

	// A Boolean value to indicate that this structure definition is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The version of the FHIR specification on which this StructureDefinition is
	// based - this is the formal version of the specification, without the revision
	// number, e.g. [publication].[major].[minor], which is 4.6.0. for this version.
	FhirVersion_2 *Code `json:"fhirVersion,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this structure definition when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// (DEPRECATED) A set of key words or terms from external terminologies that may
	// be used to assist with indexing and searching of templates nby describing the
	// use of this structure definition, or the content it describes.
	Keyword []Coding `json:"keyword,omitempty"`

	// Defines the kind of structure that this definition is describing.
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// An external specification that the content is mapped to.
	Mapping []StructureDefinitionMapping `json:"mapping,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the structure definition. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the structure definition.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this structure definition is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a StructureDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// A snapshot view is expressed in a standalone form that can be used and
	// interpreted without considering the base StructureDefinition.
	Snapshot *StructureDefinitionSnapshot `json:"snapshot,omitempty"`

	// The status of this structure definition. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the structure definition.
	Title_2 *String `json:"title,omitempty"`

	// The type this structure describes. If the derivation kind is 'specialization'
	// then this is the master definition for a type, and there is always one of these
	// (a data type, an extension, a resource, including abstract ones). Otherwise the
	// structure definition is a constraint on the stated type (and in this case, the
	// type cannot be an abstract type).  References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
	// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed
	// in logical models, where they are required.
	Type_2 *Uri `json:"type,omitempty"`

	// An absolute URI that is used to identify this structure definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this structure definition is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the structure definition is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate structure
	// definition instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the structure
	// definition when it is referenced in a specification, model, design or instance.
	// This is an arbitrary value managed by the structure definition author and is
	// not expected to be globally unique. There is no expectation that versions can
	// be placed in a lexicographical sequence, so authors are encouraged to populate
	// the StructureDefinition.versionAlgorithm[x] element to enable comparisons. If
	// there is no managed version available, authors can consider using ISO date/time
	// syntax (e.g., '2023-01-01').
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

type StructureDefinitionContainedElem interface{}

// A definition of a FHIR structure. This resource is used to describe the
// underlying resources, data types defined in FHIR, and also for describing
// extensions and constraints on resources and data types.
type StructureDefinitionContext struct {
	// Extensions for expression
	Expression *Element `json:"_expression,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// An expression that defines where an extension can be used in resources.
	Expression_2 *String `json:"expression,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Defines how to interpret the expression that defines what the context of the
	// extension is.
	Type_2 *Code `json:"type,omitempty"`
}

// A definition of a FHIR structure. This resource is used to describe the
// underlying resources, data types defined in FHIR, and also for describing
// extensions and constraints on resources and data types.
type StructureDefinitionDifferential struct {
	// Captures constraints on each element within the resource.
	Element []ElementDefinition `json:"element"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureDefinitionDifferential) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["element"]; raw != nil && !ok {
		return fmt.Errorf("field element in StructureDefinitionDifferential: required")
	}
	type Plain StructureDefinitionDifferential
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureDefinitionDifferential(plain)
	return nil
}

// A definition of a FHIR structure. This resource is used to describe the
// underlying resources, data types defined in FHIR, and also for describing
// extensions and constraints on resources and data types.
type StructureDefinitionMapping struct {
	// Extensions for comment
	Comment *Element `json:"_comment,omitempty"`

	// Extensions for identity
	Identity *Element `json:"_identity,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// Comments about this mapping, including version notes, issues, scope
	// limitations, and other important notes for usage.
	Comment_2 *String `json:"comment,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An Internal id that is used to identify this mapping set when specific mappings
	// are made.
	Identity_2 *ID `json:"identity,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A name for the specification that is being mapped to.
	Name_2 *String `json:"name,omitempty"`

	// An absolute URI that identifies the specification that this mapping is
	// expressed to.
	Uri_2 *Uri `json:"uri,omitempty"`
}

// A definition of a FHIR structure. This resource is used to describe the
// underlying resources, data types defined in FHIR, and also for describing
// extensions and constraints on resources and data types.
type StructureDefinitionSnapshot struct {
	// Captures constraints on each element within the resource.
	Element []ElementDefinition `json:"element"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureDefinitionSnapshot) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["element"]; raw != nil && !ok {
		return fmt.Errorf("field element in StructureDefinitionSnapshot: required")
	}
	type Plain StructureDefinitionSnapshot
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureDefinitionSnapshot(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in StructureDefinition: required")
	}
	type Plain StructureDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = StructureDefinition(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMap struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// Definition of a constant value used in the map rules.
	Const []StructureMapConst `json:"const,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []StructureMapContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the structure map and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the structure map.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the structure map was last significantly
	// changed. The date must change when the business version changes and it must
	// change if the status code changes. In addition, it should change when the
	// substantive content of the structure map changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the structure map from a consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// A Boolean value to indicate that this structure map is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Organizes the mapping into managable chunks for human review/ease of
	// maintenance.
	Group []StructureMapGroup `json:"group"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this structure map when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Other maps used by this map (canonical URLs).
	Import []Canonical `json:"import,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the structure map. This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the structure map.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this structure map is needed and why it has been designed as
	// it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a StructureMap resource
	ResourceType interface{} `json:"resourceType"`

	// The status of this structure map. Enables tracking the life-cycle of the
	// content.
	Status_2 *Code `json:"status,omitempty"`

	// A structure definition used by this map. The structure definition may describe
	// instances that are converted, or the instances that are produced.
	Structure []StructureMapStructure `json:"structure,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the structure map.
	Title_2 *String `json:"title,omitempty"`

	// An absolute URI that is used to identify this structure map when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this structure map is (or will
	// be) published. This URL can be the target of a canonical reference. It SHALL
	// remain the same when the structure map is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate structure map
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the structure map when
	// it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the structure map author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapConst struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Other maps used by this map (canonical URLs).
	Name_2 *ID `json:"name,omitempty"`

	// A FHIRPath expression that is the value of this variable.
	Value_2 *String `json:"value,omitempty"`
}

type StructureMapContainedElem interface{}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapDependent struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of a rule or group to apply.
	Name_2 *ID `json:"name,omitempty"`

	// Parameter to pass to the rule or group.
	Parameter []StructureMapParameter `json:"parameter"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMapDependent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["parameter"]; raw != nil && !ok {
		return fmt.Errorf("field parameter in StructureMapDependent: required")
	}
	type Plain StructureMapDependent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureMapDependent(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapGroup struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for extends
	Extends *Element `json:"_extends,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for typeMode
	TypeMode *Element `json:"_typeMode,omitempty"`

	// Additional supporting documentation that explains the purpose of the group and
	// the types of mappings within it.
	Documentation_2 *String `json:"documentation,omitempty"`

	// Another group that this group adds rules to.
	Extends_2 *ID `json:"extends,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A name assigned to an instance of data. The instance must be provided when the
	// mapping is invoked.
	Input []StructureMapInput `json:"input"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A unique name for the group for the convenience of human readers.
	Name_2 *ID `json:"name,omitempty"`

	// Transform Rule from source to target.
	Rule []StructureMapRule `json:"rule,omitempty"`

	// If this is the default rule set to apply for the source type or this
	// combination of types.
	TypeMode_2 *Code `json:"typeMode,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMapGroup) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in StructureMapGroup: required")
	}
	type Plain StructureMapGroup
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureMapGroup(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapInput struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Documentation for this instance of data.
	Documentation_2 *String `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Mode for this instance of data.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name for this instance of data.
	Name_2 *ID `json:"name,omitempty"`

	// Type for this instance of data.
	Type_2 *String `json:"type,omitempty"`
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapParameter struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Parameter value - variable or literal.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// Parameter value - variable or literal.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// Parameter value - variable or literal.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// Parameter value - variable or literal.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// Parameter value - variable or literal.
	ValueID_2 *string `json:"valueId,omitempty"`

	// Parameter value - variable or literal.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// Parameter value - variable or literal.
	ValueString_2 *string `json:"valueString,omitempty"`

	// Parameter value - variable or literal.
	ValueTime_2 *string `json:"valueTime,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMapParameter) UnmarshalJSON(value []byte) error {
	type Plain StructureMapParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	*j = StructureMapParameter(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapRule struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Which other rules to apply in the context of this rule.
	Dependent []StructureMapDependent `json:"dependent,omitempty"`

	// Documentation for this instance of data.
	Documentation_2 *String `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of the rule for internal references.
	Name_2 *ID `json:"name,omitempty"`

	// Rules contained in this rule.
	Rule []StructureMapRule `json:"rule,omitempty"`

	// Source inputs to the mapping.
	Source []StructureMapSource `json:"source"`

	// Content to create because of this mapping rule.
	Target []StructureMapTarget `json:"target,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMapRule) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["source"]; raw != nil && !ok {
		return fmt.Errorf("field source in StructureMapRule: required")
	}
	type Plain StructureMapRule
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureMapRule(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapSource struct {
	// Extensions for check
	Check *Element `json:"_check,omitempty"`

	// Extensions for condition
	Condition *Element `json:"_condition,omitempty"`

	// Extensions for context
	Context *Element `json:"_context,omitempty"`

	// Extensions for defaultValue
	DefaultValue *Element `json:"_defaultValue,omitempty"`

	// Extensions for element
	Element *Element `json:"_element,omitempty"`

	// Extensions for listMode
	ListMode *Element `json:"_listMode,omitempty"`

	// Extensions for logMessage
	LogMessage *Element `json:"_logMessage,omitempty"`

	// Extensions for max
	Max *Element `json:"_max,omitempty"`

	// Extensions for min
	Min *Element `json:"_min,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// Extensions for variable
	Variable *Element `json:"_variable,omitempty"`

	// FHIRPath expression  - must be true or the mapping engine throws an error
	// instead of completing.
	Check_2 *String `json:"check,omitempty"`

	// FHIRPath expression  - must be true or the rule does not apply.
	Condition_2 *String `json:"condition,omitempty"`

	// Type or variable this rule applies to.
	Context_2 *ID `json:"context,omitempty"`

	// A value to use if there is no existing value in the source object.
	DefaultValue_2 *String `json:"defaultValue,omitempty"`

	// Optional field for this source.
	Element_2 *String `json:"element,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// How to handle the list mode for this element.
	ListMode_2 *Code `json:"listMode,omitempty"`

	// A FHIRPath expression which specifies a message to put in the transform log
	// when content matching the source rule is found.
	LogMessage_2 *String `json:"logMessage,omitempty"`

	// Specified maximum cardinality for the element - a number or a "*". This is
	// optional; if present, it acts an implicit check on the input content (* just
	// serves as documentation; it's the default value).
	Max_2 *String `json:"max,omitempty"`

	// Specified minimum cardinality for the element. This is optional; if present, it
	// acts an implicit check on the input content.
	Min_2 *UnsignedInt `json:"min,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Specified type for the element. This works as a condition on the mapping - use
	// for polymorphic elements.
	Type_2 *String `json:"type,omitempty"`

	// Named context for field, if a field is specified.
	Variable_2 *ID `json:"variable,omitempty"`
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapStructure struct {
	// Extensions for alias
	Alias *Element `json:"_alias,omitempty"`

	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for mode
	Mode *Element `json:"_mode,omitempty"`

	// The name used for this type in the map.
	Alias_2 *String `json:"alias,omitempty"`

	// Documentation that describes how the structure is used in the mapping.
	Documentation_2 *String `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// How the referenced structure is used in this mapping.
	Mode_2 *Code `json:"mode,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The canonical reference to the structure.
	Url Canonical `json:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMapStructure) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in StructureMapStructure: required")
	}
	type Plain StructureMapStructure
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StructureMapStructure(plain)
	return nil
}

// A Map of relationships between 2 structures that can be used to transform data.
type StructureMapTarget struct {
	// Extensions for context
	Context *Element `json:"_context,omitempty"`

	// Extensions for element
	Element *Element `json:"_element,omitempty"`

	// Extensions for listMode
	ListMode []Element `json:"_listMode,omitempty"`

	// Extensions for listRuleId
	ListRuleID *Element `json:"_listRuleId,omitempty"`

	// Extensions for transform
	Transform *Element `json:"_transform,omitempty"`

	// Extensions for variable
	Variable *Element `json:"_variable,omitempty"`

	// Variable this rule applies to.
	Context_2 *String `json:"context,omitempty"`

	// Field to create in the context.
	Element_2 *String `json:"element,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If field is a list, how to manage the list.
	ListMode_2 []Code `json:"listMode,omitempty"`

	// Internal rule reference for shared list items.
	ListRuleID_2 *ID `json:"listRuleId,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Parameters to the transform.
	Parameter []StructureMapParameter `json:"parameter,omitempty"`

	// How the data is copied / created.
	Transform_2 *Code `json:"transform,omitempty"`

	// Named context for field, if desired, and a field is specified.
	Variable_2 *ID `json:"variable,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureMap) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["group"]; raw != nil && !ok {
		return fmt.Errorf("field group in StructureMap: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in StructureMap: required")
	}
	type Plain StructureMap
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = StructureMap(plain)
	return nil
}

// The subscription resource describes a particular client's request to be notified
// about a SubscriptionTopic.
type Subscription struct {
	// Extensions for content
	Content *Element `json:"_content,omitempty"`

	// Extensions for contentType
	ContentType *Element `json:"_contentType,omitempty"`

	// Extensions for end
	End *Element `json:"_end,omitempty"`

	// Extensions for endpoint
	Endpoint *Element `json:"_endpoint,omitempty"`

	// Extensions for heartbeatPeriod
	HeartbeatPeriod *Element `json:"_heartbeatPeriod,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for maxCount
	MaxCount *Element `json:"_maxCount,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for reason
	Reason *Element `json:"_reason,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for timeout
	Timeout *Element `json:"_timeout,omitempty"`

	// The type of channel to send notifications on.
	ChannelType Coding `json:"channelType"`

	// Contact details for a human to contact about the subscription. The primary use
	// of this for system administrator troubleshooting.
	Contact []ContactPoint `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SubscriptionContainedElem `json:"contained,omitempty"`

	// How much resource content to deliver in the notification payloads. The choices
	// are an empty payload, only the resource id, or the full resource content.
	Content_2 *Code `json:"content,omitempty"`

	// The MIME type to send the payload in - e.g., `application/fhir+xml` or
	// `application/fhir+json`. Note that:
	//
	// * clients may request notifications in a specific FHIR version by using the
	// [FHIR Version Parameter](http.html#version-parameter) - e.g.,
	// `application/fhir+json; fhirVersion=4.0`.
	//
	// * additional MIME types can be allowed by channels - e.g., `text/plain` and
	// `text/html` are defined by the Email channel.
	ContentType_2 *Code `json:"contentType,omitempty"`

	// The time for the server to turn the subscription off.
	End_2 *Instant `json:"end,omitempty"`

	// Channel-specific URL that describes where notifications are sent.
	Endpoint_2 *Url `json:"endpoint,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The filter properties to be applied to narrow the subscription topic stream.
	// When multiple filters are applied, evaluates to true if all the conditions
	// applicable to that resource are met; otherwise it returns false (i.e., logical
	// AND).
	FilterBy []SubscriptionFilterBy `json:"filterBy,omitempty"`

	// If present, a 'heartbeat' notification (keep-alive) is sent via this channel
	// with an interval period equal to this elements integer value in seconds.  If
	// not present, a heartbeat notification is not sent.
	HeartbeatPeriod_2 *UnsignedInt `json:"heartbeatPeriod,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this code system when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Entity with authorization to communicate with the server about this
	// Subscription, such as requesting changes (e.g., updating an endpoint URL).
	ManagingEntity *Reference `json:"managingEntity,omitempty"`

	// If present, the maximum number of events that will be included in a
	// notification bundle. Note that this is not a strict limit on the number of
	// entries in a bundle, as dependent resources can be included.
	MaxCount_2 *PositiveInt `json:"maxCount,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the subscription.
	Name_2 *String `json:"name,omitempty"`

	// Channel-dependent information to send as part of the notification (e.g., HTTP
	// Headers).
	Parameter []SubscriptionParameter `json:"parameter,omitempty"`

	// A description of why this subscription is defined.
	Reason_2 *String `json:"reason,omitempty"`

	// This is a Subscription resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the subscription, which marks the server state for managing the
	// subscription.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// If present, the maximum amount of time a server will allow before failing a
	// notification attempt.
	Timeout_2 *UnsignedInt `json:"timeout,omitempty"`

	// The reference to the subscription topic to be notified about.
	Topic Canonical `json:"topic"`
}

type SubscriptionContainedElem interface{}

// The subscription resource describes a particular client's request to be notified
// about a SubscriptionTopic.
type SubscriptionFilterBy struct {
	// Extensions for comparator
	Comparator *Element `json:"_comparator,omitempty"`

	// Extensions for filterParameter
	FilterParameter *Element `json:"_filterParameter,omitempty"`

	// Extensions for modifier
	Modifier *Element `json:"_modifier,omitempty"`

	// Extensions for resource
	Resource *Element `json:"_resource,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Comparator applied to this filter parameter.
	Comparator_2 *Code `json:"comparator,omitempty"`

	// An event filter to be applied to the topic - e.g., if a topic defined multiple
	// event triggers, this can be used to specify a single one.  Multiple values are
	// or-joined, multiple codings within a value are and-joined.
	Event []CodeableConcept `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The filter as defined in the `SubscriptionTopic.canFilterBy.filterParameter`
	// element.
	FilterParameter_2 *String `json:"filterParameter,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Modifier applied to this filter parameter.
	Modifier_2 *Code `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A resource listed in the `SubscriptionTopic` this `Subscription` references
	// (`SubscriptionTopic.canFilterBy.resource`). This element can be used to
	// differentiate filters for topics that include more than one resource type.
	Resource_2 *Uri `json:"resource,omitempty"`

	// The literal value or resource path as is legal in search - for example,
	// `Patient/123` or `le1950`.
	Value_2 *String `json:"value,omitempty"`
}

// The subscription resource describes a particular client's request to be notified
// about a SubscriptionTopic.
type SubscriptionParameter struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Parameter name for information passed to the channel for notifications, for
	// example in the case of a REST hook wanting to pass through an authorization
	// header, the name would be Authorization.
	Name_2 *String `json:"name,omitempty"`

	// Parameter value for information passed to the channel for notifications, for
	// example in the case of a REST hook wanting to pass through an authorization
	// header, the value would be `Bearer 0193...`.
	Value_2 *String `json:"value,omitempty"`
}

// The SubscriptionStatus resource describes the state of a Subscription during
// notifications.
type SubscriptionStatus struct {
	// Extensions for eventsSinceSubscriptionStart
	EventsSinceSubscriptionStart *Element `json:"_eventsSinceSubscriptionStart,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SubscriptionStatusContainedElem `json:"contained,omitempty"`

	// A record of errors that occurred when the server processed a notification.
	Error []CodeableConcept `json:"error,omitempty"`

	// The total number of actual events which have been generated since the
	// Subscription was created (inclusive of this notification) - regardless of how
	// many have been successfully communicated.  This number is NOT incremented for
	// handshake and heartbeat notifications.
	EventsSinceSubscriptionStart_2 *Integer64 `json:"eventsSinceSubscriptionStart,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Detailed information about events relevant to this subscription notification.
	NotificationEvent []SubscriptionStatusNotificationEvent `json:"notificationEvent,omitempty"`

	// This is a SubscriptionStatus resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the subscription, which marks the server state for managing the
	// subscription.
	Status_2 *Code `json:"status,omitempty"`

	// The reference to the Subscription which generated this notification.
	Subscription Reference `json:"subscription"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// The reference to the SubscriptionTopic for the Subscription which generated
	// this notification.
	Topic *Canonical `json:"topic,omitempty"`

	// The type of event being conveyed with this notification.
	Type_2 *Code `json:"type,omitempty"`
}

// The SubscriptionStatus resource describes the state of a Subscription during
// notifications.
type SubscriptionStatusAuthorizationHint struct {
	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Used by clients to determine what kind of authorization hint is being suggested
	// by the sender.
	AuthorizationType Coding `json:"authorizationType"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A value related to the authorization (e.g., a token).
	Value_2 *String `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatusAuthorizationHint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["authorizationType"]; raw != nil && !ok {
		return fmt.Errorf("field authorizationType in SubscriptionStatusAuthorizationHint: required")
	}
	type Plain SubscriptionStatusAuthorizationHint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatusAuthorizationHint(plain)
	return nil
}

type SubscriptionStatusContainedElem interface{}

// The SubscriptionStatus resource describes the state of a Subscription during
// notifications.
type SubscriptionStatusNotificationEvent struct {
	// Extensions for eventNumber
	EventNumber *Element `json:"_eventNumber,omitempty"`

	// Extensions for timestamp
	Timestamp *Element `json:"_timestamp,omitempty"`

	// Additional context information for this event. Generally, this will contain
	// references to related resources included with the event (e.g., the Patient
	// relevant to an Encounter), however it MAY refer to non-FHIR objects.
	AdditionalContext []Reference `json:"additionalContext,omitempty"`

	// Authorization context information and value (e.g., token).
	AuthorizationHint []SubscriptionStatusAuthorizationHint `json:"authorizationHint,omitempty"`

	// Either the sequential number of this event in this subscription context or a
	// relative event number for this notification.
	EventNumber_2 *Integer64 `json:"eventNumber,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The focus of this event. While this will usually be a reference to the focus
	// resource of the event, it MAY contain a reference to a non-FHIR object.
	Focus *Reference `json:"focus,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Queries and codes that could be included with notifications of this shape.
	// Servers MAY include these queries if supported and desired in the workflow.
	RelatedQuery []SubscriptionStatusRelatedQuery `json:"relatedQuery,omitempty"`

	// The actual time this event occurred on the server.
	Timestamp_2 *Instant `json:"timestamp,omitempty"`

	// If present, one or more event codes specifying the events which triggered this
	// notification.
	TriggerEvent []CodeableConcept `json:"triggerEvent,omitempty"`
}

// The SubscriptionStatus resource describes the state of a Subscription during
// notifications.
type SubscriptionStatusRelatedQuery struct {
	// Extensions for query
	Query *Element `json:"_query,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Query a subscriber can use to retrieve additional information. The exact
	// contents of the query MAY depend on the value of the `queryType`, however this
	// SHOULD be a query suitable for use as an HTTP GET request (either
	// fully-qualified or partial).
	Query_2 *String `json:"query,omitempty"`

	// Coded value(s) used to describe the type of information that evaluating this
	// query will provide. Subscribers can use the values to ensure the data they
	// request are relevant and necessary for their use.
	QueryType *Coding `json:"queryType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in SubscriptionStatus: required")
	}
	if _, ok := raw["subscription"]; raw != nil && !ok {
		return fmt.Errorf("field subscription in SubscriptionStatus: required")
	}
	type Plain SubscriptionStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubscriptionStatus(plain)
	return nil
}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopic struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the asset content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SubscriptionTopicContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the SubscriptionTopic and/or its contents.
	// Copyright statements are notices of intellectual property ownership and can
	// include restrictions on the use and publishing of the SubscriptionTopic.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date (and optionally time) when the subscription topic was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the subscription topic changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// The canonical URL pointing to another FHIR-defined SubscriptionTopic that is
	// adhered to in whole or in part by this SubscriptionTopic.
	DerivedFrom []Canonical `json:"derivedFrom,omitempty"`

	// A free text natural language description of the Topic from the consumer's
	// perspective.
	Description_2 *Markdown `json:"description,omitempty"`

	// The period during which the SubscriptionTopic content was or is planned to be
	// effective.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// A flag to indicate that this TopSubscriptionTopicic is authored for testing
	// purposes (or education/evaluation/marketing), and is not intended to be used
	// for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Business identifiers assigned to this subscription topic by the performer
	// and/or other systems.  These identifiers remain constant as the resource is
	// updated and propagates from server to server.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A jurisdiction in which the Topic is intended to be used.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the asset content was last reviewed. Review happens
	// periodically after that, but doesn't change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the subscription topic This name should be
	// usable as an identifier for the module by machine processing applications such
	// as code generation.
	Name_2 *String `json:"name,omitempty"`

	// Helps establish the "authority/credibility" of the SubscriptionTopic.  May also
	// allow for contact.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explains why this Topic is needed and why it has been designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a SubscriptionTopic resource
	ResourceType interface{} `json:"resourceType"`

	// The current state of the SubscriptionTopic.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the subscription topic.  For
	// example, "admission".
	Title_2 *String `json:"title,omitempty"`

	// A definition of a state change or event that triggers a notification based on
	// the SubscriptionTopic. The criteria may be just a human readable description,
	// or may contain a FHIRPath expression, query-based definition, or event coding.
	// Multiple triggers are considered OR joined (e.g., an update matching ANY of the
	// definitions will trigger a notification).
	Trigger []SubscriptionTopicTrigger `json:"trigger,omitempty"`

	// An absolute URI that is used to identify this subscription topic when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this subscription topic is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the subscription topic is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These terms may be used to assist with indexing and searching
	// of code system definitions.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the subscription topic
	// when it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the Topic author and is not expected to be globally
	// unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed
	// version is not available. There is also no expectation that versions are
	// orderable.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopicCanFilterBy struct {
	// Extensions for comparator
	Comparator []Element `json:"_comparator,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for filterDefinition
	FilterDefinition *Element `json:"_filterDefinition,omitempty"`

	// Extensions for filterParameter
	FilterParameter *Element `json:"_filterParameter,omitempty"`

	// Extensions for modifier
	Modifier []Element `json:"_modifier,omitempty"`

	// Extensions for resource
	Resource *Element `json:"_resource,omitempty"`

	// Comparators allowed for the filter parameter.
	Comparator_2 []Code `json:"comparator,omitempty"`

	// Description of how this filtering parameter is intended to be used.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Either the canonical URL to a search parameter (like
	// "http://hl7.org/fhir/SearchParameter/encounter-patient") or the
	// officially-defined URI for a shared filter concept (like
	// "http://example.org/concepts/shared-common-event").
	FilterDefinition_2 *Uri `json:"filterDefinition,omitempty"`

	// Either the canonical URL to a search parameter (like
	// "http://hl7.org/fhir/SearchParameter/encounter-patient") or topic-defined
	// parameter (like "hub.event") which is a label for the filter.
	FilterParameter_2 *String `json:"filterParameter,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Modifiers allowed for the filter parameter.
	Modifier_2 []Code `json:"modifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// URL of the Resource that is the type used in this filter. This is the "focus"
	// of the topic (or one of them if there are more than one). It will be the same,
	// a generality, or a specificity of the `SubscriptionTopic.trigger.resource` if
	// this is present.
	Resource_2 *Uri `json:"resource,omitempty"`
}

type SubscriptionTopicContainedElem interface{}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopicNotificationShape struct {
	// Extensions for include
	Include []Element `json:"_include,omitempty"`

	// Extensions for resource
	Resource *Element `json:"_resource,omitempty"`

	// Extensions for revInclude
	RevInclude []Element `json:"_revInclude,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Search-style _include directives, rooted in the resource for this shape.
	// Servers SHOULD include resources listed here, if they exist and the user is
	// authorized to receive them.  Clients SHOULD be prepared to receive these
	// additional resources, but SHALL function properly without them.
	Include_2 []String `json:"include,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Queries and codes that could be included with notifications of this shape.
	// Servers MAY include these queries if supported and desired in the workflow.
	RelatedQuery []SubscriptionTopicRelatedQuery `json:"relatedQuery,omitempty"`

	// URL of the Data Type, Resource, or definition (e.g., logical model) that is the
	// type used in this shape. This is the 'focus' resource of the topic (or one of
	// them if there are more than one) and the root for this shape definition. It
	// will be the same, a generality, or a specificity of
	// `SubscriptionTopic.trigger.resource` when it is present.
	Resource_2 *Uri `json:"resource,omitempty"`

	// Search-style _revinclude directives, rooted in the resource for this shape.
	// Servers SHOULD include resources listed here, if they exist and the user is
	// authorized to receive them.  Clients SHOULD be prepared to receive these
	// additional resources, but SHALL function properly without them.
	RevInclude_2 []String `json:"revInclude,omitempty"`
}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopicQueryCriteria struct {
	// Extensions for current
	Current *Element `json:"_current,omitempty"`

	// Extensions for previous
	Previous *Element `json:"_previous,omitempty"`

	// Extensions for requireBoth
	RequireBoth *Element `json:"_requireBoth,omitempty"`

	// Extensions for resultForCreate
	ResultForCreate *Element `json:"_resultForCreate,omitempty"`

	// Extensions for resultForDelete
	ResultForDelete *Element `json:"_resultForDelete,omitempty"`

	// The FHIR query based rules are applied to the current resource state (e.g.,
	// state after an update).
	Current_2 *String `json:"current,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The FHIR query based rules are applied to the previous resource state (e.g.,
	// state before an update).
	Previous_2 *String `json:"previous,omitempty"`

	// If set to `true`, both the `current` and `previous` query criteria must
	// evaluate `true` to trigger a notification for this topic.  If set to `false` or
	// not present, a notification for this topic will be triggered if either the
	// `current` or `previous` tests evaluate to `true`.
	RequireBoth_2 *Boolean `json:"requireBoth,omitempty"`

	// For `create` interactions, should the `previous` criteria count as an automatic
	// pass or an automatic fail. If not present, the testing behavior during `create`
	// interactions is unspecified (server discretion).
	ResultForCreate_2 *Code `json:"resultForCreate,omitempty"`

	// For 'delete' interactions, should the 'current' query criteria count as an
	// automatic pass or an automatic fail. If not present, the testing behavior
	// during `delete` interactions is unspecified (server discretion).
	ResultForDelete_2 *Code `json:"resultForDelete,omitempty"`
}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopicRelatedQuery struct {
	// Extensions for query
	Query *Element `json:"_query,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Query a subscriber can use to retrieve additional information. The exact
	// contents of the query MAY depend on the value of the `queryType`, however this
	// SHOULD be a query suitable for use as an HTTP GET request (either
	// fully-qualified or partial).
	Query_2 *String `json:"query,omitempty"`

	// Coded value(s) used to describe the type of information that evaluating this
	// query will provide. Subscribers can use the values to ensure the data they
	// request are relevant and necessary for their use.
	QueryType *Coding `json:"queryType,omitempty"`
}

// Describes a stream of resource state changes or events and annotated with labels
// useful to filter projections from this topic.
type SubscriptionTopicTrigger struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for fhirPathCriteria
	FhirPathCriteria *Element `json:"_fhirPathCriteria,omitempty"`

	// Extensions for resource
	Resource *Element `json:"_resource,omitempty"`

	// Extensions for supportedInteraction
	SupportedInteraction []Element `json:"_supportedInteraction,omitempty"`

	// List of properties by which Subscriptions can be filtered. May be defined
	// Search Parameters (e.g., Encounter.patient) or parameters defined within this
	// SubscriptionTopic context (e.g., hub.event).
	CanFilterBy []SubscriptionTopicCanFilterBy `json:"canFilterBy,omitempty"`

	// The human readable description of this trigger for the SubscriptionTopic -  for
	// example, "An Encounter enters the 'in-progress' state".
	Description_2 *Markdown `json:"description,omitempty"`

	// A well-defined event which can be used to trigger notifications from the
	// SubscriptionTopic.
	Event *CodeableConcept `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The FHIRPath based rules that the server should use to determine when to
	// trigger a notification for this topic.
	FhirPathCriteria_2 *String `json:"fhirPathCriteria,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// List of properties to describe the shape (e.g., resources) included in
	// notifications from this trigger.
	NotificationShape []SubscriptionTopicNotificationShape `json:"notificationShape,omitempty"`

	// The FHIR query based rules that the server should use to determine when to
	// trigger a notification for this subscription topic.
	QueryCriteria *SubscriptionTopicQueryCriteria `json:"queryCriteria,omitempty"`

	// URL of the key definition that is relevant to this trigger.  Relative URLs are
	// relative to the StructureDefinition root of the implemented FHIR version (e.g.,
	// http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to
	// http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a
	// href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
	Resource_2 *Uri `json:"resource,omitempty"`

	// The FHIR RESTful interaction which can be used to trigger a notification for
	// the SubscriptionTopic. Multiple values are considered OR joined (e.g., CREATE
	// or UPDATE). If not present, all supported interactions are assumed.
	SupportedInteraction_2 []Code `json:"supportedInteraction,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionTopic) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in SubscriptionTopic: required")
	}
	type Plain SubscriptionTopic
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SubscriptionTopic(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Subscription) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["channelType"]; raw != nil && !ok {
		return fmt.Errorf("field channelType in Subscription: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Subscription: required")
	}
	if _, ok := raw["topic"]; raw != nil && !ok {
		return fmt.Errorf("field topic in Subscription: required")
	}
	type Plain Subscription
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Subscription(plain)
	return nil
}

// A homogeneous material with a definite composition.
type Substance struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for expiry
	Expiry *Element `json:"_expiry,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// A code that classifies the general type of substance.  This is used  for
	// searching, sorting and display purposes.
	Category []CodeableConcept `json:"category,omitempty"`

	// A code (or set of codes) that identify this substance.
	Code CodeableReference `json:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SubstanceContainedElem `json:"contained,omitempty"`

	// A description of the substance - its appearance, handling requirements, and
	// other usage notes.
	Description_2 *Markdown `json:"description,omitempty"`

	// When the substance is no longer valid to use. For some substances, a single
	// arbitrary date is used for expiry.
	Expiry_2 *DateTime `json:"expiry,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Unique identifier for the substance, often an identifier associated with the
	// package/container of the substance instance (usually a label affixed directly).
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The amount of the substance.
	Quantity *Quantity `json:"quantity,omitempty"`

	// This is a Substance resource
	ResourceType interface{} `json:"resourceType"`

	// A code to indicate if the substance is actively used.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type SubstanceContainedElem interface{}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinition struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// General specifications for this substance.
	Characterization []SubstanceDefinitionCharacterization `json:"characterization,omitempty"`

	// A high level categorization, e.g. polymer or nucleic acid, or food, chemical,
	// biological, or a lower level such as the general types of polymer (linear or
	// branch chain) or type of impurity (process related or contaminant).
	Classification []CodeableConcept `json:"classification,omitempty"`

	// Codes associated with the substance.
	Code []SubstanceDefinitionCode `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []SubstanceDefinitionContainedElem `json:"contained,omitempty"`

	// Textual description of the substance.
	Description_2 *Markdown `json:"description,omitempty"`

	// The applicable usage of the substance, as an example human or veterinary.
	Domain *CodeableConcept `json:"domain,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The quality standard, established benchmark, to which substance complies (e.g.
	// USP/NF, Ph. Eur, JP, BP, Company Standard).
	Grade []CodeableConcept `json:"grade,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// Identifier by which this substance is known.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The entity that creates, makes, produces or fabricates the substance. This is a
	// set of potential manufacturers but is not necessarily comprehensive.
	Manufacturer []Reference `json:"manufacturer,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Moiety, for structural modifications.
	Moiety []SubstanceDefinitionMoiety `json:"moiety,omitempty"`

	// The average mass of a molecule of a compound compared to 1/12 the mass of
	// carbon 12 and calculated as the sum of the atomic weights of the constituent
	// atoms.
	MolecularWeight []SubstanceDefinitionMolecularWeight `json:"molecularWeight,omitempty"`

	// Names applicable to this substance.
	Name []SubstanceDefinitionName `json:"name,omitempty"`

	// Textual comment about the substance's catalogue or registry record.
	Note []Annotation `json:"note,omitempty"`

	// General specifications for this substance.
	Property []SubstanceDefinitionProperty `json:"property,omitempty"`

	// A link between this substance and another, with details of the relationship.
	Relationship []SubstanceDefinitionRelationship `json:"relationship,omitempty"`

	// This is a SubstanceDefinition resource
	ResourceType interface{} `json:"resourceType"`

	// Material or taxonomic/anatomical source for the substance.
	SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourceMaterial,omitempty"`

	// Status of substance within the catalogue e.g. active, retired.
	Status *CodeableConcept `json:"status,omitempty"`

	// Structural information.
	Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`

	// An entity that is the source for the substance. It may be different from the
	// manufacturer. Supplier is synonymous to a distributor.
	Supplier []Reference `json:"supplier,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A business level edition or revision identifier.
	Version_2 *String `json:"version,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionCharacterization struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// The description or justification in support of the interpretation of the data
	// file.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The data produced by the analytical instrument or a pictorial representation of
	// that data. Examples: a JCAMP, JDX, or ADX file, or a chromatogram or spectrum
	// analysis.
	File []Attachment `json:"file,omitempty"`

	// Describes the nature of the chemical entity and explains, for instance, whether
	// this is a base or a salt form.
	Form *CodeableConcept `json:"form,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The method used to elucidate the characterization of the drug substance.
	// Example: HPLC.
	Technique *CodeableConcept `json:"technique,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionCode struct {
	// Extensions for statusDate
	StatusDate *Element `json:"_statusDate,omitempty"`

	// The specific code.
	Code *CodeableConcept `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Any comment can be provided in this field, if necessary.
	Note []Annotation `json:"note,omitempty"`

	// Supporting literature.
	Source []Reference `json:"source,omitempty"`

	// Status of the code assignment, for example 'provisional', 'approved'.
	Status *CodeableConcept `json:"status,omitempty"`

	// The date at which the code status was changed as part of the terminology
	// maintenance.
	StatusDate_2 *DateTime `json:"statusDate,omitempty"`
}

type SubstanceDefinitionContainedElem interface{}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionMoiety struct {
	// Extensions for amountString
	AmountString *Element `json:"_amountString,omitempty"`

	// Extensions for molecularFormula
	MolecularFormula *Element `json:"_molecularFormula,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Quantitative value for this moiety.
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`

	// Quantitative value for this moiety.
	AmountString_2 *string `json:"amountString,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Identifier by which this moiety substance is known.
	Identifier *Identifier `json:"identifier,omitempty"`

	// The measurement type of the quantitative value. In capturing the actual
	// relative amounts of substances or molecular fragments it may be necessary to
	// indicate whether the amount refers to, for example, a mole ratio or weight
	// ratio.
	MeasurementType *CodeableConcept `json:"measurementType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Molecular formula for this moiety of this substance, typically using the Hill
	// system.
	MolecularFormula_2 *String `json:"molecularFormula,omitempty"`

	// Textual name for this moiety substance.
	Name_2 *String `json:"name,omitempty"`

	// Optical activity type.
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`

	// Role that the moiety is playing.
	Role *CodeableConcept `json:"role,omitempty"`

	// Stereochemistry type.
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubstanceDefinitionMoiety) UnmarshalJSON(value []byte) error {
	type Plain SubstanceDefinitionMoiety
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AmountString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AmountString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AmountString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SubstanceDefinitionMoiety(plain)
	return nil
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionMolecularWeight struct {
	// Used to capture quantitative values for a variety of elements. If only limits
	// are given, the arithmetic mean would be the average. If only a single definite
	// value for a given element is given, it would be captured in this field.
	Amount Quantity `json:"amount"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The method by which the molecular weight was determined.
	Method *CodeableConcept `json:"method,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Type of molecular weight such as exact, average (also known as. number
	// average), weight average.
	Type *CodeableConcept `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubstanceDefinitionMolecularWeight) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in SubstanceDefinitionMolecularWeight: required")
	}
	type Plain SubstanceDefinitionMolecularWeight
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubstanceDefinitionMolecularWeight(plain)
	return nil
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionName struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for preferred
	Preferred *Element `json:"_preferred,omitempty"`

	// The use context of this name for example if there is a different name a drug
	// active ingredient as opposed to a food colour additive.
	Domain []CodeableConcept `json:"domain,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The jurisdiction where this name applies.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// Human language that the name is written in.
	Language []CodeableConcept `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The actual name.
	Name_2 *String `json:"name,omitempty"`

	// Details of the official nature of this name.
	Official []SubstanceDefinitionOfficial `json:"official,omitempty"`

	// If this is the preferred name for this substance.
	Preferred_2 *Boolean `json:"preferred,omitempty"`

	// Supporting literature.
	Source []Reference `json:"source,omitempty"`

	// The status of the name, for example 'current', 'proposed'.
	Status *CodeableConcept `json:"status,omitempty"`

	// A synonym of this particular name, by which the substance is also known.
	Synonym []SubstanceDefinitionName `json:"synonym,omitempty"`

	// A translation for this name into another human language.
	Translation []SubstanceDefinitionName `json:"translation,omitempty"`

	// Name type, for example 'systematic',  'scientific, 'brand'.
	Type *CodeableConcept `json:"type,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionOfficial struct {
	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Which authority uses this official name.
	Authority *CodeableConcept `json:"authority,omitempty"`

	// Date of the official name change.
	Date_2 *DateTime `json:"date,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The status of the official name, for example 'draft', 'active', 'retired'.
	Status *CodeableConcept `json:"status,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionProperty struct {
	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code expressing the type of property.
	Type CodeableConcept `json:"type"`

	// A value for the property.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// A value for the property.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// A value for the property.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value for the property.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// A value for the property.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A value for the property.
	ValueRange *Range `json:"valueRange,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubstanceDefinitionProperty) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SubstanceDefinitionProperty: required")
	}
	type Plain SubstanceDefinitionProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	*j = SubstanceDefinitionProperty(plain)
	return nil
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionRelationship struct {
	// Extensions for amountString
	AmountString *Element `json:"_amountString,omitempty"`

	// Extensions for isDefining
	IsDefining *Element `json:"_isDefining,omitempty"`

	// A numeric factor for the relationship, for instance to express that the salt of
	// a substance has some percentage of the active substance in relation to some
	// other.
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`

	// A numeric factor for the relationship, for instance to express that the salt of
	// a substance has some percentage of the active substance in relation to some
	// other.
	AmountRatio *Ratio `json:"amountRatio,omitempty"`

	// A numeric factor for the relationship, for instance to express that the salt of
	// a substance has some percentage of the active substance in relation to some
	// other.
	AmountString_2 *string `json:"amountString,omitempty"`

	// An operator for the amount, for example "average", "approximately", "less
	// than".
	Comparator *CodeableConcept `json:"comparator,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// For example where an enzyme strongly bonds with a particular substance, this is
	// a defining relationship for that enzyme, out of several possible substance
	// relationships.
	IsDefining_2 *Boolean `json:"isDefining,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// For use when the numeric has an uncertain range.
	RatioHighLimitAmount *Ratio `json:"ratioHighLimitAmount,omitempty"`

	// Supporting literature.
	Source []Reference `json:"source,omitempty"`

	// A pointer to another substance, as a resource or just a representational code.
	SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substanceDefinitionCodeableConcept,omitempty"`

	// A pointer to another substance, as a resource or just a representational code.
	SubstanceDefinitionReference *Reference `json:"substanceDefinitionReference,omitempty"`

	// For example "salt to parent", "active moiety", "starting material",
	// "polymorph", "impurity of".
	Type CodeableConcept `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubstanceDefinitionRelationship) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SubstanceDefinitionRelationship: required")
	}
	type Plain SubstanceDefinitionRelationship
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AmountString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AmountString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AmountString_2", `^^[\s\S]+$$`)
		}
	}
	*j = SubstanceDefinitionRelationship(plain)
	return nil
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionRepresentation struct {
	// Extensions for representation
	Representation *Element `json:"_representation,omitempty"`

	// An attached file with the structural representation e.g. a molecular structure
	// graphic of the substance, a JCAMP or AnIML file.
	Document *Reference `json:"document,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB,
	// mmCIF. The logical content type rather than the physical file format of a
	// document.
	Format *CodeableConcept `json:"format,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The structural representation as a text string in a standard format.
	Representation_2 *String `json:"representation,omitempty"`

	// The kind of structural representation (e.g. full, partial).
	Type *CodeableConcept `json:"type,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionSourceMaterial struct {
	// The country or countries where the material is harvested.
	CountryOfOrigin []CodeableConcept `json:"countryOfOrigin,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The genus of an organism, typically referring to the Latin epithet of the genus
	// element of the plant/animal scientific name.
	Genus *CodeableConcept `json:"genus,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An anatomical origin of the source material within an organism.
	Part *CodeableConcept `json:"part,omitempty"`

	// The species of an organism, typically referring to the Latin epithet of the
	// species of the plant/animal.
	Species *CodeableConcept `json:"species,omitempty"`

	// A classification that provides the origin of the raw material. Example: cat
	// hair would be an Animal source type.
	Type *CodeableConcept `json:"type,omitempty"`
}

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
type SubstanceDefinitionStructure struct {
	// Extensions for molecularFormula
	MolecularFormula *Element `json:"_molecularFormula,omitempty"`

	// Extensions for molecularFormulaByMoiety
	MolecularFormulaByMoiety *Element `json:"_molecularFormulaByMoiety,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An expression which states the number and type of atoms present in a molecule
	// of a substance.
	MolecularFormula_2 *String `json:"molecularFormula,omitempty"`

	// Specified per moiety according to the Hill system, i.e. first C, then H, then
	// alphabetical, each moiety separated by a dot.
	MolecularFormulaByMoiety_2 *String `json:"molecularFormulaByMoiety,omitempty"`

	// The molecular weight or weight range (for proteins, polymers or nucleic acids).
	MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularWeight,omitempty"`

	// Optical activity type.
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`

	// A depiction of the structure of the substance.
	Representation []SubstanceDefinitionRepresentation `json:"representation,omitempty"`

	// The source of information about the structure.
	SourceDocument []Reference `json:"sourceDocument,omitempty"`

	// Stereochemistry type.
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`

	// The method used to elucidate the structure of the drug substance. Examples:
	// X-ray, NMR, Peptide mapping, Ligand binding assay.
	Technique []CodeableConcept `json:"technique,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubstanceDefinition) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in SubstanceDefinition: required")
	}
	type Plain SubstanceDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubstanceDefinition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Substance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in Substance: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Substance: required")
	}
	type Plain Substance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Substance(plain)
	return nil
}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type Task struct {
	// Extensions for authoredOn
	AuthoredOn *Element `json:"_authoredOn,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for doNotPerform
	DoNotPerform *Element `json:"_doNotPerform,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for intent
	Intent *Element `json:"_intent,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastModified
	LastModified *Element `json:"_lastModified,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// The date and time this task was created.
	AuthoredOn_2 *DateTime `json:"authoredOn,omitempty"`

	// BasedOn refers to a higher-level authorization that triggered the creation of
	// the task.  It references a "request" resource such as a ServiceRequest,
	// MedicationRequest, CarePlan, etc. which is distinct from the "request" resource
	// the task is seeking to fulfill.  This latter resource is referenced by focus.
	// For example, based on a CarePlan (= basedOn), a task is created to fulfill a
	// ServiceRequest ( = focus ) to collect a specimen from a patient.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// Contains business-specific nuances of the business state.
	BusinessStatus *CodeableConcept `json:"businessStatus,omitempty"`

	// A name or code (or both) briefly describing what the task involves.
	Code *CodeableConcept `json:"code,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []TaskContainedElem `json:"contained,omitempty"`

	// A free-text description of what is to be performed.
	Description_2 *Markdown `json:"description,omitempty"`

	// If true indicates that the Task is asking for the specified action to *not*
	// occur.
	DoNotPerform_2 *Boolean `json:"doNotPerform,omitempty"`

	// The healthcare event  (e.g. a patient and healthcare provider interaction)
	// during which this task was created.
	Encounter *Reference `json:"encounter,omitempty"`

	// Identifies the time action was first taken against the task (start) and/or the
	// time final action was taken against the task prior to marking it as completed
	// (end).
	ExecutionPeriod *Period `json:"executionPeriod,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The request being fulfilled or the resource being manipulated (changed,
	// suspended, etc.) by this task.
	Focus []TaskFocus `json:"focus,omitempty"`

	// The entity who benefits from the performance of the service specified in the
	// task (e.g., the patient).
	For *Reference `json:"for,omitempty"`

	// A shared identifier common to multiple independent Task and Request instances
	// that were activated/authorized more or less simultaneously by a single author.
	// The presence of the same identifier on each request ties those requests
	// together and may have business ramifications in terms of reporting of results,
	// billing, etc.  E.g. a requisition number shared by a set of lab tests ordered
	// together, or a prescription number shared by all meds ordered at one time.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// The business identifier for this task.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// Additional information that may be needed in the execution of the task.
	Input []TaskInput `json:"input,omitempty"`

	// Insurance plans, coverage extensions, pre-authorizations and/or
	// pre-determinations that may be relevant to the Task.
	Insurance []Reference `json:"insurance,omitempty"`

	// Indicates the "level" of actionability associated with the Task, i.e. this a
	// proposed task, a planned task, an actionable task, etc.
	Intent_2 *Code `json:"intent,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date and time of last modification to this task.
	LastModified_2 *DateTime `json:"lastModified,omitempty"`

	// Principal physical location where this task is performed.
	Location *Reference `json:"location,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Free-text information about the task during its lifecycle.
	Note []Annotation `json:"note,omitempty"`

	// Outputs produced by the Task.
	Output []TaskOutput `json:"output,omitempty"`

	// Party responsible for managing task execution.
	Owner *Reference `json:"owner,omitempty"`

	// Task that this particular task is part of.
	PartOf []Reference `json:"partOf,omitempty"`

	// The entity who performed the requested task.
	Performer []TaskPerformer `json:"performer,omitempty"`

	// Indicates how quickly the Task should be addressed with respect to other
	// requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// A description, code, or reference indicating why this task needs to be
	// performed.
	Reason []CodeableReference `json:"reason,omitempty"`

	// Links to Provenance records for past versions of this Task that identify key
	// state transitions or updates that are likely to be relevant to a user looking
	// at the current version of the task.
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`

	// The kind of participant or specific participant that should perform the task.
	RequestedPerformer []CodeableReference `json:"requestedPerformer,omitempty"`

	// Indicates the start and/or end of the period of time when completion of the
	// task is desired to take place.
	RequestedPeriod *Period `json:"requestedPeriod,omitempty"`

	// The creator of the task.
	Requester *Reference `json:"requester,omitempty"`

	// This is a Task resource
	ResourceType interface{} `json:"resourceType"`

	// If the Task.focus is a request resource and the task is seeking fulfillment
	// (i.e. is asking for the request to be actioned), this element identifies any
	// limitations on what parts of the referenced request should be actioned.
	Restriction *TaskRestriction `json:"restriction,omitempty"`

	// The current status of the task.
	Status_2 *Code `json:"status,omitempty"`

	// An explanation as to why this task is held, failed, was refused, etc.
	StatusReason []CodeableReference `json:"statusReason,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type TaskContainedElem interface{}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type TaskFocus struct {
	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// What task is acting on.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// What task is acting on.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskFocus) UnmarshalJSON(value []byte) error {
	type Plain TaskFocus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	*j = TaskFocus(plain)
	return nil
}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type TaskInput struct {
	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code or description to distinguish between inputs.
	Type CodeableConcept `json:"type"`

	// The value of the input parameter as a basic type.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// The value of the input parameter as a basic type.
	ValueAge *Age `json:"valueAge,omitempty"`

	// The value of the input parameter as a basic type.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// The value of the input parameter as a basic type.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The value of the input parameter as a basic type.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// The value of the input parameter as a basic type.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The value of the input parameter as a basic type.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of the input parameter as a basic type.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// The value of the input parameter as a basic type.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// The value of the input parameter as a basic type.
	ValueCount *Count `json:"valueCount,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// The value of the input parameter as a basic type.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The value of the input parameter as a basic type.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// The value of the input parameter as a basic type.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// The value of the input parameter as a basic type.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// The value of the input parameter as a basic type.
	ValueID_2 *string `json:"valueId,omitempty"`

	// The value of the input parameter as a basic type.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// The value of the input parameter as a basic type.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// The value of the input parameter as a basic type.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of the input parameter as a basic type.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// The value of the input parameter as a basic type.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// The value of the input parameter as a basic type.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// The value of the input parameter as a basic type.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// The value of the input parameter as a basic type.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// The value of the input parameter as a basic type.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// The value of the input parameter as a basic type.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The value of the input parameter as a basic type.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// The value of the input parameter as a basic type.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the input parameter as a basic type.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value of the input parameter as a basic type.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The value of the input parameter as a basic type.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// The value of the input parameter as a basic type.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The value of the input parameter as a basic type.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// The value of the input parameter as a basic type.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The value of the input parameter as a basic type.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// The value of the input parameter as a basic type.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The value of the input parameter as a basic type.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The value of the input parameter as a basic type.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// The value of the input parameter as a basic type.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// The value of the input parameter as a basic type.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// The value of the input parameter as a basic type.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// The value of the input parameter as a basic type.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// The value of the input parameter as a basic type.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// The value of the input parameter as a basic type.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// The value of the input parameter as a basic type.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TaskInput: required")
	}
	type Plain TaskInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = TaskInput(plain)
	return nil
}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type TaskOutput struct {
	// Extensions for valueBase64Binary
	ValueBase64Binary *Element `json:"_valueBase64Binary,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCanonical
	ValueCanonical *Element `json:"_valueCanonical,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDate
	ValueDate *Element `json:"_valueDate,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueId
	ValueID *Element `json:"_valueId,omitempty"`

	// Extensions for valueInstant
	ValueInstant *Element `json:"_valueInstant,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueInteger64
	ValueInteger64 *Element `json:"_valueInteger64,omitempty"`

	// Extensions for valueMarkdown
	ValueMarkdown *Element `json:"_valueMarkdown,omitempty"`

	// Extensions for valueOid
	ValueOid *Element `json:"_valueOid,omitempty"`

	// Extensions for valuePositiveInt
	ValuePositiveInt *Element `json:"_valuePositiveInt,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueTime
	ValueTime *Element `json:"_valueTime,omitempty"`

	// Extensions for valueUnsignedInt
	ValueUnsignedInt *Element `json:"_valueUnsignedInt,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// Extensions for valueUrl
	ValueUrl *Element `json:"_valueUrl,omitempty"`

	// Extensions for valueUuid
	ValueUuid *Element `json:"_valueUuid,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code or description to distinguish between outputs.
	Type CodeableConcept `json:"type"`

	// The value of the Output parameter as a basic type.
	ValueAddress *Address `json:"valueAddress,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueAge *Age `json:"valueAge,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueAvailability *Availability `json:"valueAvailability,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueBase64Binary_2 *string `json:"valueBase64Binary,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCanonical_2 *string `json:"valueCanonical,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueCount *Count `json:"valueCount,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDate_2 *string `json:"valueDate,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDistance *Distance `json:"valueDistance,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDosage *Dosage `json:"valueDosage,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueDuration *Duration `json:"valueDuration,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueExpression *Expression `json:"valueExpression,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueExtendedContactDetail *ExtendedContactDetail `json:"valueExtendedContactDetail,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueID_2 *string `json:"valueId,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueInstant_2 *string `json:"valueInstant,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueInteger64_2 *string `json:"valueInteger64,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueMarkdown_2 *string `json:"valueMarkdown,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueMeta *Meta `json:"valueMeta,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueMoney *Money `json:"valueMoney,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueOid_2 *string `json:"valueOid,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`

	// The value of the Output parameter as a basic type.
	ValuePeriod *Period `json:"valuePeriod,omitempty"`

	// The value of the Output parameter as a basic type.
	ValuePositiveInt_2 *float64 `json:"valuePositiveInt,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueRange *Range `json:"valueRange,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueRatio *Ratio `json:"valueRatio,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueReference *Reference `json:"valueReference,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueSignature *Signature `json:"valueSignature,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueTime_2 *string `json:"valueTime,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueTiming *Timing `json:"valueTiming,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueUnsignedInt_2 *float64 `json:"valueUnsignedInt,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueUri_2 *string `json:"valueUri,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueUrl_2 *string `json:"valueUrl,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueUuid_2 *string `json:"valueUuid,omitempty"`

	// The value of the Output parameter as a basic type.
	ValueVirtualServiceDetail *VirtualServiceDetail `json:"valueVirtualServiceDetail,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TaskOutput: required")
	}
	type Plain TaskOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueBase64Binary_2 != nil {
		if matched, _ := regexp.MatchString(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`, string(*plain.ValueBase64Binary_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueBase64Binary_2", `^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$`)
		}
	}
	if plain.ValueCanonical_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueCanonical_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCanonical_2", `^\S*$`)
		}
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.ValueDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueID_2 != nil {
		if matched, _ := regexp.MatchString(`^[A-Za-z0-9\-\.]{1,64}$`, string(*plain.ValueID_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueID_2", `^[A-Za-z0-9\-\.]{1,64}$`)
		}
	}
	if plain.ValueInstant_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`, string(*plain.ValueInstant_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInstant_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$`)
		}
	}
	if plain.ValueInteger64_2 != nil {
		if matched, _ := regexp.MatchString(`^[0]|[-+]?[1-9][0-9]*$`, string(*plain.ValueInteger64_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueInteger64_2", `^[0]|[-+]?[1-9][0-9]*$`)
		}
	}
	if plain.ValueMarkdown_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueMarkdown_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueMarkdown_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueOid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`, string(*plain.ValueOid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueOid_2", `^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(*plain.ValueTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueTime_2", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	if plain.ValueUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUrl_2", `^\S*$`)
		}
	}
	if plain.ValueUuid_2 != nil {
		if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(*plain.ValueUuid_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUuid_2", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
		}
	}
	*j = TaskOutput(plain)
	return nil
}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type TaskPerformer struct {
	// The actor or entity who performed the task.
	Actor Reference `json:"actor"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A code or description of the performer of the task.
	Function *CodeableConcept `json:"function,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskPerformer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actor"]; raw != nil && !ok {
		return fmt.Errorf("field actor in TaskPerformer: required")
	}
	type Plain TaskPerformer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskPerformer(plain)
	return nil
}

// A task to be performed as a part of a workflow and the related informations like
// inputs, outputs and execution progress. While very simple workflows can be
// implemented with [[[Request]]] alone, most workflows would require a Task
// (explicit or contained) as a means to track the execution progress (i.e. inputs,
// outputs, status). Please refer to
// [Fulfillment/Execution](request.html#fulfillment).
type TaskRestriction struct {
	// Extensions for repetitions
	Repetitions *Element `json:"_repetitions,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The time-period for which fulfillment is sought. This must fall within the
	// overall time period authorized in the referenced request.  E.g.
	// ServiceRequest.occurance[x].
	Period *Period `json:"period,omitempty"`

	// For requests directed at multiple potential recipients or targets, this is used
	// to specify the individual or entity from whom fulfillment is being sought.
	Recipient []Reference `json:"recipient,omitempty"`

	// Indicates the number of times the requested action should occur.
	Repetitions_2 *PositiveInt `json:"repetitions,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Task) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Task(plain)
	return nil
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilities struct {
	// Extensions for codeSearch
	CodeSearch *Element `json:"_codeSearch,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for kind
	Kind *Element `json:"_kind,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lockedDate
	LockedDate *Element `json:"_lockedDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The degree to which the server supports the code search parameter on ValueSet,
	// if it is supported.
	CodeSearch_2 *Code `json:"codeSearch,omitempty"`

	// Identifies a code system that is supported by the server. If there is a no code
	// system URL, then this declares the general assumptions a client can make about
	// support for any CodeSystem resource.
	CodeSystem []TerminologyCapabilitiesCodeSystem `json:"codeSystem,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []TerminologyCapabilitiesContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the terminology capabilities and/or its
	// contents. Copyright statements are notices of intellectual property ownership
	// and can include restrictions on the use and publishing of the terminology
	// capabilities.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date  (and optionally time) when the terminology capabilities was last
	// significantly changed. The date must change when the business version changes
	// and it must change if the status code changes. In addition, it should change
	// when the substantive content of the terminology capabilities changes.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the terminology capabilities from a
	// consumer's perspective. Typically, this is used when the capability statement
	// describes a desired rather than an actual solution, for example as a formal
	// expression of requirements as part of an RFP.
	Description_2 *Markdown `json:"description,omitempty"`

	// Information about the [ValueSet/$expand](valueset-operation-expand.html)
	// operation.
	Expansion *TerminologyCapabilitiesExpansion `json:"expansion,omitempty"`

	// A Boolean value to indicate that this terminology capabilities is authored for
	// testing purposes (or education/evaluation/marketing) and no version of this
	// resource will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this terminology capabilities when
	// it is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// Identifies a specific implementation instance that is described by the
	// terminology capability statement - i.e. a particular installation, rather than
	// the capabilities of a software program.
	Implementation *TerminologyCapabilitiesImplementation `json:"implementation,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The way that this statement is intended to be used, to describe an actual
	// running instance of software, a particular product (kind, not instance of
	// software) or a class of implementation (e.g. a desired purchase).
	Kind_2 *Code `json:"kind,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Whether the server supports lockedDate.
	LockedDate_2 *Boolean `json:"lockedDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the terminology capabilities. This name
	// should be usable as an identifier for the module by machine processing
	// applications such as code generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the terminology capabilities.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this terminology capabilities is needed and why it has been
	// designed as it has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// This is a TerminologyCapabilities resource
	ResourceType interface{} `json:"resourceType"`

	// Software that is covered by this terminology capability statement.  It is used
	// when the statement describes the capabilities of a particular software version,
	// independent of an installation.
	Software *TerminologyCapabilitiesSoftware `json:"software,omitempty"`

	// The status of this terminology capabilities. Enables tracking the life-cycle of
	// the content.
	Status_2 *Code `json:"status,omitempty"`

	// Information about how the system supports CodeSystem supplements.
	Supplements *TerminologyCapabilitiesSupplements `json:"supplements,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the terminology capabilities.
	Title_2 *String `json:"title,omitempty"`

	// Information about the
	// [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
	Translation *TerminologyCapabilitiesTranslation `json:"translation,omitempty"`

	// An absolute URI that is used to identify this terminology capabilities when it
	// is referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which an authoritative instance of this terminology capabilities is
	// (or will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the terminology capabilities is stored on different
	// servers.
	Url_2 *Uri `json:"url,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate terminology
	// capabilities instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// Information about the
	// [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
	ValidateCode *TerminologyCapabilitiesValidateCode `json:"validateCode,omitempty"`

	// The identifier that is used to identify this version of the terminology
	// capabilities when it is referenced in a specification, model, design or
	// instance. This is an arbitrary value managed by the terminology capabilities
	// author and is not expected to be globally unique. For example, it might be a
	// timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
	// no expectation that versions can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which is more
	// current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesCodeSystem struct {
	// Extensions for content
	Content *Element `json:"_content,omitempty"`

	// Extensions for subsumption
	Subsumption *Element `json:"_subsumption,omitempty"`

	// The extent of the content of the code system (the concepts and codes it
	// defines) are represented in this resource instance.
	Content_2 *Code `json:"content,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// True if subsumption is supported for this version of the code system.
	Subsumption_2 *Boolean `json:"subsumption,omitempty"`

	// Canonical identifier for a supported supplement to this code system.
	// Supplements listed here supplement all versions of the code system. This
	// reference SHOULD be version specific.
	Supplement []Canonical `json:"supplement,omitempty"`

	// Canonical identifier for the code system, represented as a URI. This cannot
	// have a version in the canonical URL.
	Uri *Canonical `json:"uri,omitempty"`

	// For the code system, a list of versions that are supported by the server.
	Version []TerminologyCapabilitiesVersion `json:"version,omitempty"`
}

type TerminologyCapabilitiesContainedElem interface{}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesExpansion struct {
	// Extensions for hierarchical
	Hierarchical *Element `json:"_hierarchical,omitempty"`

	// Extensions for incomplete
	Incomplete *Element `json:"_incomplete,omitempty"`

	// Extensions for paging
	Paging *Element `json:"_paging,omitempty"`

	// Extensions for textFilter
	TextFilter *Element `json:"_textFilter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Whether the server can return nested value sets.
	Hierarchical_2 *Boolean `json:"hierarchical,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// True if requests for incomplete expansions are allowed.
	Incomplete_2 *Boolean `json:"incomplete,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether the server supports paging on expansion.
	Paging_2 *Boolean `json:"paging,omitempty"`

	// Supported expansion parameter.
	Parameter []TerminologyCapabilitiesParameter `json:"parameter,omitempty"`

	// Documentation about text searching works.
	TextFilter_2 *Markdown `json:"textFilter,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesFilter struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for op
	Op []Element `json:"_op,omitempty"`

	// Code of the property supported.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Operations supported for the property.
	Op_2 []Code `json:"op,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesImplementation struct {
	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Information about the specific installation that this terminology capability
	// statement relates to.
	Description_2 *Markdown `json:"description,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An absolute base URL for the implementation.
	Url_2 *Url `json:"url,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesParameter struct {
	// Extensions for documentation
	Documentation *Element `json:"_documentation,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Description of support for parameter.
	Documentation_2 *Markdown `json:"documentation,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of the supported expansion parameter.
	Name_2 *Code `json:"name,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesSoftware struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name the software is known by.
	Name_2 *String `json:"name,omitempty"`

	// The version identifier for the software covered by this statement.
	Version_2 *String `json:"version,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesSupplements struct {
	// Extensions for globals
	Globals *Element `json:"_globals,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Codes that describes how the server implements global language packs - that is,
	// supplements that contain only designations for a single language that are
	// marked as intended by the extension
	// http://hl7.org/fhir/StructureDefinition/codesystem-globalLangPack for use with
	// all value sets and codesystem without explicit reference.
	Globals_2 *Code `json:"globals,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesTranslation struct {
	// Extensions for needsMap
	NeedsMap *Element `json:"_needsMap,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether the client must identify the map.
	NeedsMap_2 *Boolean `json:"needsMap,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesValidateCode struct {
	// Extensions for translations
	Translations *Element `json:"_translations,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Whether translations are validated.
	Translations_2 *Boolean `json:"translations,omitempty"`
}

// A TerminologyCapabilities resource documents a set of capabilities (behaviors)
// of a FHIR Terminology Server that may be used as a statement of actual server
// functionality or a statement of required or desired server implementation.
type TerminologyCapabilitiesVersion struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for compositional
	Compositional *Element `json:"_compositional,omitempty"`

	// Extensions for isDefault
	IsDefault *Element `json:"_isDefault,omitempty"`

	// Extensions for language
	Language []Element `json:"_language,omitempty"`

	// Extensions for property
	Property []Element `json:"_property,omitempty"`

	// For version-less code systems, there should be a single version with no
	// identifier.
	Code_2 *String `json:"code,omitempty"`

	// If the compositional grammar defined by the code system is supported.
	Compositional_2 *Boolean `json:"compositional,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Filter Properties supported.
	Filter []TerminologyCapabilitiesFilter `json:"filter,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If this is the default version for this code system.
	IsDefault_2 *Boolean `json:"isDefault,omitempty"`

	// Language Displays supported.
	Language_2 []Code `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Properties supported for $lookup.
	Property_2 []Code `json:"property,omitempty"`

	// Canonical identifier for a supported supplement to this code system.
	// Supplements listed here supplement this specific version of the code system
	// (and by implication, not all of the supported versions). This reference SHOULD
	// be version specific.
	Supplement []Canonical `json:"supplement,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TerminologyCapabilities) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in TerminologyCapabilities: required")
	}
	type Plain TerminologyCapabilities
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = TerminologyCapabilities(plain)
	return nil
}

// A time during the day, with no date specified
type Time string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Time) UnmarshalJSON(value []byte) error {
	type Plain Time
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$`)
	}
	*j = Time(plain)
	return nil
}

// Specifies an event that may occur multiple times. Timing schedules are used to
// record when things are planned, expected or requested to occur. The most common
// usage is in dosage instructions for medications. They are also used when
// planning care of various kinds, and may be used for reporting the schedule to
// which past regular activities were carried out.
type Timing struct {
	// Extensions for event
	Event []Element `json:"_event,omitempty"`

	// A code for the timing schedule (or just text in code.text). Some codes such as
	// BID are ubiquitous, but many institutions define their own additional codes. If
	// a code is provided, the code is understood to be a complete statement of
	// whatever is specified in the structured timing data, and either the code or the
	// data may be used to interpret the Timing, with the exception that
	// .repeat.bounds still applies over the code (and is not contained in the code).
	Code *CodeableConcept `json:"code,omitempty"`

	// Identifies specific times when the event occurs.
	Event_2 []DateTime `json:"event,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A set of rules that describe when the event is scheduled.
	Repeat *TimingRepeat `json:"repeat,omitempty"`
}

// Specifies an event that may occur multiple times. Timing schedules are used to
// record when things are planned, expected or requested to occur. The most common
// usage is in dosage instructions for medications. They are also used when
// planning care of various kinds, and may be used for reporting the schedule to
// which past regular activities were carried out.
type TimingRepeat struct {
	// Extensions for count
	Count *Element `json:"_count,omitempty"`

	// Extensions for countMax
	CountMax *Element `json:"_countMax,omitempty"`

	// Extensions for dayOfWeek
	DayOfWeek []Element `json:"_dayOfWeek,omitempty"`

	// Extensions for duration
	Duration *Element `json:"_duration,omitempty"`

	// Extensions for durationMax
	DurationMax *Element `json:"_durationMax,omitempty"`

	// Extensions for durationUnit
	DurationUnit *Element `json:"_durationUnit,omitempty"`

	// Extensions for frequency
	Frequency *Element `json:"_frequency,omitempty"`

	// Extensions for frequencyMax
	FrequencyMax *Element `json:"_frequencyMax,omitempty"`

	// Extensions for offset
	Offset *Element `json:"_offset,omitempty"`

	// Extensions for period
	Period *Element `json:"_period,omitempty"`

	// Extensions for periodMax
	PeriodMax *Element `json:"_periodMax,omitempty"`

	// Extensions for periodUnit
	PeriodUnit *Element `json:"_periodUnit,omitempty"`

	// Extensions for timeOfDay
	TimeOfDay []Element `json:"_timeOfDay,omitempty"`

	// Extensions for when
	When []Element `json:"_when,omitempty"`

	// Either a duration for the length of the timing schedule, a range of possible
	// length, or outer bounds for start and/or end limits of the timing schedule.
	BoundsDuration *Duration `json:"boundsDuration,omitempty"`

	// Either a duration for the length of the timing schedule, a range of possible
	// length, or outer bounds for start and/or end limits of the timing schedule.
	BoundsPeriod *Period `json:"boundsPeriod,omitempty"`

	// Either a duration for the length of the timing schedule, a range of possible
	// length, or outer bounds for start and/or end limits of the timing schedule.
	BoundsRange *Range `json:"boundsRange,omitempty"`

	// A total count of the desired number of repetitions across the duration of the
	// entire timing specification. If countMax is present, this element indicates the
	// lower bound of the allowed range of count values.
	Count_2 *PositiveInt `json:"count,omitempty"`

	// If present, indicates that the count is a range - so to perform the action
	// between [count] and [countMax] times.
	CountMax_2 *PositiveInt `json:"countMax,omitempty"`

	// If one or more days of week is provided, then the action happens only on the
	// specified day(s).
	DayOfWeek_2 []Code `json:"dayOfWeek,omitempty"`

	// How long this thing happens for when it happens. If durationMax is present,
	// this element indicates the lower bound of the allowed range of the duration.
	Duration_2 *Decimal `json:"duration,omitempty"`

	// If present, indicates that the duration is a range - so to perform the action
	// between [duration] and [durationMax] time length.
	DurationMax_2 *Decimal `json:"durationMax,omitempty"`

	// The units of time for the duration, in UCUM units
	// Normal practice is to use the 'mo' code as a calendar month when calculating
	// the next occurrence.
	DurationUnit_2 *TimingRepeatDurationUnit_2 `json:"durationUnit,omitempty"`

	// Indicates that the events within the period of the repeat step endOffset before
	// the period ends.
	EndOffset *Quantity `json:"endOffset,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The number of times to repeat the action within the specified period. If
	// frequencyMax is present, this element indicates the lower bound of the allowed
	// range of the frequency.
	Frequency_2 *PositiveInt `json:"frequency,omitempty"`

	// If present, indicates that the frequency is a range - so to repeat between
	// [frequency] and [frequencyMax] times within the period or period range.
	FrequencyMax_2 *PositiveInt `json:"frequencyMax,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The number of minutes from the event. If the event code does not indicate
	// whether the minutes is before or after the event, then the offset is assumed to
	// be after the event.
	Offset_2 *UnsignedInt `json:"offset,omitempty"`

	// Indicates the duration of time over which repetitions are to occur; e.g. to
	// express "3 times per day", 3 would be the frequency and "1 day" would be the
	// period. If periodMax is present, this element indicates the lower bound of the
	// allowed range of the period length.
	Period_2 *Decimal `json:"period,omitempty"`

	// If present, indicates that the period is a range from [period] to [periodMax],
	// allowing expressing concepts such as "do this once every 3-5 days.
	PeriodMax_2 *Decimal `json:"periodMax,omitempty"`

	// The units of time for the period in UCUM units
	// Normal practice is to use the 'mo' code as a calendar month when calculating
	// the next occurrence.
	PeriodUnit_2 *TimingRepeatPeriodUnit_2 `json:"periodUnit,omitempty"`

	// Indicates that the events within the period of the repeat do not start until
	// startOffset has elapsed.
	StartOffset *Quantity `json:"startOffset,omitempty"`

	// Specified time of day for action to take place.
	TimeOfDay_2 []Time `json:"timeOfDay,omitempty"`

	// An approximate time period during the day, potentially linked to an event of
	// daily living that indicates when the action should occur.
	When_2 []TimingRepeatWhen_2Elem `json:"when,omitempty"`
}

type TimingRepeatDurationUnit_2 string

const TimingRepeatDurationUnit_2_A TimingRepeatDurationUnit_2 = "a"
const TimingRepeatDurationUnit_2_D TimingRepeatDurationUnit_2 = "d"
const TimingRepeatDurationUnit_2_H TimingRepeatDurationUnit_2 = "h"
const TimingRepeatDurationUnit_2_Min TimingRepeatDurationUnit_2 = "min"
const TimingRepeatDurationUnit_2_Mo TimingRepeatDurationUnit_2 = "mo"
const TimingRepeatDurationUnit_2_S TimingRepeatDurationUnit_2 = "s"
const TimingRepeatDurationUnit_2_Wk TimingRepeatDurationUnit_2 = "wk"

var enumValues_TimingRepeatDurationUnit_2 = []interface{}{
	"s",
	"min",
	"h",
	"d",
	"wk",
	"mo",
	"a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimingRepeatDurationUnit_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimingRepeatDurationUnit_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimingRepeatDurationUnit_2, v)
	}
	*j = TimingRepeatDurationUnit_2(v)
	return nil
}

type TimingRepeatPeriodUnit_2 string

const TimingRepeatPeriodUnit_2_A TimingRepeatPeriodUnit_2 = "a"
const TimingRepeatPeriodUnit_2_D TimingRepeatPeriodUnit_2 = "d"
const TimingRepeatPeriodUnit_2_H TimingRepeatPeriodUnit_2 = "h"
const TimingRepeatPeriodUnit_2_Min TimingRepeatPeriodUnit_2 = "min"
const TimingRepeatPeriodUnit_2_Mo TimingRepeatPeriodUnit_2 = "mo"
const TimingRepeatPeriodUnit_2_S TimingRepeatPeriodUnit_2 = "s"
const TimingRepeatPeriodUnit_2_Wk TimingRepeatPeriodUnit_2 = "wk"

var enumValues_TimingRepeatPeriodUnit_2 = []interface{}{
	"s",
	"min",
	"h",
	"d",
	"wk",
	"mo",
	"a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimingRepeatPeriodUnit_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimingRepeatPeriodUnit_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimingRepeatPeriodUnit_2, v)
	}
	*j = TimingRepeatPeriodUnit_2(v)
	return nil
}

type TimingRepeatWhen_2Elem string

const TimingRepeatWhen_2ElemAC TimingRepeatWhen_2Elem = "AC"
const TimingRepeatWhen_2ElemACD TimingRepeatWhen_2Elem = "ACD"
const TimingRepeatWhen_2ElemACM TimingRepeatWhen_2Elem = "ACM"
const TimingRepeatWhen_2ElemACV TimingRepeatWhen_2Elem = "ACV"
const TimingRepeatWhen_2ElemAFT TimingRepeatWhen_2Elem = "AFT"
const TimingRepeatWhen_2ElemAFTEarly TimingRepeatWhen_2Elem = "AFT.early"
const TimingRepeatWhen_2ElemAFTLate TimingRepeatWhen_2Elem = "AFT.late"
const TimingRepeatWhen_2ElemC TimingRepeatWhen_2Elem = "C"
const TimingRepeatWhen_2ElemCD TimingRepeatWhen_2Elem = "CD"
const TimingRepeatWhen_2ElemCM TimingRepeatWhen_2Elem = "CM"
const TimingRepeatWhen_2ElemCV TimingRepeatWhen_2Elem = "CV"
const TimingRepeatWhen_2ElemEVE TimingRepeatWhen_2Elem = "EVE"
const TimingRepeatWhen_2ElemEVEEarly TimingRepeatWhen_2Elem = "EVE.early"
const TimingRepeatWhen_2ElemEVELate TimingRepeatWhen_2Elem = "EVE.late"
const TimingRepeatWhen_2ElemHS TimingRepeatWhen_2Elem = "HS"
const TimingRepeatWhen_2ElemIMD TimingRepeatWhen_2Elem = "IMD"
const TimingRepeatWhen_2ElemMORN TimingRepeatWhen_2Elem = "MORN"
const TimingRepeatWhen_2ElemMORNEarly TimingRepeatWhen_2Elem = "MORN.early"
const TimingRepeatWhen_2ElemMORNLate TimingRepeatWhen_2Elem = "MORN.late"
const TimingRepeatWhen_2ElemNIGHT TimingRepeatWhen_2Elem = "NIGHT"
const TimingRepeatWhen_2ElemNOON TimingRepeatWhen_2Elem = "NOON"
const TimingRepeatWhen_2ElemPC TimingRepeatWhen_2Elem = "PC"
const TimingRepeatWhen_2ElemPCD TimingRepeatWhen_2Elem = "PCD"
const TimingRepeatWhen_2ElemPCM TimingRepeatWhen_2Elem = "PCM"
const TimingRepeatWhen_2ElemPCV TimingRepeatWhen_2Elem = "PCV"
const TimingRepeatWhen_2ElemPHS TimingRepeatWhen_2Elem = "PHS"
const TimingRepeatWhen_2ElemWAKE TimingRepeatWhen_2Elem = "WAKE"

var enumValues_TimingRepeatWhen_2Elem = []interface{}{
	"MORN",
	"MORN.early",
	"MORN.late",
	"NOON",
	"AFT",
	"AFT.early",
	"AFT.late",
	"EVE",
	"EVE.early",
	"EVE.late",
	"NIGHT",
	"PHS",
	"IMD",
	"HS",
	"WAKE",
	"C",
	"CM",
	"CD",
	"CV",
	"AC",
	"ACM",
	"ACD",
	"ACV",
	"PC",
	"PCM",
	"PCD",
	"PCV",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimingRepeatWhen_2Elem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimingRepeatWhen_2Elem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimingRepeatWhen_2Elem, v)
	}
	*j = TimingRepeatWhen_2Elem(v)
	return nil
}

// A description of a triggering event. Triggering events can be named events, data
// events, or periodic, as determined by the type element.
type TriggerDefinition struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for timingDate
	TimingDate *Element `json:"_timingDate,omitempty"`

	// Extensions for timingDateTime
	TimingDateTime *Element `json:"_timingDateTime,omitempty"`

	// Extensions for type
	Type *Element `json:"_type,omitempty"`

	// A code that identifies the event.
	Code *CodeableConcept `json:"code,omitempty"`

	// A boolean-valued expression that is evaluated in the context of the container
	// of the trigger definition and returns whether or not the trigger fires.
	Condition *Expression `json:"condition,omitempty"`

	// The triggering data of the event (if this is a data trigger). If more than one
	// data is requirement is specified, then all the data requirements must be true.
	Data []DataRequirement `json:"data,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A formal name for the event. This may be an absolute URI that identifies the
	// event formally (e.g. from a trigger registry), or a simple relative URI that
	// identifies the event in a local context.
	Name_2 *String `json:"name,omitempty"`

	// A reference to a SubscriptionTopic resource that defines the event. If this
	// element is provided, no other information about the trigger definition may be
	// supplied.
	SubscriptionTopic *Canonical `json:"subscriptionTopic,omitempty"`

	// The timing of the event (if this is a periodic trigger).
	TimingDate_2 *string `json:"timingDate,omitempty"`

	// The timing of the event (if this is a periodic trigger).
	TimingDateTime_2 *string `json:"timingDateTime,omitempty"`

	// The timing of the event (if this is a periodic trigger).
	TimingTiming *Timing `json:"timingTiming,omitempty"`

	// The type of triggering event.
	Type_2 *TriggerDefinitionType_2 `json:"type,omitempty"`
}

type TriggerDefinitionType_2 string

const TriggerDefinitionType_2_DataAccessEnded TriggerDefinitionType_2 = "data-access-ended"
const TriggerDefinitionType_2_DataAccessed TriggerDefinitionType_2 = "data-accessed"
const TriggerDefinitionType_2_DataAdded TriggerDefinitionType_2 = "data-added"
const TriggerDefinitionType_2_DataChanged TriggerDefinitionType_2 = "data-changed"
const TriggerDefinitionType_2_DataModified TriggerDefinitionType_2 = "data-modified"
const TriggerDefinitionType_2_DataRemoved TriggerDefinitionType_2 = "data-removed"
const TriggerDefinitionType_2_NamedEvent TriggerDefinitionType_2 = "named-event"
const TriggerDefinitionType_2_Periodic TriggerDefinitionType_2 = "periodic"
const TriggerDefinitionType_2_SubscriptionTopic TriggerDefinitionType_2 = "subscription-topic"

var enumValues_TriggerDefinitionType_2 = []interface{}{
	"named-event",
	"periodic",
	"data-changed",
	"data-added",
	"data-modified",
	"data-removed",
	"data-accessed",
	"data-access-ended",
	"subscription-topic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TriggerDefinitionType_2) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TriggerDefinitionType_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TriggerDefinitionType_2, v)
	}
	*j = TriggerDefinitionType_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TriggerDefinition) UnmarshalJSON(value []byte) error {
	type Plain TriggerDefinition
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TimingDate_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`, string(*plain.TimingDate_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDate_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$`)
		}
	}
	if plain.TimingDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.TimingDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TimingDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	*j = TriggerDefinition(plain)
	return nil
}

// An integer with a value that is not negative (e.g. >= 0)
type UnsignedInt float64

// String of characters used to identify a name or a resource
type Uri string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Uri) UnmarshalJSON(value []byte) error {
	type Plain Uri
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^\S*$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^\S*$`)
	}
	*j = Uri(plain)
	return nil
}

// A URI that is a literal reference
type Url string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Url) UnmarshalJSON(value []byte) error {
	type Plain Url
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^\S*$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^\S*$`)
	}
	*j = Url(plain)
	return nil
}

// Specifies clinical/business/etc. metadata that can be used to retrieve, index
// and/or categorize an artifact. This metadata can either be specific to the
// applicable population (e.g., age category, DRG) or the specific context of care
// (e.g., venue, care setting, provider of care).
type UsageContext struct {
	// A code that identifies the type of context being specified by this usage
	// context.
	Code Coding `json:"code"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// A value that defines the context specified in this context of use. The
	// interpretation of the value is defined by the code.
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`

	// A value that defines the context specified in this context of use. The
	// interpretation of the value is defined by the code.
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`

	// A value that defines the context specified in this context of use. The
	// interpretation of the value is defined by the code.
	ValueRange *Range `json:"valueRange,omitempty"`

	// A value that defines the context specified in this context of use. The
	// interpretation of the value is defined by the code.
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UsageContext) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in UsageContext: required")
	}
	type Plain UsageContext
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UsageContext(plain)
	return nil
}

// A UUID, represented as a URI
type Uuid string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Uuid) UnmarshalJSON(value []byte) error {
	type Plain Uuid
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
	}
	*j = Uuid(plain)
	return nil
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSet struct {
	// Extensions for approvalDate
	ApprovalDate *Element `json:"_approvalDate,omitempty"`

	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for copyrightLabel
	CopyrightLabel *Element `json:"_copyrightLabel,omitempty"`

	// Extensions for date
	Date *Element `json:"_date,omitempty"`

	// Extensions for description
	Description *Element `json:"_description,omitempty"`

	// Extensions for experimental
	Experimental *Element `json:"_experimental,omitempty"`

	// Extensions for immutable
	Immutable *Element `json:"_immutable,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for lastReviewDate
	LastReviewDate *Element `json:"_lastReviewDate,omitempty"`

	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for publisher
	Publisher *Element `json:"_publisher,omitempty"`

	// Extensions for purpose
	Purpose *Element `json:"_purpose,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Extensions for title
	Title *Element `json:"_title,omitempty"`

	// Extensions for url
	Url *Element `json:"_url,omitempty"`

	// Extensions for usage
	Usage *Element `json:"_usage,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Extensions for versionAlgorithmString
	VersionAlgorithmString *Element `json:"_versionAlgorithmString,omitempty"`

	// The date on which the resource content was approved by the publisher. Approval
	// happens once when the content is officially approved for usage.
	ApprovalDate_2 *Date `json:"approvalDate,omitempty"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the ValueSet.
	Author []ContactDetail `json:"author,omitempty"`

	// A set of criteria that define the contents of the value set by including or
	// excluding codes selected from the specified code system(s) that the value set
	// draws from. This is also known as the Content Logical Definition (CLD).
	Compose *ValueSetCompose `json:"compose,omitempty"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []ContactDetail `json:"contact,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []ValueSetContainedElem `json:"contained,omitempty"`

	// A copyright statement relating to the value set and/or its contents. Copyright
	// statements are notices of intellectual property ownership and can include
	// restrictions on the use and publishing of the value set.
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// A short string (<50 characters), suitable for inclusion in a page footer that
	// identifies the copyright holder, effective period, and optionally whether
	// rights are restricted. (e.g. 'All rights reserved', 'Some rights reserved').
	CopyrightLabel_2 *String `json:"copyrightLabel,omitempty"`

	// The date (and optionally time) when the value set metadata or content logical
	// definition (.compose) was created or revised.
	Date_2 *DateTime `json:"date,omitempty"`

	// A free text natural language description of the value set from a consumer's
	// perspective. The textual description specifies the span of meanings for
	// concepts to be included within the Value Set Expansion, and also may specify
	// the intended use and limitations of the Value Set.
	Description_2 *Markdown `json:"description,omitempty"`

	// An individual or organization primarily responsible for internal coherence of
	// the ValueSet.
	Editor []ContactDetail `json:"editor,omitempty"`

	// The period during which the ValueSet content was or is planned to be in active
	// use.
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`

	// An individual or organization asserted by the publisher to be responsible for
	// officially endorsing the ValueSet for use in some setting.
	Endorser []ContactDetail `json:"endorser,omitempty"`

	// A value set can also be "expanded", where the value set is turned into a simple
	// collection of enumerated codes. This element holds the expansion, if it has
	// been performed.
	Expansion *ValueSetExpansion `json:"expansion,omitempty"`

	// A Boolean value to indicate that this value set is authored for testing
	// purposes (or education/evaluation/marketing) and no version of this resource
	// will ever be intended for genuine usage.
	Experimental_2 *Boolean `json:"experimental,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A formal identifier that is used to identify this value set when it is
	// represented in other formats, or referenced in a specification, model, design
	// or an instance.
	Identifier []Identifier `json:"identifier,omitempty"`

	// If this is set to 'true', then no new versions of the content logical
	// definition can be created.  Note: Other metadata might still change.
	Immutable_2 *Boolean `json:"immutable,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// A legal or geographic region in which the authority that maintains the resource
	// is operating.  In general, the jurisdiction is also found in the useContext.
	// The useContext may reference additional jurisdictions because the defining
	// jurisdiction does not necessarily limit the jurisdictions of use.
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate_2 *Date `json:"lastReviewDate,omitempty"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A natural language name identifying the value set. This name should be usable
	// as an identifier for the module by machine processing applications such as code
	// generation.
	Name_2 *String `json:"name,omitempty"`

	// The name of the organization or individual responsible for the release and
	// ongoing maintenance of the value set.
	Publisher_2 *String `json:"publisher,omitempty"`

	// Explanation of why this value set is needed and why it has been designed as it
	// has.
	Purpose_2 *Markdown `json:"purpose,omitempty"`

	// Related artifacts such as additional documentation, justification,
	// dependencies, bibliographic references, and predecessor and successor
	// artifacts.
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`

	// This is a ValueSet resource
	ResourceType interface{} `json:"resourceType"`

	// An individual or organization asserted by the publisher to be primarily
	// responsible for review of some aspect of the ValueSet.
	Reviewer []ContactDetail `json:"reviewer,omitempty"`

	// The status of this value set. Enables tracking the life-cycle of the content.
	// The status of the value set applies to the value set definition
	// (ValueSet.compose) and the associated ValueSet metadata. Expansions do not have
	// a state.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`

	// A short, descriptive, user-friendly title for the value set.
	Title_2 *String `json:"title,omitempty"`

	// Descriptions related to the content of the ValueSet. Topics provide a
	// high-level categorization as well as keywords for the ValueSet that can be
	// useful for filtering and searching.
	Topic []CodeableConcept `json:"topic,omitempty"`

	// An absolute URI that is used to identify this value set when it is referenced
	// in a specification, model, design or an instance; also called its canonical
	// identifier. This SHOULD be globally unique and SHOULD be a literal address at
	// which an authoritative instance of this value set is (or will be) published.
	// This URL can be the target of a canonical reference. It SHALL remain the same
	// when the value set is stored on different servers.
	Url_2 *Uri `json:"url,omitempty"`

	// A detailed description of how the {{title}} is used from a clinical/user
	// perspective.
	Usage_2 *Markdown `json:"usage,omitempty"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...) or
	// may be references to specific programs (insurance plans, studies, ...) and may
	// be used to assist with indexing and searching for appropriate value set
	// instances.
	UseContext []UsageContext `json:"useContext,omitempty"`

	// The identifier that is used to identify this version of the value set when it
	// is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the value set author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version_2 *String `json:"version,omitempty"`

	// Indicates the mechanism used to compare versions to determine which ValueSet is
	// more current.
	VersionAlgorithmCoding *Coding `json:"versionAlgorithmCoding,omitempty"`

	// Indicates the mechanism used to compare versions to determine which ValueSet is
	// more current.
	VersionAlgorithmString_2 *string `json:"versionAlgorithmString,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetCompose struct {
	// Extensions for inactive
	Inactive *Element `json:"_inactive,omitempty"`

	// Extensions for lockedDate
	LockedDate *Element `json:"_lockedDate,omitempty"`

	// Extensions for property
	Property []Element `json:"_property,omitempty"`

	// Exclude one or more codes from the value set based on code system filters
	// and/or other value sets.
	Exclude []ValueSetInclude `json:"exclude,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Whether inactive codes - codes that are not approved for current use - are in
	// the value set. If inactive = true, inactive codes are to be included in the
	// expansion, if inactive = false, the inactive codes will not be included in the
	// expansion. If absent, the behavior is determined by the implementation, or by
	// the applicable $expand parameters (but generally, inactive codes would be
	// expected to be included).
	Inactive_2 *Boolean `json:"inactive,omitempty"`

	// Include one or more codes from a code system or other value set(s).
	Include []ValueSetInclude `json:"include"`

	// The Locked Date is  the effective date that is used to determine the version of
	// all referenced Code Systems and Value Set Definitions included in the compose
	// that are not already tied to a specific version.
	LockedDate_2 *Date `json:"lockedDate,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A property to return in the expansion, if the client doesn't ask for any
	// particular properties. May be either a code from the code system definition
	// (convenient) or a the formal URI that refers to the property. The special value
	// '*' means all properties known to the server.
	Property_2 []String `json:"property,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueSetCompose) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["include"]; raw != nil && !ok {
		return fmt.Errorf("field include in ValueSetCompose: required")
	}
	type Plain ValueSetCompose
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ValueSetCompose(plain)
	return nil
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetConcept struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Specifies a code for the concept to be included or excluded.
	Code_2 *Code `json:"code,omitempty"`

	// Additional representations for this concept when used in this value set - other
	// languages, aliases, specialized purposes, used for particular purposes, etc.
	Designation []ValueSetDesignation `json:"designation,omitempty"`

	// The text to display to the user for this concept in the context of this
	// valueset. If no display is provided, then applications using the value set use
	// the display specified for the code by the system.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

type ValueSetContainedElem interface{}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetContains struct {
	// Extensions for abstract
	Abstract *Element `json:"_abstract,omitempty"`

	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for display
	Display *Element `json:"_display,omitempty"`

	// Extensions for inactive
	Inactive *Element `json:"_inactive,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// If true, this entry is included in the expansion for navigational purposes, and
	// the user cannot select the code directly as a proper value.
	Abstract_2 *Boolean `json:"abstract,omitempty"`

	// The code for this item in the expansion hierarchy. If this code is missing the
	// entry in the hierarchy is a place holder (abstract) and does not represent a
	// valid code in the value set.
	Code_2 *Code `json:"code,omitempty"`

	// Other codes and entries contained under this entry in the hierarchy.
	Contains []ValueSetContains `json:"contains,omitempty"`

	// Additional representations for this item - other languages, aliases,
	// specialized purposes, used for particular purposes, etc. These are relevant
	// when the conditions of the expansion do not fix to a single correct
	// representation.
	Designation []ValueSetDesignation `json:"designation,omitempty"`

	// The recommended display for this item in the expansion.
	Display_2 *String `json:"display,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// If the concept is inactive in the code system that defines it. Inactive codes
	// are those that are no longer to be used, but are maintained by the code system
	// for understanding legacy data. It might not be known or specified whether a
	// concept is inactive (and it may depend on the context of use).
	Inactive_2 *Boolean `json:"inactive,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A property value for this concept.
	Property []ValueSetProperty1 `json:"property,omitempty"`

	// An absolute URI which is the code system in which the code for this item in the
	// expansion is defined.
	System_2 *Uri `json:"system,omitempty"`

	// The version of the code system from this code was taken. Note that a
	// well-maintained code system does not need the version reported, because the
	// meaning of codes is consistent across versions. However this cannot
	// consistently be assured, and when the meaning is not guaranteed to be
	// consistent, the version SHOULD be exchanged.
	Version_2 *String `json:"version,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetDesignation struct {
	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// Additional codes that detail how this designation would be used, if there is
	// more than one use.
	AdditionalUse []Coding `json:"additionalUse,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// The language this designation is defined for.
	Language_2 *Code `json:"language,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A code that represents types of uses of designations.
	Use *Coding `json:"use,omitempty"`

	// The text value for this designation.
	Value_2 *String `json:"value,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetExpansion struct {
	// Extensions for identifier
	Identifier *Element `json:"_identifier,omitempty"`

	// Extensions for next
	Next *Element `json:"_next,omitempty"`

	// Extensions for offset
	Offset *Element `json:"_offset,omitempty"`

	// Extensions for timestamp
	Timestamp *Element `json:"_timestamp,omitempty"`

	// Extensions for total
	Total *Element `json:"_total,omitempty"`

	// The codes that are contained in the value set expansion.
	Contains []ValueSetContains `json:"contains,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// An identifier that uniquely identifies this expansion of the valueset, based on
	// a unique combination of the provided parameters, the system default parameters,
	// and the underlying system code system versions etc. Systems may re-use the same
	// identifier as long as those factors remain the same, and the expansion is the
	// same, but are not required to do so. This is a business identifier.
	Identifier_2 *Uri `json:"identifier,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// As per paging Search results, the next URLs are opaque to the client, have no
	// dictated structure, and only the server understands them.
	Next_2 *Uri `json:"next,omitempty"`

	// If paging is being used, the offset at which this resource starts.  I.e. this
	// resource is a partial view into the expansion. If paging is not being used,
	// this element SHALL NOT be present.
	Offset_2 *Integer `json:"offset,omitempty"`

	// A parameter that controlled the expansion process. These parameters may be used
	// by users of expanded value sets to check whether the expansion is suitable for
	// a particular purpose, or to pick the correct expansion.
	Parameter []ValueSetParameter `json:"parameter,omitempty"`

	// A property defines an additional slot through which additional information can
	// be provided about a concept.
	Property []ValueSetProperty `json:"property,omitempty"`

	// The time at which the expansion was produced by the expanding system.
	Timestamp_2 *DateTime `json:"timestamp,omitempty"`

	// The total number of concepts in the expansion. If the number of concept nodes
	// in this resource is less than the stated number, then the server can return
	// more using the offset parameter.
	Total_2 *Integer `json:"total,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetFilter struct {
	// Extensions for op
	Op *Element `json:"_op,omitempty"`

	// Extensions for property
	Property *Element `json:"_property,omitempty"`

	// Extensions for value
	Value *Element `json:"_value,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The kind of operation to perform as a part of the filter criteria.
	Op_2 *Code `json:"op,omitempty"`

	// A code that identifies a property or a filter defined in the code system.
	Property_2 *Code `json:"property,omitempty"`

	// ValueSet.compose.include.filter.value is represented as a string, and the
	// string value must be [as described](valueset.html#filter-values).
	Value_2 *String `json:"value,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetInclude struct {
	// Extensions for copyright
	Copyright *Element `json:"_copyright,omitempty"`

	// Extensions for system
	System *Element `json:"_system,omitempty"`

	// Extensions for version
	Version *Element `json:"_version,omitempty"`

	// Specifies a concept to be included or excluded.
	Concept []ValueSetConcept `json:"concept,omitempty"`

	// A copyright statement for the specific code system asserted by the containing
	// ValueSet.compose.include element's system value (if the associated
	// ValueSet.compose.include.version element is not present); or the code system
	// and version combination (if the associated ValueSet.compose.include.version
	// element is present).
	Copyright_2 *Markdown `json:"copyright,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Select concepts by specifying a matching criterion based on the properties
	// (including relationships) defined by the system, or on filters defined by the
	// system. If multiple filters are specified within the include, they SHALL all be
	// true.
	Filter []ValueSetFilter `json:"filter,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// An absolute URI which is the code system from which the selected codes come
	// from.
	System_2 *Uri `json:"system,omitempty"`

	// Selects the concepts found in this value set (based on its value set
	// definition). This is an absolute URI that is a reference to ValueSet.url.  If
	// multiple value sets are specified this includes the intersection of the
	// contents of all of the referenced value sets.
	ValueSet []Canonical `json:"valueSet,omitempty"`

	// The version of the code system that the codes are selected from, or the special
	// version '*' for all versions.
	Version_2 *String `json:"version,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetParameter struct {
	// Extensions for name
	Name *Element `json:"_name,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// Extensions for valueUri
	ValueUri *Element `json:"_valueUri,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Name of the input parameter to the $expand operation; may be a server-assigned
	// name for additional default or other server-supplied parameters used to control
	// the expansion process.
	Name_2 *String `json:"name,omitempty"`

	// The value of the parameter.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of the parameter.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of the parameter.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of the parameter.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of the parameter.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of the parameter.
	ValueString_2 *string `json:"valueString,omitempty"`

	// The value of the parameter.
	ValueUri_2 *string `json:"valueUri,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueSetParameter) UnmarshalJSON(value []byte) error {
	type Plain ValueSetParameter
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.ValueUri_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.ValueUri_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueUri_2", `^\S*$`)
		}
	}
	*j = ValueSetParameter(plain)
	return nil
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetProperty struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for uri
	Uri *Element `json:"_uri,omitempty"`

	// A code that is used to identify the property. The code is used in
	// ValueSet.expansion.contains.property.code.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Reference to the formal meaning of the property. One possible source of meaning
	// is the [Concept Properties](codesystem-concept-properties.html) code system.
	Uri_2 *Uri `json:"uri,omitempty"`
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetProperty1 struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A code that is a reference to ValueSet.expansion.property.code.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A subproperty value for this concept.
	SubProperty []ValueSetSubProperty `json:"subProperty,omitempty"`

	// The value of this property.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of this property.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of this property.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of this property.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of this property.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of this property.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of this property.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueSetProperty1) UnmarshalJSON(value []byte) error {
	type Plain ValueSetProperty1
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ValueSetProperty1(plain)
	return nil
}

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link between
// [CodeSystem](codesystem.html) definitions and their use in [coded
// elements](terminologies.html).
type ValueSetSubProperty struct {
	// Extensions for code
	Code *Element `json:"_code,omitempty"`

	// Extensions for valueBoolean
	ValueBoolean *Element `json:"_valueBoolean,omitempty"`

	// Extensions for valueCode
	ValueCode *Element `json:"_valueCode,omitempty"`

	// Extensions for valueDateTime
	ValueDateTime *Element `json:"_valueDateTime,omitempty"`

	// Extensions for valueDecimal
	ValueDecimal *Element `json:"_valueDecimal,omitempty"`

	// Extensions for valueInteger
	ValueInteger *Element `json:"_valueInteger,omitempty"`

	// Extensions for valueString
	ValueString *Element `json:"_valueString,omitempty"`

	// A code that is a reference to ValueSet.expansion.property.code.
	Code_2 *Code `json:"code,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// The value of this subproperty.
	ValueBoolean_2 *bool `json:"valueBoolean,omitempty"`

	// The value of this subproperty.
	ValueCode_2 *string `json:"valueCode,omitempty"`

	// The value of this subproperty.
	ValueCoding *Coding `json:"valueCoding,omitempty"`

	// The value of this subproperty.
	ValueDateTime_2 *string `json:"valueDateTime,omitempty"`

	// The value of this subproperty.
	ValueDecimal_2 *float64 `json:"valueDecimal,omitempty"`

	// The value of this subproperty.
	ValueInteger_2 *float64 `json:"valueInteger,omitempty"`

	// The value of this subproperty.
	ValueString_2 *string `json:"valueString,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueSetSubProperty) UnmarshalJSON(value []byte) error {
	type Plain ValueSetSubProperty
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ValueCode_2 != nil {
		if matched, _ := regexp.MatchString(`^[^\s]+( [^\s]+)*$`, string(*plain.ValueCode_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueCode_2", `^[^\s]+( [^\s]+)*$`)
		}
	}
	if plain.ValueDateTime_2 != nil {
		if matched, _ := regexp.MatchString(`^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`, string(*plain.ValueDateTime_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueDateTime_2", `^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)?)?)?)?)?$`)
		}
	}
	if plain.ValueString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.ValueString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "ValueString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ValueSetSubProperty(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueSet) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in ValueSet: required")
	}
	type Plain ValueSet
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.VersionAlgorithmString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.VersionAlgorithmString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VersionAlgorithmString_2", `^^[\s\S]+$$`)
		}
	}
	*j = ValueSet(plain)
	return nil
}

// The set of values required to describe a virtual service's connection details,
// including some limitations of the service.
type VirtualServiceDetail struct {
	// Extensions for additionalInfo
	AdditionalInfo []Element `json:"_additionalInfo,omitempty"`

	// Extensions for addressString
	AddressString *Element `json:"_addressString,omitempty"`

	// Extensions for addressUrl
	AddressUrl *Element `json:"_addressUrl,omitempty"`

	// Extensions for maxParticipants
	MaxParticipants *Element `json:"_maxParticipants,omitempty"`

	// Extensions for sessionKey
	SessionKey *Element `json:"_sessionKey,omitempty"`

	// A web address that provides additional details on the call, such as
	// alternative/regional call in numbers, or other associated services.
	AdditionalInfo_2 []Url `json:"additionalInfo,omitempty"`

	// What address or number needs to be used for a user to connect to the virtual
	// service to join. The channelType informs as to which datatype is appropriate to
	// use (requires knowledge of the specific type).
	AddressContactPoint *ContactPoint `json:"addressContactPoint,omitempty"`

	// What address or number needs to be used for a user to connect to the virtual
	// service to join. The channelType informs as to which datatype is appropriate to
	// use (requires knowledge of the specific type).
	AddressExtendedContactDetail *ExtendedContactDetail `json:"addressExtendedContactDetail,omitempty"`

	// What address or number needs to be used for a user to connect to the virtual
	// service to join. The channelType informs as to which datatype is appropriate to
	// use (requires knowledge of the specific type).
	AddressString_2 *string `json:"addressString,omitempty"`

	// What address or number needs to be used for a user to connect to the virtual
	// service to join. The channelType informs as to which datatype is appropriate to
	// use (requires knowledge of the specific type).
	AddressUrl_2 *string `json:"addressUrl,omitempty"`

	// The type of virtual service to connect to (i.e. Teams, Zoom, Specific VMR
	// technology, WhatsApp).
	ChannelType *Coding `json:"channelType,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// Maximum number of participants supported by the virtual service where there are
	// limitations imposed.
	MaxParticipants_2 *PositiveInt `json:"maxParticipants,omitempty"`

	// Some systems require an additional factor/value be provided to access the
	// service.
	SessionKey_2 *String `json:"sessionKey,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualServiceDetail) UnmarshalJSON(value []byte) error {
	type Plain VirtualServiceDetail
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AddressString_2 != nil {
		if matched, _ := regexp.MatchString(`^^[\s\S]+$$`, string(*plain.AddressString_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AddressString_2", `^^[\s\S]+$$`)
		}
	}
	if plain.AddressUrl_2 != nil {
		if matched, _ := regexp.MatchString(`^\S*$`, string(*plain.AddressUrl_2)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AddressUrl_2", `^\S*$`)
		}
	}
	*j = VirtualServiceDetail(plain)
	return nil
}

// An authorization for the provision of glasses and/or contact lenses to a
// patient.
type VisionPrescription struct {
	// Extensions for created
	Created *Element `json:"_created,omitempty"`

	// Extensions for dateWritten
	DateWritten *Element `json:"_dateWritten,omitempty"`

	// Extensions for implicitRules
	ImplicitRules *Element `json:"_implicitRules,omitempty"`

	// Extensions for language
	Language *Element `json:"_language,omitempty"`

	// Extensions for priority
	Priority *Element `json:"_priority,omitempty"`

	// Extensions for status
	Status *Element `json:"_status,omitempty"`

	// Plan/proposal/order/request fulfilled by this prescription.
	BasedOn []Reference `json:"basedOn,omitempty"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, nor can they have
	// their own independent transaction scope. This is allowed to be a Parameters
	// resource if and only if it is referenced by a resource that provides
	// context/meaning.
	Contained []VisionPrescriptionContainedElem `json:"contained,omitempty"`

	// The date this resource was created.
	Created_2 *DateTime `json:"created,omitempty"`

	// The date (and perhaps time) when the prescription was written.
	DateWritten_2 *DateTime `json:"dateWritten,omitempty"`

	// A reference to a resource that identifies the particular occurrence of contact
	// between patient and health care provider during which the prescription was
	// issued.
	Encounter *Reference `json:"encounter,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// A shared identifier common to all Vision Prescriptions that were authorized
	// more or less simultaneously by a single author, representing the composite or
	// group identifier.
	GroupIdentifier *Identifier `json:"groupIdentifier,omitempty"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID *ID `json:"id,omitempty"`

	// A unique identifier assigned to this vision prescription.
	Identifier []Identifier `json:"identifier,omitempty"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content. Often,
	// this is a reference to an implementation guide that defines the special rules
	// along with other profiles etc. For DomainResources, if more than one
	// implicitRules policy applies, additional policies may be conveyed using the
	// [additionalImplicitRules](https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-additionalImplicitRules.html)
	// extension.
	ImplicitRules_2 *Uri `json:"implicitRules,omitempty"`

	// The base language in which the resource is written.
	Language_2 *Code `json:"language,omitempty"`

	// Contain the details of  the individual lens specifications and serves as the
	// authorization for the fullfillment by certified professionals.
	LensSpecification []VisionPrescriptionLensSpecification `json:"lensSpecification"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *Meta `json:"meta,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the resource and that modifies the understanding of the element
	// that contains it and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer is allowed to define an extension, there is a set of requirements
	// that SHALL be met as part of the definition of the extension. Applications
	// processing a resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// A resource reference to the person to whom the vision prescription applies.
	Patient Reference `json:"patient"`

	// The healthcare professional responsible for authorizing the prescription.
	Prescriber Reference `json:"prescriber"`

	// Indicates how quickly the vision prescription should be addressed with respect
	// to other requests.
	Priority_2 *Code `json:"priority,omitempty"`

	// This is a VisionPrescription resource
	ResourceType interface{} `json:"resourceType"`

	// The status of the resource instance.
	Status_2 *Code `json:"status,omitempty"`

	// A human-readable narrative that contains a summary of the resource and can be
	// used to represent the content of the resource to a human. The narrative need
	// not encode all the structured data, but is required to contain sufficient
	// detail to make it "clinically safe" for a human to just read the narrative.
	// Resource definitions may define what content should be represented in the
	// narrative to ensure clinical safety.
	Text *Narrative `json:"text,omitempty"`
}

type VisionPrescriptionContainedElem interface{}

// An authorization for the provision of glasses and/or contact lenses to a
// patient.
type VisionPrescriptionLensSpecification struct {
	// Extensions for add
	Add *Element `json:"_add,omitempty"`

	// Extensions for axis
	Axis *Element `json:"_axis,omitempty"`

	// Extensions for backCurve
	BackCurve *Element `json:"_backCurve,omitempty"`

	// Extensions for brand
	Brand *Element `json:"_brand,omitempty"`

	// Extensions for color
	Color *Element `json:"_color,omitempty"`

	// Extensions for cylinder
	Cylinder *Element `json:"_cylinder,omitempty"`

	// Extensions for diameter
	Diameter *Element `json:"_diameter,omitempty"`

	// Extensions for eye
	Eye *Element `json:"_eye,omitempty"`

	// Extensions for power
	Power *Element `json:"_power,omitempty"`

	// Extensions for sphere
	Sphere *Element `json:"_sphere,omitempty"`

	// Power adjustment for multifocal lenses measured in dioptres (0.25 units).
	Add_2 *Decimal `json:"add,omitempty"`

	// Adjustment for astigmatism measured in integer degrees.
	Axis_2 *Integer `json:"axis,omitempty"`

	// Back curvature measured in millimetres.
	BackCurve_2 *Decimal `json:"backCurve,omitempty"`

	// Brand recommendations or restrictions.
	Brand_2 *String `json:"brand,omitempty"`

	// Special color or pattern.
	Color_2 *String `json:"color,omitempty"`

	// Power adjustment for astigmatism measured in dioptres (0.25 units).
	Cylinder_2 *Decimal `json:"cylinder,omitempty"`

	// Contact lens diameter measured in millimetres.
	Diameter_2 *Decimal `json:"diameter,omitempty"`

	// The recommended maximum wear period for the lens.
	Duration *Quantity `json:"duration,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// The eye for which the lens specification applies.
	Eye_2 *Code `json:"eye,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`

	// Notes for special requirements such as coatings and lens materials.
	Note []Annotation `json:"note,omitempty"`

	// Contact lens power measured in dioptres (0.25 units).
	Power_2 *Decimal `json:"power,omitempty"`

	// Allows for adjustment on two axis.
	Prism []VisionPrescriptionPrism `json:"prism,omitempty"`

	// Identifies the type of vision correction product which is required for the
	// patient.
	Product CodeableConcept `json:"product"`

	// Lens power measured in dioptres (0.25 units).
	Sphere_2 *Decimal `json:"sphere,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VisionPrescriptionLensSpecification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["product"]; raw != nil && !ok {
		return fmt.Errorf("field product in VisionPrescriptionLensSpecification: required")
	}
	type Plain VisionPrescriptionLensSpecification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = VisionPrescriptionLensSpecification(plain)
	return nil
}

// An authorization for the provision of glasses and/or contact lenses to a
// patient.
type VisionPrescriptionPrism struct {
	// Extensions for amount
	Amount *Element `json:"_amount,omitempty"`

	// Extensions for base
	Base *Element `json:"_base,omitempty"`

	// Amount of prism to compensate for eye alignment in fractional units.
	Amount_2 *Decimal `json:"amount,omitempty"`

	// The relative base, or reference lens edge, for the prism.
	Base_2 *Code `json:"base,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element. To make the use of extensions safe and managable,
	// there is a strict set of governance applied to the definition and use of
	// extensions. Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	Extension []Extension `json:"extension,omitempty"`

	// Unique id for the element within a resource (for internal references). This may
	// be any string value that does not contain spaces.
	ID *String `json:"id,omitempty"`

	// May be used to represent additional information that is not part of the basic
	// definition of the element and that modifies the understanding of the element in
	// which it is contained and/or the understanding of the containing element's
	// descendants. Usually modifier elements provide negation or qualification. To
	// make the use of extensions safe and managable, there is a strict set of
	// governance applied to the definition and use of extensions. Though any
	// implementer can define an extension, there is a set of requirements that SHALL
	// be met as part of the definition of the extension. Applications processing a
	// resource are required to check for modifier extensions.
	//
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource or
	// DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VisionPrescription) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["lensSpecification"]; raw != nil && !ok {
		return fmt.Errorf("field lensSpecification in VisionPrescription: required")
	}
	if _, ok := raw["patient"]; raw != nil && !ok {
		return fmt.Errorf("field patient in VisionPrescription: required")
	}
	if _, ok := raw["prescriber"]; raw != nil && !ok {
		return fmt.Errorf("field prescriber in VisionPrescription: required")
	}
	if _, ok := raw["resourceType"]; raw != nil && !ok {
		return fmt.Errorf("field resourceType in VisionPrescription: required")
	}
	type Plain VisionPrescription
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = VisionPrescription(plain)
	return nil
}

// xhtml - escaped html (see specfication)
type Xhtml interface{}
